<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/blogs/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/blogs/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/blogs/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/blogs/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/blogs/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/blogs/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/blogs/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />




  


  <link rel="alternate" href="/blogs/atom.xml" title="StriveZs的博客" type="application/atom+xml" />






<meta property="og:type" content="website">
<meta property="og:title" content="StriveZs的博客">
<meta property="og:url" content="https://zs670980918.github.io/blogs/page/18/index.html">
<meta property="og:site_name" content="StriveZs的博客">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="StriveZs">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/blogs/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'StriveZs'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://zs670980918.github.io/blogs/page/18/"/>





  <title>StriveZs的博客</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?5c8bbf815dac51a855060f947b787303";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/blogs/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">StriveZs的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/blogs/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/blogs/about/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/blogs/tags/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/blogs/categories/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/blogs/archives/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/blogs/schedule/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br />
            
            Schedule
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/blogs/sitemap.xml%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            Sitemap
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zs670980918.github.io/blogs/blogs/2018/05/15/c-shi-xian-zi-mu-biao-quan-pai-xu/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="StriveZs">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blogs/images/avatar.JPG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="StriveZs的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blogs/2018/05/15/c-shi-xian-zi-mu-biao-quan-pai-xu/" itemprop="url">C++实现字母表全排序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-15T23:22:16+08:00">
                2018-05-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/C-amp-C/" itemprop="url" rel="index">
                    <span itemprop="name">C&amp;C++</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/C-amp-C/%E6%96%87%E7%AB%A0%E9%A1%B5/" itemprop="url" rel="index">
                    <span itemprop="name">文章页</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/C-amp-C/%E6%96%87%E7%AB%A0%E9%A1%B5/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://47.100.4.8/wp-content/uploads/2018/05/%E5%9B%BE%E7%89%87150.png" alt=""> 全排列具体说明： 例如abc会有abc,acb,bac,bca,cab,abc六种情况 采用递归的方法： 先看a作为字母表首位时会有bc和cb两种排序 然后b作为字母表首位时会有ac和ca两种排序 最后是c作为字母表首位时会有ab和ba两种排序   这里就用到了swap（）进行交换。为了每次确保不重复， 第i个数分别与它后面的数字交换就能得到新的排列，这样可以构建一个递归   具体的代码：</p>
<p>#include<iostream><br>#include<cstdio><br>using namespace std;</p>
<p>//采用递归方式进行全排列<br>bool IsSwap(char <em>str, int Begin, int End)<br>{<br>    for (int i = Begin; i &lt; End; i++)<br>        if (str[i] == str[End])<br>            return false;<br>    return true;<br>}<br>int num=1;<br>//k表示当前选取到第几个数,m表示共有多少数.<br>void AllRange(char *str, int k, int m)<br>{<br>    if (k == m)<br>    {<br>        static int s = 1;<br>        cout&lt;&lt;” 第”&lt;&lt;s++&lt;&lt;”个排列”&lt;&lt;str&lt;&lt;endl;;<br>    }<br>    else<br>    {<br>        for (int i = k; i &lt;= m; i++) //第i个数分别与它后面的数字交换就能得到新的排列<br>        {<br>            if (IsSwap(str, k, i))<br>            {<br>                swap(</em>(str + k), <em>(str + i));<br>                AllRange(str, k + 1, m);<br>                swap(</em>(str + k), *(str + i));<br>            }<br>        }<br>    }<br>}</p>
<p>int main()<br>{<br>    int n=0;<br>    cout&lt;&lt;”输入你想要输出的个数：”;<br>    cin&gt;&gt;n;<br>    char str[100]={‘\0’};  //最大容量为100<br>    for(int i =0;i&lt;n;i++)<br>        cin&gt;&gt;str[i];<br>    str[n]=’\0’;<br>    for(int i=1;i&lt;=n;i++)<br>    {<br>        num=num*i;<br>    }<br>    cout&lt;&lt;”全排列总数个数为：”&lt;&lt;num&lt;&lt;endl;<br>    AllRange(str, 0, n-1);<br>    return 0;<br>}</p>
<p>实现： <img src="http://47.100.4.8/wp-content/uploads/2018/05/12314324324.png" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zs670980918.github.io/blogs/blogs/2018/05/14/stl-zhi-priority-queue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="StriveZs">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blogs/images/avatar.JPG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="StriveZs的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blogs/2018/05/14/stl-zhi-priority-queue/" itemprop="url">STL之priority_queue</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-14T23:02:22+08:00">
                2018-05-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/C-amp-C/" itemprop="url" rel="index">
                    <span itemprop="name">C&amp;C++</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/C-amp-C/C-%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index">
                    <span itemprop="name">C++学习</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/C-amp-C/C-%E5%AD%A6%E4%B9%A0/%E6%96%87%E7%AB%A0%E9%A1%B5/" itemprop="url" rel="index">
                    <span itemprop="name">文章页</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://47.100.4.8/wp-content/uploads/2018/05/QQ%E5%9B%BE%E7%89%8720180507183124.png" alt=""> 优先级队列是一个拥有权值概念的单向队列，在这个队列中，所有元素是按优先级排 的。 优先队列容器也是一种从一端入队，另一端出对的队列。不同于一般队列的是，队列中最大的元素总是位于队首位置，因此，元素的出对并非按照先进先出的要求，将最先入队的元素出对，而是将当前队列中的最大元素出对。 C++ STL 优先队列的泛化，底层默认采用 vector 向量容器，使得队列容器的元素可做数组操作，从而应用堆算法找出当前队列最大元素，并将它调整到队首位置，确保最大元素出队。   priority_queue函数列表 构造函数： priority_queue&lt;类型&gt;c   //创建一个空的priority_queue   数据访问与添加和删除: c.top()  //返回队列头部元素 c.push()  //在队列尾部添加元素 c.pop（）  //队列头部数据出队   其他操作： c.empty（）   //判断队列是否为空 c.size（）  //返回队列中数据的个数   有上面函数可以看出其实STL中许多成员函数都是相似的。 同样的priority_queue队列包含在queue头文件中 代码：</p>
<p>#include<iostream><br>#include<queue><br>#include&lt;stdlib.h&gt;</p>
<p>using namespace std;</p>
<p>int main()<br>{<br>    priority_queue<int>test1; //创建一个优先级队列test1  使用vector作为容器<br>    priority_queue<int>test2(test1);  //使用test1调用复制析构函数来初始化test2<br>    cout&lt;&lt;”随机输入五个数据：”;<br>    for(int i=0;i&lt;5;i++)  //向优先级队列添加5个数据<br>    {<br>        int t=rand()%20;<br>        test1.push(t);<br>        cout&lt;&lt;t&lt;&lt;” “;<br>    }<br>    cout&lt;&lt;endl;<br>    cout&lt;&lt;”当前队列的元素个数：”&lt;&lt;test1.size()&lt;&lt;endl;<br>    cout&lt;&lt;”输出队列数据（通过pop（）方式弹出队列头）：”;<br>    for(int i=0;i&lt;5;i++)<br>    {<br>        int t = test1.top();  //先接受值然后在弹出 因为弹出没有返回值所以才先用top（）<br>        test1.pop();<br>        cout&lt;&lt;t&lt;&lt;” “;<br>    }<br>    cout&lt;&lt;endl;<br>    cout&lt;&lt;”由上面结果可以看出优先级队列会按照输入数据的大小进行排列！”&lt;&lt;endl;<br>    return 0;<br>}</p>
<p>  实现： <img src="http://47.100.4.8/wp-content/uploads/2018/05/4324234234.png" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zs670980918.github.io/blogs/blogs/2018/05/13/stl-zhi-heap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="StriveZs">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blogs/images/avatar.JPG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="StriveZs的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blogs/2018/05/13/stl-zhi-heap/" itemprop="url">STL之heap</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-13T21:30:44+08:00">
                2018-05-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/C-amp-C/" itemprop="url" rel="index">
                    <span itemprop="name">C&amp;C++</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/C-amp-C/C-%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index">
                    <span itemprop="name">C++学习</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/C-amp-C/C-%E5%AD%A6%E4%B9%A0/%E6%96%87%E7%AB%A0%E9%A1%B5/" itemprop="url" rel="index">
                    <span itemprop="name">文章页</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://47.100.4.8/wp-content/uploads/2018/05/QQ%E5%9B%BE%E7%89%8720180507183124.png" alt=""> STL中并没有把heap作为一种容器组件，heap的实现亦需要更低一层的容器组件（诸如list,array,vector）作为其底层机制。Heap是一个类属算法，包含在algorithm头文件中。虽然STL中关于heap默认调整成的是大顶堆，但却可以让用户利用自定义的compare_fuction函数实现大顶堆或小顶堆。heap的低层机制vector本身就是一个类模板，heap基于vector便实现了对各种数据类型（无论基本数据类型还是用户自定义的数据类型）的堆排（前提是用户自定义的数据类型要提供比较机制compare_fuction函数）。   包含在头文件<strong>#include&lt;**</strong>algorithm<strong>**&gt;</strong>  下面的_First与_Last为可以随机访问的迭代器（指针），_Comp为比较函数（仿函数），其规则——如果函数的第一个参数小于第二个参数应返回true，否则返回false。   建立堆 make_heap（_First,_Last,_Comp） 默认是建立最大堆。对int类型，可以在第三个参数传入great<int>（）得到最小堆。   在堆中添加数据 push_heap（_First,_Last） 要先在容器中加入数据，再调用push_heap（）   在堆中删除数据 pop_heap（_First,_Last） 要先调用pop_heap（）再在容器中删除数据   堆排序 sort_heap（_First,_Last） 排序之后就不再是一个合法的heap了   总结： <strong>这里在通过对写下面代码的过程中，对heap有了更进一步的了解。</strong> <strong>个人认为这个堆相关的操作就是算法的集合。</strong> <strong>需要注意的是要创建一个动态容器（vector）：vector<int>*test1=new vector<int>(MAXN);</strong> <strong>以及创建迭代器：vector<int>::iterator pos;方便在遍历容器元素时使用。</strong> <strong>将容器构建成一个堆 make_heap（）将容器放进去。注意由于这里是指针创建的动态容器，所以在调用容器成员时 使用-&gt;进行访问。</strong> <strong>在插入数据时，要先在容器中进行数据插入，然后在堆中插入使用push_heap（）</strong> <strong>在删除数据时，要先从堆中删除数据使用pop_heap（），然后在容器中删除数据</strong> <strong>由于容器中没有排序成员函数，所以这里就体现出了堆中堆排序的重要性。</strong> <strong>sort_heap**</strong>（）** 代码：</p>
<p>#include<iostream><br>#include<vector><br>#include<algorithm><br>#include<functional></p>
<p>using namespace std;</p>
<p>int main()<br>{<br>    int MAXN = 20;<br>    int a[MAXN];<br>    int i;<br>    //创建一个随机数组<br>    for(int i=0;i&lt;MAXN;i++)<br>        a[i] = rand()%(MAXN<em>2);<br>    cout&lt;&lt;”创建一个堆”&lt;&lt;endl;<br>    //创建动态vector容器 并对vector建堆<br>    vector<int></em>test1=new vector<int>(MAXN);<br>    vector<int>::iterator pos;<br>    test1-&gt;assign(a,a+MAXN);<br>    make_heap(test1-&gt;begin(),test1-&gt;end());  //用test1建堆<br>    for(pos = test1-&gt;begin();pos!=test1-&gt;end();pos++)<br>        cout&lt;&lt;<em>pos&lt;&lt;” “;<br>    cout&lt;&lt;endl;<br>    cout&lt;&lt;”在堆中进行插入数据:”&lt;&lt;endl;<br>    //对堆进行新数据插入  要现在容器中加入，在调用push_heap（）<br>    test1-&gt;push_back(25);<br>    push_heap(test1-&gt;begin(),test1-&gt;end());<br>    for(pos = test1-&gt;begin();pos!=test1-&gt;end();pos++)<br>        cout&lt;&lt;</em>pos&lt;&lt;” “;<br>    cout&lt;&lt;endl;<br>    //删除数据  先调用pop_heap（）从堆中删除，然后再在容器中删除<br>    cout&lt;&lt;”删除堆中的数据：”&lt;&lt;endl;<br>    pop_heap(test1-&gt;begin(),test1-&gt;end());  //从堆中弹出一个元素<br>    test1-&gt;pop_back();  //然后在容器中删除该元素<br>    push_heap(test1-&gt;begin(),test1-&gt;end());<br>    test1-&gt;pop_back();<br>    for(pos = test1-&gt;begin();pos!=test1-&gt;end();pos++)<br>        cout&lt;&lt;<em>pos&lt;&lt;” “;<br>    cout&lt;&lt;endl;<br>    //堆排序<br>    cout&lt;&lt;”进行堆排序之后的结果：”&lt;&lt;endl;<br>    sort_heap(test1-&gt;begin(),test1-&gt;end());<br>    for(pos = test1-&gt;begin();pos!=test1-&gt;end();pos++)<br>        cout&lt;&lt;</em>pos&lt;&lt;” “;<br>    cout&lt;&lt;endl;<br>    return 0;<br>}</p>
<p>截图： <img src="http://47.100.4.8/wp-content/uploads/2018/05/453445324324.png" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zs670980918.github.io/blogs/blogs/2018/05/12/fcfs-suan-fa-he-you-xian-ji-diao-du-suan-fa-c-shi-xian/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="StriveZs">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blogs/images/avatar.JPG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="StriveZs的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blogs/2018/05/12/fcfs-suan-fa-he-you-xian-ji-diao-du-suan-fa-c-shi-xian/" itemprop="url">FCFS算法和优先级调度算法C++实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-12T23:15:30+08:00">
                2018-05-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/C-amp-C/" itemprop="url" rel="index">
                    <span itemprop="name">C&amp;C++</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/C-amp-C/%E6%96%87%E7%AB%A0%E9%A1%B5/" itemprop="url" rel="index">
                    <span itemprop="name">文章页</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/C-amp-C/%E6%96%87%E7%AB%A0%E9%A1%B5/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://47.100.4.8/wp-content/uploads/2018/05/%E5%9B%BE%E7%89%87150.png" alt=""> FCFS调度算法（短作业优先） 该算法采用非剥夺策略，算法按照进程提交或进程变为就绪状态的先后次序，分派 CPU。当前进程占用CPU，直到执行完或阻塞，才出让CPU（非抢占方式）。在进程唤醒后（如I/O 完成），并不立即恢复执行，通常等到当前进程出让CPU。这是最简单的调度算法，比较有利于长进程，而不利于短进程，有利于CPU 繁忙的进程，而不利于I/O 繁忙的进程。 算法流程： <img src="http://47.100.4.8/wp-content/uploads/2018/05/QQ%E5%9B%BE%E7%89%8720180512230549.png" alt=""> 代码：</p>
<p>#include<iostream><br>#include<ctime><br>#include <cstdlib><br>#include&lt;windows.h&gt;<br>#include&lt;malloc.h&gt;</p>
<p>using namespace std;<br>#define MAX 5<br>typedef int ElemType;<br>typedef char State;</p>
<p>typedef struct PCB{<br>ElemType flag; //进程标识<br>struct PCB <em>next;//链接指针<br>ElemType arrive; //到达时间<br>ElemType process; //运行时间<br>ElemType start; //开始执行时间<br>ElemType current; //当前状态<br>}PCB,</em>PCBList;</p>
<p>typedef struct{<br>PCBList fronts;<br>PCBList last;<br>}PCBLink;</p>
<p>int flagfull = 0; //定义一个全局变量用来表示当前已有进程在处理机中<br>ElemType times = 1; //初始化全局时间以便确定处理机中进程的开始执行时间<br>int num=0; //总的进程计数器</p>
<p>//进程插入操作<br>void InputList(PCBLink &amp;L,int i)<br>{<br>    PCB *p,*tail,<em>q;<br>    int arrivetime=0,processtime=0;<br>    arrivetime = i*i;<br>    processtime = time((time_t</em>)NULL)%20;  //根据系统当前秒数随机生成运行时间<br>    q=(PCBList)malloc(sizeof(PCB));  //创建列表头节点<br>    if(i==1)<br>    {<br>        L.fronts = L.last = q;<br>        q-&gt;flag = i;  //设置标识符<br>        q-&gt;next = NULL;  //将头指针的后面节点置为空<br>        q-&gt;arrive = arrivetime;  //设置到达时间<br>        q-&gt;start = 0; //初始化开始时间<br>        q-&gt;process = processtime; //设置执行时间<br>        q-&gt;current = 0;  //设置初始状态  R表示就绪 C表示正在运行 O表示运行结束<br>    }<br>    else<br>    {</p>
<pre><code>    p=(PCBList)malloc(sizeof(PCB)); //创建子节点
    p-&gt;flag = i;
    p-&gt;next = NULL;  //将表尾指针设置为空
    p-&gt;current = 0;
    p-&gt;process = processtime;
    p-&gt;start = 0; //初始化开始时间
    p-&gt;arrive = arrivetime;
    L.last-&gt;next = p;  //将p节点插入到表尾
    L.last = p;
}</code></pre><p>}<br>//显示当前就绪队列中的进程的状态<br>void showState(PCBLink &amp;L)<br>{<br>    cout&lt;&lt;endl;<br>    cout&lt;&lt;endl;<br>    PCBList p;<br>    p=(PCBList)malloc(sizeof(PCB));<br>    p=L.fronts;<br>    for(int i=1;i&lt;=MAX;i++)<br>    {<br>       cout&lt;&lt;”进程”&lt;&lt;i&lt;&lt;endl;<br>       cout&lt;&lt;”&lt;—————-创建进程的信息：———————-&gt;”&lt;&lt;endl;<br>       cout&lt;&lt;”进程标识：”&lt;<p->flag&lt;&lt;endl;<br>       cout&lt;&lt;”进程到达时间：”&lt;<p->arrive&lt;&lt;endl;<br>       cout&lt;&lt;”进程开始时间：”&lt;<p->start&lt;&lt;endl;<br>       cout&lt;&lt;”进程执行时间：”&lt;<p->process&lt;&lt;endl;<br>       if(p-&gt;current==-1)<br>        cout&lt;&lt;”进程当前状态为：O”&lt;&lt;endl;<br>       else if(p-&gt;current==0)<br>        cout&lt;&lt;”进程当前状态为：R”&lt;&lt;endl;<br>       else<br>        cout&lt;&lt;”进程当前状态为：C”&lt;&lt;endl;<br>       cout&lt;&lt;”&lt;——————-信息结束：———————-&gt;”&lt;&lt;endl;<br>       p=p-&gt;next;<br>       Sleep(500);<br>    }<br>    cout&lt;&lt;endl;<br>    cout&lt;&lt;endl;<br>}</p>
<p>//处理机进程运行<br>void overprocess(PCBList &amp;p)<br>{<br>    num++;<br>    Sleep(1000);<br>    p-&gt;process–;<br>    p-&gt;current=-1;<br>    cout&lt;&lt;”进程”&lt;&lt;num&lt;&lt;”运行结束！”&lt;&lt;endl;<br>    cout&lt;&lt;”&lt;————–进程信息：———————-&gt;”&lt;&lt;endl;<br>    cout&lt;&lt;”进程标识：”&lt;<p->flag&lt;&lt;endl;<br>    cout&lt;&lt;”进程到达时间：”&lt;<p->arrive&lt;&lt;endl;<br>    cout&lt;&lt;”进程开始时间：”&lt;<p->start&lt;&lt;endl;<br>    cout&lt;&lt;”进程完成时间：”&lt;<p->start + p-&gt;process + 1&lt;&lt;endl;<br>       if(p-&gt;current==-1)<br>        cout&lt;&lt;”进程当前状态为：O”&lt;&lt;endl;<br>       else if(p-&gt;current==0)<br>        cout&lt;&lt;”进程当前状态为：R”&lt;&lt;endl;<br>       else<br>        cout&lt;&lt;”进程当前状态为：C”&lt;&lt;endl;<br>    cout&lt;&lt;”&lt;————–信息结束：———————-&gt;”&lt;&lt;endl;<br>    flagfull=0;<br>}</p>
<p>//将进程调度进处理机中<br>void Scheduling(PCBLink &amp;L)<br>{<br>    if(flagfull == 1)<br>    {<br>        cout&lt;&lt;”当前已有进程在处理机中请等待！”&lt;&lt;endl;<br>    }<br>    else<br>    {<br>        //将进程从就绪队列中删除<br>        PCBList p,j;<br>        p=(PCBList)malloc(sizeof(PCB));<br>        j=(PCBList)malloc(sizeof(PCB));<br>        j=L.fronts;<br>        p = L.fronts-&gt;next;<br>        L.fronts=p;<br>        j-&gt;next = NULL;<br>        //修改信息<br>        //j为当前在处理机中的进程<br>        j-&gt;current = 1;<br>        //处理进程开始执行时间<br>        if(times == 1) //表示第一个进程<br>            {<br>                j-&gt;start = times;<br>                times = j-&gt;process; //为下一次进程开始做准备  这里的time更准确的为下次处理进程开始的时间<br>            }<br>        else<br>        {<br>            if(j-&gt;arrive &gt; times)  //如果下一个进程还没到达则time设置为下一个进程到达的时间<br>                {<br>                    times = j-&gt;arrive;<br>                    j-&gt;start = j-&gt;arrive;<br>                }<br>            else //否则将time直接加上下一个进程的运行时间<br>            {<br>                j-&gt;start = times;<br>                times = times + j-&gt;process;<br>            }<br>        }<br>        flagfull = 1;<br>        overprocess(j);<br>    }<br>}</p>
<p>int main()<br>{<br>    cout&lt;&lt;”&lt;————————信息提示栏：———————————&gt;”&lt;&lt;endl;<br>    cout&lt;&lt;”                                 R代表就绪状态”&lt;&lt;endl;<br>    cout&lt;&lt;”                                 C代表运行状态”&lt;&lt;endl;<br>    cout&lt;&lt;”                                 O代表结束状态”&lt;&lt;endl;<br>    cout&lt;&lt;”&lt;———————————————————————&gt;”&lt;&lt;endl;<br>    PCBLink L;<br>    cout&lt;&lt;”&lt;————————-开始运行！———————————-&gt;”&lt;&lt;endl;<br>    for(int i=1;i&lt;=MAX;i++)<br>    {<br>        InputList(L,i);<br>        cout&lt;&lt;”第”&lt;&lt;i&lt;&lt;”个进城进入就绪队列！”&lt;&lt;endl;<br>        Sleep(1000);<br>    }<br>    cout&lt;&lt;”初始化结束！”&lt;&lt;endl;<br>    cout&lt;&lt;”&lt;————————显示当前队列信息！—————————-&gt;”&lt;&lt;endl;<br>    showState(L);<br>    cout&lt;&lt;endl;<br>    cout&lt;&lt;”&lt;————————开始进程调度！——————————–&gt;”&lt;&lt;endl;<br>    while(true)<br>    {<br>        Scheduling(L);<br>        if(num==MAX)<br>            break;<br>    }<br>    cout&lt;&lt;”&lt;————————-进程调度结束！——————————-&gt;”&lt;&lt;endl;</p>
<pre><code>return 0;</code></pre><p>}</p>
<p>截图： <img src="http://47.100.4.8/wp-content/uploads/2018/05/312312312.png" alt=""> <img src="http://47.100.4.8/wp-content/uploads/2018/05/123154324234.png" alt=""> <img src="http://47.100.4.8/wp-content/uploads/2018/05/4234324234.png" alt=""> <img src="http://47.100.4.8/wp-content/uploads/2018/05/123234234.png" alt="">   优先级调度算法： 优先级越高的进程会被优先选择，但是这里不是抢占式的调度算法。 根据每个进程块的优先级在队列中选择一个优先级最大的进程，然后将进程放到处理机中进行运行。进程每运行一次重新计算各进程的响应比。由于本实验是模拟处理器调度，所以，对被选中的进程并不实际的启动运行，而是执行：优先级减1，运行时间减1，然后再次从就绪队列中选择新的优先级进程放入到处理机中，循环执行上面的步骤，当某个进程运行结束后，将它从队列中去除直至所有的进程都从中去除，然后结束。 这里我的优先级是在我的算法中的所有进程初始化的值手动输入的。 在处理机选择进程时，总是选择队列中优先级最高的进程运行。为了采用动态优先级调度，在每次进程运行一次之后，其优先级就会减1.当进程运行结束时首先将它的状态更改为完成状态（C），并且撤出就绪队列，如果就绪队列不为空则重复执行上面的操作。 <img src="http://47.100.4.8/wp-content/uploads/2018/05/QQ%E5%9B%BE%E7%89%8720180512231124.png" alt=""> 代码：</p>
<p>#include<iostream><br>#include&lt;stdlib.h&gt;<br>#include&lt;conio.h&gt;<br>#include&lt;malloc.h&gt;<br>#include&lt;windows.h&gt;</p>
<p>using namespace std;</p>
<p>int MAX = 5;</p>
<p>typedef int ElemType;<br>typedef char State;</p>
<p>typedef struct PCB{<br>ElemType name;  //进程名<br>State current;  //进程状态<br>ElemType priority;  //进程优先级<br>ElemType runtime; //进程运行时间<br>ElemType haverun; //进程已经运行的时间<br>struct PCB <em>next; //链接指针<br>}PCB,</em>PCBList;</p>
<p>typedef struct{<br>PCBList fronts;<br>PCBList last;<br>}PCBLink;</p>
<p>int num=0;  //记录以及运行结束的进程</p>
<p>//进程创建<br>void inputPCB(PCBLink &amp;L,int i)<br>{<br>    PCB *p,*tail,*q;<br>    int run=0,super=0;<br>    cout&lt;&lt;”请输入第”&lt;&lt;i&lt;&lt;”个进程的运行时间：”;<br>    cin&gt;&gt;run;<br>    cout&lt;&lt;”请输入第”&lt;&lt;i&lt;&lt;”个进程的优先级:”;<br>    cin&gt;&gt;super;<br>    q=(PCBList)malloc(sizeof(PCB));  //创建列表头节点<br>    if(i==1)<br>    {<br>        L.fronts = L.last = q;<br>        q-&gt;name = i;<br>        q-&gt;next = NULL;  //将头指针的后面节点置为空<br>        q-&gt;runtime = run;<br>        q-&gt;priority = super;<br>        q-&gt;haverun = 0;<br>        q-&gt;current = ‘R’;  //设置初始状态  R表示就绪 C表示正在运行 O表示运行结束<br>    }<br>    else<br>    {<br>            p=(PCBList)malloc(sizeof(PCB)); //创建子节点<br>            p-&gt;name = i;<br>            p-&gt;runtime = run;<br>            p-&gt;priority = super;<br>            p-&gt;haverun = 0;<br>            p-&gt;current = ‘R’;<br>            p-&gt;next = NULL;  //将表尾指针设置为空<br>            L.last-&gt;next = p;  //将p节点插入到表尾<br>            L.last = p;<br>    }<br>}</p>
<p>//将进程放入处理机<br>void processing(PCBLink &amp;L,PCBList &amp;q)<br>{<br>    if(q-&gt;haverun == q-&gt;runtime&amp;&amp;num != MAX)<br>    {<br>        PCBList s;<br>        s=(PCBList)malloc(sizeof(PCB));<br>        s=L.fronts;<br>        if(s-&gt;name == q-&gt;name)<br>        {<br>            L.fronts=q-&gt;next;<br>            q-&gt;next=NULL;<br>        }<br>        else<br>        {<br>           while(s-&gt;next-&gt;name!=q-&gt;name)<br>           {<br>              s = s-&gt;next;<br>           }<br>           s-&gt;next = q-&gt;next;<br>        }<br>        num++;<br>        cout&lt;&lt;”进程”&lt;&lt;num&lt;&lt;”完成被移除！”&lt;&lt;endl;<br>    }<br>    else<br>    {<br>        q-&gt;haverun++;<br>        if(q-&gt;priority&gt;0)<br>            q-&gt;priority–;<br>        cout&lt;&lt;endl;<br>        cout&lt;&lt;”当前在处理中的进程是：”&lt;<q->name&lt;&lt;endl;<br>        cout&lt;&lt;”进程已经运行的时间：”&lt;<q->haverun&lt;&lt;endl;<br>        cout&lt;&lt;”进程需要运行的剩余时间：”&lt;<q->runtime-q-&gt;haverun&lt;&lt;endl;<br>        cout&lt;&lt;”就绪队列中的进程数为：”&lt;&lt;MAX-num&lt;&lt;endl;<br>        cout&lt;&lt;endl;<br>        Sleep(600);<br>    }<br>}</p>
<p>//选择优先级最高的进程放入CPU<br>void selecthigest(PCBLink &amp;L)<br>{<br>    int higest=0;  //存储最大优先级<br>    int t=0;<br>    PCBList p,q;<br>    p=(PCBList)malloc(sizeof(PCB));<br>    q=(PCBList)malloc(sizeof(PCB));<br>    q=p=L.fronts;<br>    higest = p-&gt;priority;<br>    while(p-&gt;next!=NULL)<br>    {<br>        t = p-&gt;next-&gt;priority;<br>        if(t &gt; higest)<br>        {<br>            higest = t;<br>            q=p-&gt;next;<br>        }<br>        p=p-&gt;next;<br>    }<br>    processing(L,q);<br>}</p>
<p>//显示当前就绪队列中的进程的状态<br>void showState(PCBLink &amp;L)<br>{<br>    cout&lt;&lt;endl;<br>    cout&lt;&lt;endl;<br>    PCBList p;<br>    p=(PCBList)malloc(sizeof(PCB));<br>    p=L.fronts;<br>    for(int i=1;i&lt;=MAX;i++)<br>    {<br>       cout&lt;&lt;”进程”&lt;&lt;i&lt;&lt;endl;<br>       cout&lt;&lt;”&lt;—————-创建进程的信息：———————-&gt;”&lt;&lt;endl;<br>       cout&lt;&lt;”进程标识：”&lt;<p->name&lt;&lt;endl;<br>       cout&lt;&lt;”进程执行时间：”&lt;<p->runtime&lt;&lt;endl;<br>       cout&lt;&lt;”进程当前状态：”&lt;<p->current&lt;&lt;endl;<br>       cout&lt;&lt;”进程的优先级：”&lt;<p->priority&lt;&lt;endl;<br>       cout&lt;&lt;”&lt;——————-信息结束：———————-&gt;”&lt;&lt;endl;<br>       p=p-&gt;next;<br>       Sleep(500);<br>    }<br>    cout&lt;&lt;endl;<br>    cout&lt;&lt;endl;<br>}</p>
<p>int main()<br>{<br>    PCBLink L;<br>    for(int i=1;i&lt;=MAX;i++)<br>    {<br>        inputPCB(L,i);<br>        cout&lt;&lt;”第”&lt;&lt;i&lt;&lt;”个进城进入就绪队列！”&lt;&lt;endl;<br>        cout&lt;&lt;endl;<br>        Sleep(1000);<br>    }<br>    showState(L);<br>    cout&lt;&lt;”&lt;——————–开始处理进程—————————&gt;”&lt;&lt;endl;<br>    while(num !=MAX)<br>    {<br>        selecthigest(L);<br>    }<br>    if(num == MAX)<br>        cout&lt;&lt;”&lt;———————所有进程处理完毕！———————&gt;”&lt;&lt;endl;<br>    return 0;<br>}</p>
<p>  实现： <img src="http://47.100.4.8/wp-content/uploads/2018/05/1-5.png" alt=""> <img src="http://47.100.4.8/wp-content/uploads/2018/05/2-5.png" alt=""> <img src="http://47.100.4.8/wp-content/uploads/2018/05/3-4.png" alt=""> <img src="http://47.100.4.8/wp-content/uploads/2018/05/4-4.png" alt=""> <img src="http://47.100.4.8/wp-content/uploads/2018/05/5-2.png" alt=""> <img src="http://47.100.4.8/wp-content/uploads/2018/05/6-1.png" alt=""> <img src="http://47.100.4.8/wp-content/uploads/2018/05/7-1.png" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zs670980918.github.io/blogs/blogs/2018/05/11/stl-zhi-queue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="StriveZs">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blogs/images/avatar.JPG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="StriveZs的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blogs/2018/05/11/stl-zhi-queue/" itemprop="url">STL之queue</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-11T23:22:58+08:00">
                2018-05-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/C-amp-C/" itemprop="url" rel="index">
                    <span itemprop="name">C&amp;C++</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/C-amp-C/C-%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index">
                    <span itemprop="name">C++学习</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/C-amp-C/C-%E5%AD%A6%E4%B9%A0/%E6%96%87%E7%AB%A0%E9%A1%B5/" itemprop="url" rel="index">
                    <span itemprop="name">文章页</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>queue单向队列使用 queue单向队列与<a href="http://blog.csdn.net/morewindows/article/details/6950881" target="_blank" rel="noopener">栈</a>有点类似，一个是在同一端存取数据，另一个是在一端存入数据，另一端取出数据。单向队列中的数据是先进先出（First In First Out,FIFO）。在STL中，单向队列也是以别的容器作为底部结构，再将接口改变，使之符合单向队列的特性就可以了。因此实现也是非常方便的。下面就给出单向队列的函数列表和VS2008中单向队列的源代码。单向队列一共6个常用函数（front()、back()、push()、pop()、empty()、size()），与<a href="http://blog.csdn.net/morewindows/article/details/6950881" target="_blank" rel="noopener">栈</a>的常用函数较为相似。 <img src="http://47.100.4.8/wp-content/uploads/2018/05/512357486.png" alt=""> 由于仅需取队首和队尾元素的操作，因此<strong>queue**</strong>队列容器并不提供任何类型的迭代器对队列中其他位置处的元素进行访问操作。** <strong>函数</strong> <strong>构造函数：</strong> queue&lt;类型&gt;c   创建一个空间queue queue&lt;类型&gt;c1(c2)  用c2初始化c1   数据访问与增减 c.front（）  返回队列头部数据 c.back（）  返回队列尾部数据 c.push（elem）  在队列尾部增加elem数据 c.pop（）   队列头部数据出队   其他操作 c.empty（）  判断队列是否为空 c.size（）  返回队列中数据的个数 代码：</p>
<p>#include<iostream><br>#include<queue></p>
<p>using namespace std;<br>int main()<br>{<br>    //创建队列1<br>    queue<int>test1;<br>    cout&lt;&lt;”判断队列test1是否为空：”&lt;&lt;test1.empty()&lt;&lt;endl;<br>    cout&lt;&lt;”得到队列test1元素个数:”&lt;&lt;test1.size()&lt;&lt;endl;<br>    test1.push(1);<br>    test1.push(2);<br>    queue<int>test2(test1);<br>    //打印队列元素<br>    int t=test1.size();<br>    for(int i=0;i&lt;t;i++)<br>    {<br>        cout&lt;&lt;test1.front()&lt;&lt;” “;<br>        test1.pop();<br>    }<br>    cout&lt;&lt;endl;<br>    cout&lt;&lt;test2.back()&lt;&lt;” “&lt;&lt;test2.front()&lt;&lt;endl;<br>    return 0;<br>}</p>
<p>结果： <img src="http://47.100.4.8/wp-content/uploads/2018/05/14741.png" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zs670980918.github.io/blogs/blogs/2018/05/10/c-zhi-ji-cheng-pai-sheng/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="StriveZs">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blogs/images/avatar.JPG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="StriveZs的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blogs/2018/05/10/c-zhi-ji-cheng-pai-sheng/" itemprop="url">C++之继承派生</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-10T22:01:27+08:00">
                2018-05-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/C-amp-C/" itemprop="url" rel="index">
                    <span itemprop="name">C&amp;C++</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/C-amp-C/C-%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index">
                    <span itemprop="name">C++学习</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/C-amp-C/C-%E5%AD%A6%E4%B9%A0/%E6%96%87%E7%AB%A0%E9%A1%B5/" itemprop="url" rel="index">
                    <span itemprop="name">文章页</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://47.100.4.8/wp-content/uploads/2018/05/510baad315cd40fc90c092cba2d63480.jpg" alt=""> 类的继承，是新的类从已有的类那里得到已有的特性。从另一个角度上看，从已有的类中产生新类的过程就是类的派生。 原有的类称为基类或父类，产生的新类称为派生类或子类。派生类也可以作为基类派生新的类，这样就形成了类的层次结构。   派生类的定义： class 派生类名称：继承方式 基类名1，继承方式 基类名2，继承方式 基类名3 { 派生类成员声明； } 代码：</p>
<p>#include<iostream></p>
<p>using namespace std;</p>
<p>class Animal{<br>public:<br>    Animal(){};<br>    ~Animal(){};<br>    int age;<br>};</p>
<p>class Dog:public Animal<br>{<br>public:<br>    Dog(){};<br>    ~Dog(){};<br>    int SetAge(int n);<br>};</p>
<p>int Dog::SetAge(int n)<br>{<br>    age=n;<br>    cout&lt;&lt;”age=”&lt;&lt;age&lt;&lt;endl;<br>}<br>int main()<br>{<br>    Dog dog;<br>    int n=10;<br>    dog.SetAge(n);<br>    return 0;<br>}</p>
<p>截图： <img src="http://47.100.4.8/wp-content/uploads/2018/05/1-4.png" alt=""> 一个派生类，可以同时有多个基类，这种情况称为多继承，这时的派生类同时得到多个已有类的特征。 一个派生类只有一个直接基类的情况称为单继承。 <img src="http://47.100.4.8/wp-content/uploads/2018/05/2-4.png" alt=""> 继承方式关键字：public，protected，private分别表示公有继承，保护继承，私有继承。 1.公有继承，使得基类public（公有）和protected（保护）成员的访问属性在派生类中不变，而基类private（私有）成员不可访问 2.私有继承，使用基类public（公有）和protected（保护）成员都以private（私有）成员身份出现在派生类中，而基类private（私有）成员不可访问。 3.保护继承中，基类public（公有）和protected（保护）成员都已protected（保护）成员身份出现在派生类中，而基类private（私有）成员不可访问。   上面的代码就是使用public公有继承。   构造函数： 构造派生类的对象时，就要对基类的成员对象和新增成员对象进行初始化。 派生类构造函数的一般语法形式： 派生类名：：派生类名（参数表）：基类名1 （），基类名2（）…… { 派生类构造函数的其他初始化操作； }   如果对基类初始化时，需要调用基类带有形参的构造函数，派生类就必须声明构造函数。   析构函数： 同样也要调用基类的成员析构函数和该类的析构函数。   代码：</p>
<p>#include<iostream></p>
<p>using namespace std;</p>
<p>class BaseClass<br>{<br>public:<br>    BaseClass()<br>    {<br>        cout&lt;&lt;”     BaseClass’s message:Create”&lt;&lt;endl;<br>    }<br>    ~BaseClass()<br>    {<br>        cout&lt;&lt;”     BaseClass’s message:Destroy”&lt;&lt;endl;<br>    }<br>};</p>
<p>class DerivedClass:public BaseClass<br>{<br>public:<br>    DerivedClass()<br>    {<br>        cout&lt;&lt;”     DerivedClass’s message:Create”&lt;&lt;endl;<br>    }<br>    ~DerivedClass()<br>    {<br>        cout&lt;&lt;”     DerivedClass’s message:Destroy”&lt;&lt;endl;<br>    }</p>
<p>};<br>int main()<br>{<br>    cout&lt;&lt;”MessageBox:”&lt;&lt;endl;<br>    DerivedClass derivedclass;<br>    return 0;<br>}</p>
<p>  截图： <img src="http://47.100.4.8/wp-content/uploads/2018/05/3-3.png" alt=""> 由截图可以看出继承构造和析构函数的使用：如果DerivedClass继承于基类BaseClass，则在使用DerivedClass类去声明一个对象时，会先创建一个BaseClass类的对象，然后在创建DerivedClass类的对象，上面是构造函数的调用情况，然后是析构函数的调用情况，是先调用DerivedClass的析构函数，然后再调用BaseClass的析构函数。   <strong>在派生类中可以使用基类名：：基类成员来访问基类中的成员。</strong> 访问方式也会在下面使用到   先介绍一下虚基类： 当某类的部分或全部直接基类是从另一个基类派生而来的，这些直接基类中，从上一级基类继承来的成员就拥有相同的名称，派生类的对象的这些同名成员在内存中同时拥有多个拷贝，我们可以使用作用于分辨符来唯一标识并分别访问他们，我们也可以<strong>将直接基类的共同基类设置为虚基类，这时从不同的路径继承过来的该类成员在内存中只拥有一个拷贝</strong>，这样就解决了同名成员的唯一标识问题。   虚基类的声明是在派生类的声明过程中，其语法格式为： class 派生类名：virtual 继承方式 基类名 在多继承情况下，虚基类关键字的作用范围和继承方式关键字相同，只对紧跟其后的基类起作用，声明了虚基类之后，虚基类的成员在进一步的派生中，和派生类一起维护一个内存数据拷贝。   图示： <img src="http://47.100.4.8/wp-content/uploads/2018/05/4-3.png" alt=""> 使用 代码：</p>
<p>#include<iostream><br>#include&lt;string.h&gt;</p>
<p>using namespace std;</p>
<p>class vehicle{<br>public:<br>    vehicle()<br>    {<br>        cout&lt;&lt;”     Vehicle’s message:Create”&lt;&lt;endl;<br>    }<br>    ~vehicle()<br>    {<br>        cout&lt;&lt;”     Vehicle’s message:Destroy”&lt;&lt;endl;<br>    }<br>    int Lunzi;  //轮子数目<br>    int Price;  //价格</p>
<pre><code>void SetLunZi(int n)
{
    Lunzi=n;
}

void SetPrice(int n)
{
    Price = n;
}</code></pre><p>};</p>
<p>class bicycle:virtual public vehicle<br>{<br>public:<br>    bicycle()<br>    {<br>        cout&lt;&lt;”     bicycle’s message:Create”&lt;&lt;endl;<br>    }<br>    ~bicycle()<br>    {<br>        cout&lt;&lt;”     bicycle’s message:Destroy”&lt;&lt;endl;<br>    }<br>    string PinPai;  //品牌<br>    void SetPinPai(string a)<br>    {<br>        PinPai = a;<br>    }<br>};</p>
<p>class motorcar:virtual public vehicle<br>{<br>public:<br>    motorcar()<br>    {<br>        cout&lt;&lt;”     motorcar’s message:Create”&lt;&lt;endl;<br>    }<br>    ~motorcar()<br>    {<br>        cout&lt;&lt;”     motorcar’s message:Destroy”&lt;&lt;endl;<br>    }<br>    string PinPai;  //品牌<br>    void SetPinPai(string a)<br>    {<br>        PinPai = a;<br>    }<br>};</p>
<p>class motorcycle:public bicycle,public motorcar<br>{<br>public:<br>    motorcycle()<br>    {<br>        cout&lt;&lt;”     motorcycle’s message:Create”&lt;&lt;endl;<br>    }<br>    ~motorcycle()<br>    {<br>        cout&lt;&lt;”     motorcycle’s message:Destroy”&lt;&lt;endl;<br>    }<br>    void SetMessage(string a,int b,int c,int d)<br>    {<br>        bicycle::SetPinPai(a);<br>        vehicle::SetPrice(b);<br>        vehicle::SetLunZi(c);<br>        v=d;<br>    }<br>    void OutMessage()<br>    {<br>        cout&lt;&lt;”     摩托车品牌名称：”&lt;&lt;bicycle::PinPai&lt;&lt;endl;<br>        cout&lt;&lt;”     摩托车价格：”&lt;&lt;vehicle::Price&lt;&lt;”元”&lt;&lt;endl;<br>        cout&lt;&lt;”     摩托车轮子数；”&lt;&lt;vehicle::Lunzi&lt;&lt;”个”&lt;&lt;endl;<br>        cout&lt;&lt;”     摩托车速度：”&lt;&lt;v&lt;&lt;”km/h”&lt;&lt;endl;<br>    }<br>private:<br>    int v;  //速度<br>};</p>
<p>int main()<br>{<br>    cout&lt;&lt;”MessageBox:”&lt;&lt;endl;<br>    motorcycle mb;<br>    cout&lt;&lt;”输入摩托车品牌名称：”;<br>    string s1;<br>    cin&gt;&gt;s1;<br>    cout&lt;&lt;”输入摩托车价格：”;<br>    int a;<br>    cin&gt;&gt;a;<br>    cout&lt;&lt;”输入摩托车轮子数；”;<br>    int b;<br>    cin&gt;&gt;b;<br>    cout&lt;&lt;”输入摩托车速度：”;<br>    int c;<br>    cin&gt;&gt;c;<br>    mb.SetMessage(s1,a,b,c);<br>    cout&lt;&lt;”摩托车信息显示：”&lt;&lt;endl;<br>    mb.OutMessage();<br>    return 0;<br>}</p>
<p>截图： <img src="http://47.100.4.8/wp-content/uploads/2018/05/5-1.png" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zs670980918.github.io/blogs/blogs/2018/05/09/stl-zhi-stack-xue-xi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="StriveZs">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blogs/images/avatar.JPG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="StriveZs的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blogs/2018/05/09/stl-zhi-stack-xue-xi/" itemprop="url">STL之Stack学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-09T22:41:26+08:00">
                2018-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/C-amp-C/" itemprop="url" rel="index">
                    <span itemprop="name">C&amp;C++</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/C-amp-C/C-%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index">
                    <span itemprop="name">C++学习</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/C-amp-C/C-%E5%AD%A6%E4%B9%A0/%E6%96%87%E7%AB%A0%E9%A1%B5/" itemprop="url" rel="index">
                    <span itemprop="name">文章页</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://47.100.4.8/wp-content/uploads/2018/05/QQ%E5%9B%BE%E7%89%8720180507183124.png" alt=""> 栈是一种容器适配器，特别为后入先出而设计的一种（LIFO ），那种数据被插入，然后再容器末端取出 栈实现了容器适配器，这是用了一个封装了的类作为他的特定容器，提供了一组成员函数去访问他的元素，元素从特定的容器，也就是堆栈的头取出。 遵循先进先出的原则。栈口只有一个，允许新增元素（只能在栈顶上增加）、移除元素（只能一处栈顶元素）、取得栈顶元素等操作。在STL，栈是以别的容器作为底部结构，再将接口改变，使之符合栈的特性就可以了。   栈的相关函数 构造函数： stack<Elem>c  创建一个空的stack stack<Elem>c1(c2)  用c2初始化c1   数据增减： c.top（）  返回栈顶元素 c.push（elem） 在栈顶增加elem数据 c.pop（）  弹出栈顶元素   其他操作： c.empty（）   判断栈是否为空 c.size（）  返回栈中数据的个数 代码：</p>
<p>#include<iostream><br>#include<stack></p>
<p>using namespace std;</p>
<p>int main()<br>{<br>    stack<int>s;  //创建一个栈<br>    cout&lt;&lt;”创建栈成功！”&lt;&lt;endl;<br>    cout&lt;&lt;”当前栈的数据个数：”&lt;&lt;s.size()&lt;&lt;endl;<br>    cout&lt;&lt;”添加三个元素在之后：”&lt;&lt;endl;<br>    s.push(1);  //向栈中添加元素<br>    s.push(2);<br>    s.push(3);<br>    cout&lt;&lt;”当前栈的数据个数：”&lt;&lt;s.size()&lt;&lt;endl;<br>    cout&lt;&lt;”返回栈顶元素：”&lt;&lt;s.top()&lt;&lt;endl;<br>    cout&lt;&lt;”弹出栈顶元素之前的数据个数：”&lt;&lt;s.size()&lt;&lt;endl;<br>    s.pop();<br>    cout&lt;&lt;”弹出栈顶元素之后的数据个数：”&lt;&lt;s.size()&lt;&lt;endl;<br>    cout&lt;&lt;”判断栈是否为空:”&lt;&lt;s.empty()&lt;&lt;endl;<br>    return 0;<br>}</p>
<p>  结果： <img src="http://47.100.4.8/wp-content/uploads/2018/05/12335424.png" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zs670980918.github.io/blogs/blogs/2018/05/08/stl-zhi-deque-xue-xi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="StriveZs">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blogs/images/avatar.JPG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="StriveZs的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blogs/2018/05/08/stl-zhi-deque-xue-xi/" itemprop="url">STL之deque学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-08T23:14:08+08:00">
                2018-05-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/C-amp-C/" itemprop="url" rel="index">
                    <span itemprop="name">C&amp;C++</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/C-amp-C/C-%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index">
                    <span itemprop="name">C++学习</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/C-amp-C/C-%E5%AD%A6%E4%B9%A0/%E6%96%87%E7%AB%A0%E9%A1%B5/" itemprop="url" rel="index">
                    <span itemprop="name">文章页</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://47.100.4.8/wp-content/uploads/2018/05/QQ%E5%9B%BE%E7%89%8720180507183124.png" alt=""></p>
<ul>
<li>deque双向队列：</li>
</ul>
<p>deque双向队列是一种双向开口的连续线性空间，可以高效的在头尾两端插入和删除元素，deque在接口上和vector非常相似，下面列出deque的常用成员函数：   构造析构函数： deque&lt;类型&gt;c  创建一个名称为c的空元素类型的deque deque&lt;类型&gt;c(a2)  用c2来初始化c1 deque&lt;类型&gt;c（n）  创建deque，含有n个数据，数据均有基础构造函数初始化 deque&lt;类型&gt;c（n，t）  创建一个含有n个t构成的deque deque&lt;类型&gt;c（start,end）创建一个以（start，end）区间的deque c ~deque&lt;类型&gt;（）   析构函数   赋值函数： 可以直接使用c[i]=x 直接进行赋值 c.assign（n，elem）  将n个elem赋值给c   数据访问： c.at（index）   返回索引index所指的数据  如果index大于最大边界 则抛出一个异常 c.front（）  返回deque第一个数据 c.back（）  返回最后一个数据 c.begin（）   返回指向第一个数据的迭代器 注意： deque<int>::iterator pos;  声明一个迭代器变量 使用pos=c.begin（）  来接收返回值不能使用int定义的变量接收否则会报错！ c.end（）同理。 c.end（）   返回指向最后一个数据的下一个位置的迭代器 c.rbegin（）  返回逆向队列的第一个数据 c.rend（）  返回逆向队列指向最后一个数据的下一个位置的迭代器   加入数据： c.push_back（elem）  在尾部加入一个数据 c.push_from（elem）  在头部插入一个数据 c.insert（pos，elem）  在pos位置后面插入一个elem  返回新的数据位置 c.insert（pos，n，elem）  在pos位置后面插入n个elem，无返回值   删除数据： c.pop_back（）  删除最后一个数据 c.pop_from（）  删除头部数据 c.erase（pos）  删除pos位置的数据，返回下一个数据的位置   其他操作： c.empty（）  判断容器是否为空 c.max_size（）  返回容器中最大数据的数量 c.resize（num）  重新指定队列长度 c.size（）  返回容器实际数据值 c.swap（s）  将c和s的元素互换 swap（c，s）   deque从逻辑上看是连续的内存，本质是由一段段固定大小的连续的空间组成。 <img src="http://47.100.4.8/wp-content/uploads/2018/05/1232154.png" alt=""> 采用一小块连续的内存索引缓存结点，每个缓存结点也是一段连续的空间，可以存储多个数据，当索引内存空间满载时，需要申请一块更大的内存做索引。   使用：</p>
<p>#include<iostream><br>#include<deque><br>#include <cstdio></p>
<p>using namespace std;</p>
<p>int main()<br>{<br>    deque<int> test1(20);  //创建一个数据大小为20的deque<br>    deque<int>::iterator pos1;  //声明deque test1的迭代器变量为pos</p>
<pre><code>//初始化
for(int i=0;i&lt;20;i++)
    test1\[i\]=i;
cout&lt;&lt;&quot;输出test1初始化数据：&quot;&lt;&lt;endl;
for(int i=0;i&lt;20;i++)
    cout&lt;&lt;test1\[i\]&lt;&lt;&quot; &quot;;
cout&lt;&lt;endl;

cout&lt;&lt;&quot;用test1初始化test2的数据：&quot;&lt;&lt;endl;
deque&lt;int&gt; test2(test1);  //用test1初始化test2
for(int i=0;i&lt;20;i++)
    cout&lt;&lt;test2\[i\]&lt;&lt;&quot; &quot;;
cout&lt;&lt;endl;

deque&lt;int&gt; test3(4);
test3.assign(5,5);
for(int i=0;i&lt;5;i++)
    cout&lt;&lt;test3\[i\]&lt;&lt;&quot; &quot;;
cout&lt;&lt;endl;

cout&lt;&lt;&quot;对test1进行相关操作：&quot;&lt;&lt;endl;
cout&lt;&lt;&quot;test1.front():&quot;&lt;&lt;test1.front()&lt;&lt;endl;
cout&lt;&lt;&quot;test1.back():&quot;&lt;&lt;test1.back()&lt;&lt;endl;
//这里要注意的test1.begin（） 需要使用声明迭代器的变量来接收  输出时使用*pos1来输出  pos1为地址
cout&lt;&lt;&quot;通过使用迭代器进行test1的数据输出：&quot;&lt;&lt;endl;
for(pos1=test1.begin();pos1!=test1.end();pos1++)
    cout&lt;&lt;*pos1&lt;&lt;&quot; &quot;;
cout&lt;&lt;endl;
int s=1;
deque&lt;int&gt;test4;
cout&lt;&lt;&quot;使用push\_back和push\_front使用：&quot;&lt;&lt;endl;
test4.push_front(1);
test4.push_back(0);
cout&lt;&lt;&quot;size（）使用：&quot;&lt;&lt;test4.size()&lt;&lt;endl;
cout&lt;&lt;&quot;pop\_back和pop\_from的使用：&quot;&lt;&lt;endl;
test4.pop_back();
//test4.pop_front();
cout&lt;&lt;&quot;当前的大小:&quot;&lt;&lt;test4.size()&lt;&lt;endl;
cout&lt;&lt;&quot;对test3进行插入操作：&quot;;
test3.insert(test3.begin()+1,3);  //要注意插入操作 插入下标位置使用的是test.begin()+i
for(pos1=test3.begin();pos1!=test3.end();pos1++)
    cout&lt;&lt;*pos1&lt;&lt;&quot; &quot;;
cout&lt;&lt;endl;
cout&lt;&lt;&quot;判断容器test3是否为空：&quot;&lt;&lt;test3.empty()&lt;&lt;endl;
deque&lt;int&gt;test5(10);
cout&lt;&lt;&quot;输入test5当前的大小:&quot;&lt;&lt;test5.size()&lt;&lt;&quot;  \\n输出最大数据的数量：&quot;&lt;&lt;test5.max_size()&lt;&lt;endl;
return 0;</code></pre><p>}</p>
<p>结果： <img src="http://47.100.4.8/wp-content/uploads/2018/05/4324235.png" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zs670980918.github.io/blogs/blogs/2018/05/07/c-zhi-stl-jie-shao/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="StriveZs">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blogs/images/avatar.JPG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="StriveZs的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blogs/2018/05/07/c-zhi-stl-jie-shao/" itemprop="url">C++之STL介绍</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-07T18:33:45+08:00">
                2018-05-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/C-amp-C/" itemprop="url" rel="index">
                    <span itemprop="name">C&amp;C++</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/C-amp-C/C-%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index">
                    <span itemprop="name">C++学习</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/C-amp-C/C-%E5%AD%A6%E4%B9%A0/%E6%96%87%E7%AB%A0%E9%A1%B5/" itemprop="url" rel="index">
                    <span itemprop="name">文章页</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://47.100.4.8/wp-content/uploads/2018/05/QQ%E5%9B%BE%E7%89%8720180507183124.png" alt=""> C++STL（标准模板库）是一套功能强大的C++模板类，提供了通用的模板类和函数，这些模板类和函数可以实现多种流行和常用的算法和数据结构，如向量、链表、队列、栈。 C++标准模板库三个核心组件：</p>
<p>算法（Algorithm）</p>
<p>算法作用于容器。它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。</p>
<p>容器（Containers）</p>
<p>容器是用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，比如 deque、list、vector、map 、set等。</p>
<p>迭代器（iterators）</p>
<p>迭代器用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集。</p>
<p>  在C++标准库中，STL被组织在13个头文件中：<strong><algorithm>**</strong>、<deque>、<functional>、<iterator>、<vector>、<list>、<map>、<memory>、<numeric>、<queue>、<set>、<stack>和<utility>。** <strong>STL**</strong>提供了大约100多个实现算法的模板函数。** </p>
<ol>
<li>算法部分的主要头文件为：<strong><algorithm>**</strong>、<numeric>、<functional>**</li>
</ol>
<p><strong><algorithm>**</strong>是所有STL头文件中最大的一个（尽管它很好理解），它是由一大堆模版函数组成的，可以认为每个函数在很大程度上都是独立的，其中常用到的功能范围涉及到比较、交换、查找、遍历操作、复制、修改、移除、反转、排序、合并等等。** <strong><numeric>**</strong>体积很小，只包括几个在序列上面进行简单数学运算的模板函数，包括加法和乘法在序列上的一些操作。** <strong><functional>**</strong>中则定义了一些模板类，用以声明函数对象。** </p>
<ol start="2">
<li>容器部分的头文件：<strong><vector>,<list>,<deque>,<set>,<map>,<stack>和<queue></strong></li>
</ol>
<p><strong>向量(vector) 连续存储的元素<vector></strong> <strong>列表(list)       由节点组成的双向链表，每个结点包含着一个元素<list></strong> <strong>双队列(deque) 连续存储的指向不同元素的指针所组成的数组<deque></strong> <strong>集合(set) 由节点组成的红黑树，每个节点都包含着一个元素，节点之间以某种作用于元素对的谓词排列，没有两个不同的元素能够拥有相同的次序 <set></strong> <strong>多重集合(multiset) 允许存在两个次序相等的元素的集合 <set></strong> <strong>栈(stack) 后进先出的值的排列 <stack></strong> <strong>队列(queue) 先进先出的执的排列 <queue></strong> <strong>优先队列(priority_queue) 元素的次序是由作用于所存储的值对上的某种谓词决定的的一种队列 <queue></strong> <strong>映射(map) 由{键，值}对组成的集合，以某种作用于键对上的谓词排列 <map></strong> <strong>多重映射(multimap) 允许键对有相等的次序的映射 <map></strong>   3.迭代器 包含迭代器的头文件<utility>,<iterator>和<memory>。 <strong><utility></strong>是一个很小的头文件，它包括了贯穿使用在STL中的几个模板的声明， <strong><iterator></strong>中提供了迭代器使用的许多方法，而对于<strong><memory></strong>的描述则十分的困难，它以不同寻常的方式为容器中的元素分配存储空间，同时也为某些算法执行期间产生的临时对象提供机制,<strong><memory></strong>中的主要部分是模板类allocator，它负责产生所有容器中的默认分配器。   后面会慢慢给出给出各个容器的使用。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zs670980918.github.io/blogs/blogs/2018/05/06/c-zhi-vector-shi-yong/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="StriveZs">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blogs/images/avatar.JPG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="StriveZs的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blogs/2018/05/06/c-zhi-vector-shi-yong/" itemprop="url">C++之vector使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-06T22:41:21+08:00">
                2018-05-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/C-amp-C/" itemprop="url" rel="index">
                    <span itemprop="name">C&amp;C++</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/C-amp-C/C-%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index">
                    <span itemprop="name">C++学习</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/C-amp-C/C-%E5%AD%A6%E4%B9%A0/%E6%96%87%E7%AB%A0%E9%A1%B5/" itemprop="url" rel="index">
                    <span itemprop="name">文章页</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://47.100.4.8/wp-content/uploads/2018/05/%E5%9B%BE%E7%89%87150.png" alt=""> 使用vector创建数组对象   C++标准库提供了被封装的动态数组—vector，而且这种封装的数组可以具有各种类型。 vector它不是类，它是类的一个模板。 使用vector动态定义数组的形式为： vector&lt;元素类型&gt;数组对象名（数组长度）;   例如： vector<int>array(5);  //创建一个长度为5的动态整形数组对象   与普通数组不同的是，用vector定义的数组对象所有的元素都会被初始化。如果数组的元素类型为基本数据类型，则所有元素都会被以0初始化。如果数组元素为类类型，则会调用类的默认构造函数初始化。   创建数组的元素初值也可以自己选择： 但是只能为相同的初值 vector&lt;元素类型&gt;数组对象名（数组长度,元素初值）; 对vector数组对象元素的访问方式为：数组对象名[下标表达式]; 可以使用它的成员函数size（）来得到数组的大小。   计算数组平均值：使用到了size（） 代码：</p>
<p>#include<iostream></p>
<p>#include<vector></p>
<p>using namespace std;</p>
<p>double average(const vector<double>&amp;arr)</p>
<p>{</p>
<pre><code>double sum=0;

for(int i=0;i&lt;arr.size();i++)

    sum += arr\[i\];

return sum/arr.size();</code></pre><p>}</p>
<p>int main()</p>
<p>{</p>
<pre><code>int n;

cout&lt;&lt;&quot;请输入n的值：&quot;;

cin&gt;&gt;n;



vector&lt;double&gt;arr(n,0);

cout&lt;&lt;&quot;输入n个数组元素:&quot;&lt;&lt;endl;

for(int i=0;i&lt;n;i++)

    cin&gt;&gt;arr\[i\];



cout&lt;&lt;&quot;平均值为：&quot;&lt;&lt;average(arr)&lt;&lt;endl;

return 0;</code></pre><p>}</p>
<p>  结果： <img src="http://47.100.4.8/wp-content/uploads/2018/05/123123.png" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blogs/page/17/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/blogs/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blogs/page/17/">17</a><span class="page-number current">18</span><a class="page-number" href="/blogs/page/19/">19</a><span class="space">&hellip;</span><a class="page-number" href="/blogs/page/26/">26</a><a class="extend next" rel="next" href="/blogs/page/19/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/blogs/images/avatar.JPG"
                alt="StriveZs" />
            
              <p class="site-author-name" itemprop="name">StriveZs</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/blogs/archives/%20%7C%7C%20archive">
              
                  <span class="site-state-item-count">252</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">162</span>
                  <span class="site-state-item-name">categories</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/blogs/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">StriveZs</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/blogs/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/blogs/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/blogs/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/blogs/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blogs/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blogs/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/blogs/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/blogs/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/blogs/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/blogs/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/blogs/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
