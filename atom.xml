<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>StriveZs的博客</title>
  
  <subtitle>Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="www.strivezs.com/"/>
  <updated>2021-07-06T12:06:01.868Z</updated>
  <id>www.strivezs.com/</id>
  
  <author>
    <name>StriveZs</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode No.139</title>
    <link href="www.strivezs.com/2021/07/06/LeetCode%E7%AC%AC139%E9%A2%98/"/>
    <id>www.strivezs.com/2021/07/06/LeetCode%E7%AC%AC139%E9%A2%98/</id>
    <published>2021-07-06T12:06:01.868Z</published>
    <updated>2021-07-06T12:06:01.868Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第139题—单词拆分</h1><p>这几天课比较多，有点忙，可能来不及更新喔</p><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p><p>说明：</p><p>拆分时可以重复使用字典中的单词。<br>你可以假设字典中没有重复的单词。</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入: <span class="attr">s</span> = <span class="string">"leetcode"</span>, <span class="attr">wordDict</span> = [<span class="string">"leet"</span>, <span class="string">"code"</span>]</span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">解释: 返回 <span class="literal">true</span> 因为 <span class="string">"leetcode"</span> 可以被拆分成 <span class="string">"leet code"</span>。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入: <span class="attr">s</span> = <span class="string">"applepenapple"</span>, <span class="attr">wordDict</span> = [<span class="string">"apple"</span>, <span class="string">"pen"</span>]</span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">解释: 返回 <span class="literal">true</span> 因为 <span class="string">"applepenapple"</span> 可以被拆分成 <span class="string">"apple pen apple"</span>。</span><br><span class="line">     注意你可以重复使用字典中的单词。</span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入: <span class="attr">s</span> = <span class="string">"catsandog"</span>, <span class="attr">wordDict</span> = [<span class="string">"cats"</span>, <span class="string">"dog"</span>, <span class="string">"sand"</span>, <span class="string">"and"</span>, <span class="string">"cat"</span>]</span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><h3 id="最初版本"><a class="header-anchor" href="#最初版本">¶</a>最初版本</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def wordBreak(self, s, wordDict):</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        拆分时可以重复使用字典中的单词。</span><br><span class="line">        你可以假设字典中没有重复的单词</span><br><span class="line">        题目分析:</span><br><span class="line">            从头到尾开始移动<span class="built_in">index</span>，进行单词切片，如果单词在字典里就，从新的<span class="built_in">index</span>开始</span><br><span class="line">            这种做法无法解决: <span class="string">"goalspecial"</span>  [<span class="string">"go"</span>,<span class="string">"goal"</span>,<span class="string">"goals"</span>,<span class="string">"special"</span>] 这种情况</span><br><span class="line">        因此需要考虑动态规划的做法：</span><br><span class="line">            <span class="keyword">dp</span>[i] 表示前i个字符是否能够拆分成wordDict</span><br><span class="line">            状态转移公式:</span><br><span class="line">                <span class="keyword">dp</span>[i]=true的话，则只需要判断i+<span class="number">1</span>到<span class="keyword">j</span>个字符是否属于WordDict就可以了</span><br><span class="line">            最后返回<span class="keyword">dp</span>[-<span class="number">1</span>]就好了</span><br><span class="line">        :<span class="built_in">type</span> <span class="variable">s:</span> str</span><br><span class="line">        :<span class="built_in">type</span> wordDic<span class="variable">t:</span> List[str]</span><br><span class="line">        :rtype: bool</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        <span class="keyword">dp</span> = [False] * (<span class="built_in">len</span>(s)+<span class="number">1</span>) # <span class="keyword">dp</span>[]长度为<span class="built_in">len</span>(s)+<span class="number">1</span></span><br><span class="line">        <span class="keyword">dp</span>[<span class="number">0</span>] = True # 设置初始</span><br><span class="line">        <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">for</span> <span class="keyword">j</span> in <span class="built_in">range</span>(i+<span class="number">1</span>, <span class="built_in">len</span>(s)+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">dp</span>[i]:</span><br><span class="line">                    <span class="keyword">if</span> s[i:<span class="keyword">j</span>] in wordDic<span class="variable">t:</span></span><br><span class="line">                        <span class="keyword">dp</span>[<span class="keyword">j</span>] = True</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">dp</span>[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="加速和节省之后的版本"><a class="header-anchor" href="#加速和节省之后的版本">¶</a>加速和节省之后的版本</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def wordBreak(self, s, wordDict):</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        拆分时可以重复使用字典中的单词。</span><br><span class="line">        你可以假设字典中没有重复的单词</span><br><span class="line">        题目分析:</span><br><span class="line">            从头到尾开始移动<span class="built_in">index</span>，进行单词切片，如果单词在字典里就，从新的<span class="built_in">index</span>开始</span><br><span class="line">            这种做法无法解决: <span class="string">"goalspecial"</span>  [<span class="string">"go"</span>,<span class="string">"goal"</span>,<span class="string">"goals"</span>,<span class="string">"special"</span>] 这种情况</span><br><span class="line">        因此需要考虑动态规划的做法：</span><br><span class="line">            <span class="keyword">dp</span>[i] 表示前i个字符是否能够拆分成wordDict</span><br><span class="line">            状态转移公式:</span><br><span class="line">                <span class="keyword">dp</span>[i]=true的话，则只需要判断i+<span class="number">1</span>到<span class="keyword">j</span>个字符是否属于WordDict就可以了</span><br><span class="line">            最后返回<span class="keyword">dp</span>[-<span class="number">1</span>]就好了</span><br><span class="line">        :<span class="built_in">type</span> <span class="variable">s:</span> str</span><br><span class="line">        :<span class="built_in">type</span> wordDic<span class="variable">t:</span> List[str]</span><br><span class="line">        :rtype: bool</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        <span class="keyword">dp</span> = [False] * (<span class="built_in">len</span>(s)+<span class="number">1</span>) # <span class="keyword">dp</span>[]长度为<span class="built_in">len</span>(s)+<span class="number">1</span></span><br><span class="line">        <span class="keyword">dp</span>[<span class="number">0</span>] = True # 设置初始</span><br><span class="line">        <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">dp</span>[i]:</span><br><span class="line">                <span class="keyword">for</span> <span class="keyword">j</span> in <span class="built_in">range</span>(i+<span class="number">1</span>, <span class="built_in">len</span>(s)+<span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">if</span> s[i:<span class="keyword">j</span>] in wordDic<span class="variable">t:</span></span><br><span class="line">                        <span class="keyword">dp</span>[<span class="keyword">j</span>] = True</span><br><span class="line">                        # 提前结束条件</span><br><span class="line">                        <span class="keyword">if</span> <span class="keyword">j</span> == <span class="built_in">len</span>(s)+<span class="number">1</span>:</span><br><span class="line">                             <span class="keyword">return</span> True</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">dp</span>[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    <span class="keyword">print</span>(s.wordBreak(<span class="string">"catsandog"</span>, wordDict = [<span class="string">"cats"</span>, <span class="string">"dog"</span>, <span class="string">"sand"</span>, <span class="string">"and"</span>, <span class="string">"cat"</span>]))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第139题—单词拆分&lt;/h1&gt;
&lt;p&gt;这几天课比较多，有点忙，可能来不及更新喔&lt;/p&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click h
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.138</title>
    <link href="www.strivezs.com/2021/07/04/LeetCode%E7%AC%AC138%E9%A2%98/"/>
    <id>www.strivezs.com/2021/07/04/LeetCode%E7%AC%AC138%E9%A2%98/</id>
    <published>2021-07-04T03:06:21.328Z</published>
    <updated>2021-07-04T03:06:21.328Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第138题—复制带随机指针的链表</h1><p>今天获得了习近平七年知青岁月这本书，很开心！</p><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。</p><p>构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。</p><p>例如，如果原链表中有 X 和 Y 两个节点，其中 X.random --&gt; Y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random --&gt; y 。</p><p>返回复制链表的头节点。</p><p>用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：</p><p>val：一个表示 Node.val 的整数。<br>random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。<br>你的代码 只 接受原链表的头节点 head 作为传入参数。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e1.png" alt="figure.1"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：head = [[<span class="number">7</span>,<span class="literal">null</span>],[<span class="number">13</span>,<span class="number">0</span>],[<span class="number">11</span>,<span class="number">4</span>],[<span class="number">10</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">0</span>]]</span><br><span class="line">输出：[[<span class="number">7</span>,<span class="literal">null</span>],[<span class="number">13</span>,<span class="number">0</span>],[<span class="number">11</span>,<span class="number">4</span>],[<span class="number">10</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">0</span>]]</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e2.png" alt="figure.2"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：head = <span class="string">[[1,1],[2,1]]</span></span><br><span class="line">输出：<span class="string">[[1,1],[2,1]]</span></span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e3.png" alt="figure.3"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：head = [[<span class="number">3</span>,<span class="literal">null</span>],[<span class="number">3</span>,<span class="number">0</span>],[<span class="number">3</span>,<span class="literal">null</span>]]</span><br><span class="line">输出：[[<span class="number">3</span>,<span class="literal">null</span>],[<span class="number">3</span>,<span class="number">0</span>],[<span class="number">3</span>,<span class="literal">null</span>]]</span><br><span class="line">示例 <span class="number">4</span>：</span><br><span class="line"></span><br><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br><span class="line">解释：给定的链表为空（空指针），因此返回 <span class="literal">null</span>。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> &lt;= n &lt;= <span class="number">1000</span></span><br><span class="line"><span class="number">-10000</span> &lt;= Node.val &lt;= <span class="number">10000</span></span><br><span class="line">Node.random 为空（<span class="literal">null</span>）或指向链表中的节点。</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><h3 id="Python取巧方法（不建议！！！）"><a class="header-anchor" href="#Python取巧方法（不建议！！！）">¶</a>Python取巧方法（不建议！！！）</h3><p>如果是生活中可以用库，真正OJ不建议使用。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">copy</span>.<span class="built_in">deepcopy</span>(head)</span><br></pre></td></tr></table></figure><h3 id="实打实的哈希方法"><a class="header-anchor" href="#实打实的哈希方法">¶</a>实打实的哈希方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, next=None, random=None)</span>:</span></span><br><span class="line">        self.val = int(x)</span><br><span class="line">        self.next = next</span><br><span class="line">        self.random = random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        题目分析：</span></span><br><span class="line"><span class="string">            实质上就是链表的深度copy，同时要保留链表之间的random连接关系</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            比较困难的一点就是: 如何找到random对应的节点关系</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            想法：</span></span><br><span class="line"><span class="string">                因为random_index是对应的节点索引，因此考虑先不设置random关系来构建一个完全相同的链表，并将节点对应的索引构建一个MAP和索引对应的节点构建一个MAP</span></span><br><span class="line"><span class="string">                然后根据原来链表的random_index来构建索引关系</span></span><br><span class="line"><span class="string">            构建：</span></span><br><span class="line"><span class="string">                1. 旧链表：节点到index的映射</span></span><br><span class="line"><span class="string">                2. 新链表：index到节点的映射</span></span><br><span class="line"><span class="string">            第一遍遍历先构建一个全新的链表</span></span><br><span class="line"><span class="string">            第二遍遍历在根据哈希关系构建random关系</span></span><br><span class="line"><span class="string">        :type head: Node</span></span><br><span class="line"><span class="string">        :rtype: Node</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        index_node_dict = dict() <span class="comment"># 新链表的index和节点对应关系</span></span><br><span class="line">        node_index_dict = dict() <span class="comment"># 旧链表的节点和index对应关系</span></span><br><span class="line">        start = head</span><br><span class="line">        new_head = Node(head.val)</span><br><span class="line">        new_start = new_head</span><br><span class="line">        index_node_dict[<span class="number">0</span>] = new_head</span><br><span class="line">        node_index_dict[head] = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 构建一个新的链表</span></span><br><span class="line">        num = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> start.next != <span class="literal">None</span>:</span><br><span class="line">            start = start.next</span><br><span class="line">            node = Node(start.val)</span><br><span class="line">            new_start.next = node</span><br><span class="line">            new_start = node</span><br><span class="line">            index_node_dict[num] = node</span><br><span class="line">            node_index_dict[start] = num</span><br><span class="line">            num += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 构建random关系</span></span><br><span class="line">        start = head</span><br><span class="line">        new_start = new_head</span><br><span class="line">        <span class="keyword">while</span> start != <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 单独处理为NULL情况</span></span><br><span class="line">            <span class="keyword">if</span> start.random <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                new_start.random = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                new_start.random = index_node_dict[node_index_dict[start.random]] <span class="comment"># random是按照index索引的</span></span><br><span class="line">            start = start.next</span><br><span class="line">            new_start = new_start.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> new_head</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第138题—复制带随机指针的链表&lt;/h1&gt;
&lt;p&gt;今天获得了习近平七年知青岁月这本书，很开心！&lt;/p&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.137</title>
    <link href="www.strivezs.com/2021/07/03/LeetCode%E7%AC%AC137%E9%A2%98/"/>
    <id>www.strivezs.com/2021/07/03/LeetCode%E7%AC%AC137%E9%A2%98/</id>
    <published>2021-07-03T04:36:54.245Z</published>
    <updated>2021-07-03T04:36:54.245Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第137题—只出现一次的数字II</h1><p>今天获得了习近平七年知青岁月这本书，很开心！</p><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">99</span>]</span><br><span class="line">输出：<span class="number">99</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= nums.length &lt;= <span class="number">3</span> * <span class="number">104</span></span><br><span class="line"><span class="number">-231</span> &lt;= nums[i] &lt;= <span class="number">231</span> - <span class="number">1</span></span><br><span class="line">nums 中，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">进阶：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        还是考虑使用以前的异或操作，这里建立一个记忆字典，如果一个数出现了3次，则本次异或运算该数不参与运算了</span></span><br><span class="line"><span class="string">        所有的数只能出现3次或者1次，而且只有一个数可以出现1次 (充分利用这个思想)</span></span><br><span class="line"><span class="string">        然后就可以按照上一题的思路来做了:</span></span><br><span class="line"><span class="string">        异或^:</span></span><br><span class="line"><span class="string">            n ^ n = 0</span></span><br><span class="line"><span class="string">            0 ^ n = n</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        memory = dict()</span><br><span class="line">        res = nums[<span class="number">0</span>]</span><br><span class="line">        memory[res] = <span class="number">1</span> <span class="comment"># 出现次数设为1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] <span class="keyword">not</span> <span class="keyword">in</span> memory.keys():</span><br><span class="line">                memory[nums[i]] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                memory[nums[i]] += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 出现第三次就跳过</span></span><br><span class="line">            <span class="keyword">if</span> memory[nums[i]] == <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            res = res ^ nums[i]</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.singleNumber([<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>]))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第137题—只出现一次的数字II&lt;/h1&gt;
&lt;p&gt;今天获得了习近平七年知青岁月这本书，很开心！&lt;/p&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>TensorFlow-静态图和PyTorch-动态图区别</title>
    <link href="www.strivezs.com/2021/07/02/TensorFlow-%E9%9D%99%E6%80%81%E5%9B%BE%E5%92%8CPyTorch-%E5%8A%A8%E6%80%81%E5%9B%BE%E5%8C%BA%E5%88%AB/"/>
    <id>www.strivezs.com/2021/07/02/TensorFlow-%E9%9D%99%E6%80%81%E5%9B%BE%E5%92%8CPyTorch-%E5%8A%A8%E6%80%81%E5%9B%BE%E5%8C%BA%E5%88%AB/</id>
    <published>2021-07-02T03:04:08.034Z</published>
    <updated>2021-07-02T03:04:08.034Z</updated>
    
    <content type="html"><![CDATA[<h1>TensorFlow-静态图和PyTorch-动态图区别</h1><p>最近在重新学习一遍pytorch，之前对于自动求导中的计算图的概念不是很清楚，这里从头看了一遍，有了解一下，简单的写一下自己的笔记。</p><p>PyTorch自动求导看起来非常像TensorFlow，这两个框架中，我们都定义了计算图，使用自动微分来计算梯度，但是两者之间最大的不同是TensorFlow的计算图是静态的，而PyTorch使用的是动态的计算图。<br><strong>在TensorFlow中，我们定义计算图一次，然后后续就会重复执行这个相同的图，后面的话可能只是会提供不同的输入数据，而在PyTorch中，每一个前向通道(forward)定义一个新的计算图。</strong></p><p>静态图的好处在于你可以预先对图进行优化。例如：一个框架可能要融合一些图的运算来提升效率，或者产生一个策略来将图分布到多个GPU或者机器上，如果重复使用相同的图，那么再重复运行一个图时，前期潜在的代价高昂的预先优化的消耗就会被分摊开。</p><p>静态图和动态图的一个区别是<strong>控制流</strong>。对于一些模型，我们希望对每个数据点执行不同的计算。例如：一个递归神经网络可能对每个数据点执行不同的时间步数，这个展开（unrolling)可以作为一个循环来实现。<br>对于一个静态图，循环结构要作为图的一部分，因此TensorFlow提供了运算符来把循环嵌入到图当中。对于动态图来说，情况更加简单，既然我们为每个例子即时创建计算图，我们可以使用普通的命令式控制流来为每个输入执行不同的计算。</p><p><strong>tensorflow的forward只会根据第一次模型前向传播来构建一个静态的计算图, 后面的梯度自动求导都是根据这个计算图来计算的, 但是pytorch则不是, 它会为每次forward计算都构建一个动态图的计算图, 后续的每一次迭代都是使用一个新的计算图进行计算的.</strong></p><h2 id="PyTorch应用控制流的动态图实例"><a class="header-anchor" href="#PyTorch应用控制流的动态图实例">¶</a>PyTorch应用控制流的动态图实例</h2><p>作为动态图(网络结构发生变化并不影响计算图计算梯度)和权重共享的一个例子，我们实现了一个非常奇怪的模型：一个全连接的ReLU网络，在每一次前向传播时，它的隐藏层的层数为随机1到4之间的数，这样可以多次重用相同的权重来计算。</p><p>因为这个模型可以使用普通的Python流控制来实现循环，并且我们可以通过定义转发时多次重用同一个模块来实现最内层的权重共享。</p><p>下面是例子的代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># fixme: 定义网络</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DynamicNet</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, D_in, H, D_out)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        构造函数，在这里需要将网络的各个模块进行实例化, 并把他们作为成员变量</span></span><br><span class="line"><span class="string">        :params D_in: 输入维度</span></span><br><span class="line"><span class="string">        :params H: 隐藏层维度</span></span><br><span class="line"><span class="string">        :params D_out: 输出维度</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        super(DynamicNet, self).__init__()</span><br><span class="line">        </span><br><span class="line">        self.input_layer = nn.Linear(D_in, H)</span><br><span class="line">        self.hidden_layer = nn.Linear(H, H)</span><br><span class="line">        self.output_layer = nn.Linear(H, D_out)</span><br><span class="line">        </span><br><span class="line">        self.relu = nn.ReLU()</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        x1 = self.input_layer(x)</span><br><span class="line">        t_relu = self.relu(x1)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 定义0-3个隐藏层，利用pytorch动态图的特征，这种做法是可行的</span></span><br><span class="line">        <span class="comment">## 重复调用self.hidden_layer 0-3次，由于pytorch是采用动态图的，因此每一次forward都会创建一个新的动态图，不影响梯度计算</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(random.randint(<span class="number">0</span>, <span class="number">3</span>)):</span><br><span class="line">            t_relu = self.relu(self.hidden_layer(t_relu))</span><br><span class="line">        </span><br><span class="line">        pred = self.output_layer(t_relu)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> pred</span><br><span class="line"></span><br><span class="line"><span class="comment"># fixme: 参数配置</span></span><br><span class="line">dtype = torch.float</span><br><span class="line">device = torch.device(<span class="string">'cuda:0'</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">'cpu'</span>)</span><br><span class="line">N, D_in, H, D_out = <span class="number">64</span>, <span class="number">1000</span>, <span class="number">100</span>, <span class="number">10</span> <span class="comment"># N为批量大小，D_in是输入维度，H是隐藏层维度，D_out是输出层维度</span></span><br><span class="line">learning_rate = <span class="number">1e-4</span></span><br><span class="line">epochs = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># fixeme: 创建输入和输出随机张量</span></span><br><span class="line">input = torch.randn(N, D_in)</span><br><span class="line">label = torch.randn(N, D_out)</span><br><span class="line"></span><br><span class="line"><span class="comment"># fixme: 实例化模型</span></span><br><span class="line">model = DynamicNet(D_in, H, D_out)</span><br><span class="line"></span><br><span class="line"><span class="comment"># fixme: 损失函数的定义</span></span><br><span class="line">loss_fn = torch.nn.MSELoss(reduction=<span class="string">'sum'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># fixme: 使用torch.optim定义参数优化器</span></span><br><span class="line">optimizer = torch.optim.Adam(model.parameters(), lr = learning_rate) <span class="comment"># 这里用的是Adam</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># fixme: 训练</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(epochs):</span><br><span class="line">    <span class="comment"># 前向过程</span></span><br><span class="line">    pred = model(input)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算loss</span></span><br><span class="line">    loss = loss_fn(pred, label)</span><br><span class="line">    print(<span class="string">'当前代数:&#123;&#125;，当前loss为:&#123;&#125;'</span>.format(epoch,loss.item()))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 模型参数梯度置零</span></span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># loss反向传播</span></span><br><span class="line">    loss.backward()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 更新权重</span></span><br><span class="line">    optimizer.step()</span><br></pre></td></tr></table></figure><pre><code>当前代数:0，当前loss为:702.3717651367188当前代数:1，当前loss为:700.1735229492188当前代数:2，当前loss为:697.996826171875当前代数:3，当前loss为:701.37646484375当前代数:4，当前loss为:745.0324096679688当前代数:5，当前loss为:686.2260131835938当前代数:6，当前loss为:729.3468017578125当前代数:7，当前loss为:719.3234252929688当前代数:8，当前loss为:700.3496704101562当前代数:9，当前loss为:697.38720703125当前代数:10，当前loss为:676.840576171875当前代数:11，当前loss为:674.8969116210938当前代数:12，当前loss为:667.5950927734375当前代数:13，当前loss为:657.723388671875当前代数:14，当前loss为:668.5684814453125当前代数:15，当前loss为:691.20361328125当前代数:16，当前loss为:629.1569213867188当前代数:17，当前loss为:662.6659545898438当前代数:18，当前loss为:611.5732421875当前代数:19，当前loss为:602.4924926757812当前代数:20，当前loss为:698.65625当前代数:21，当前loss为:583.9902954101562当前代数:22，当前loss为:655.1369018554688当前代数:23，当前loss为:566.2965087890625当前代数:24，当前loss为:557.3516845703125当前代数:25，当前loss为:547.8927001953125当前代数:26，当前loss为:650.374755859375当前代数:27，当前loss为:648.9633178710938当前代数:28，当前loss为:697.7493286132812当前代数:29，当前loss为:515.4136962890625当前代数:30，当前loss为:507.982421875当前代数:31，当前loss为:500.00030517578125当前代数:32，当前loss为:491.6020812988281当前代数:33，当前loss为:482.8730163574219当前代数:34，当前loss为:697.01220703125当前代数:35，当前loss为:687.0211791992188当前代数:36，当前loss为:638.8866577148438当前代数:37，当前loss为:696.5703735351562当前代数:38，当前loss为:636.4703369140625当前代数:39，当前loss为:685.7159423828125当前代数:40，当前loss为:685.2298583984375当前代数:41，当前loss为:684.5957641601562当前代数:42，当前loss为:695.6959228515625当前代数:43，当前loss为:427.000732421875当前代数:44，当前loss为:682.4891967773438当前代数:45，当前loss为:419.1412048339844当前代数:46，当前loss为:681.0149536132812当前代数:47，当前loss为:694.716552734375当前代数:48，当前loss为:406.95831298828125当前代数:49，当前loss为:678.7310180664062当前代数:50，当前loss为:623.3473510742188当前代数:51，当前loss为:395.0804443359375当前代数:52，当前loss为:693.6585083007812当前代数:53，当前loss为:675.7344360351562当前代数:54，当前loss为:618.6995239257812当前代数:55，当前loss为:616.9414672851562当前代数:56，当前loss为:614.5744018554688当前代数:57，当前loss为:692.4542236328125当前代数:58，当前loss为:609.0692138671875当前代数:59，当前loss为:691.904052734375当前代数:60，当前loss为:603.1943359375当前代数:61，当前loss为:669.9990234375当前代数:62，当前loss为:691.0020141601562当前代数:63，当前loss为:594.264892578125当前代数:64，当前loss为:591.1102294921875当前代数:65，当前loss为:666.8950805664062当前代数:66，当前loss为:665.9771728515625当前代数:67，当前loss为:689.326171875当前代数:68，当前loss为:688.93701171875当前代数:69，当前loss为:688.5073852539062当前代数:70，当前loss为:574.0647583007812当前代数:71，当前loss为:661.115234375当前代数:72，当前loss为:660.0462036132812当前代数:73，当前loss为:566.465576171875当前代数:74，当前loss为:360.7765197753906当前代数:75，当前loss为:685.8043212890625当前代数:76，当前loss为:357.83026123046875当前代数:77，当前loss为:556.7740478515625当前代数:78，当前loss为:684.478515625当前代数:79，当前loss为:683.9954223632812当前代数:80，当前loss为:683.468994140625当前代数:81，当前loss为:650.9133911132812当前代数:82，当前loss为:545.8726806640625当前代数:83，当前loss为:543.443359375当前代数:84，当前loss为:540.5396118164062当前代数:85，当前loss为:342.5977478027344当前代数:86，当前loss为:645.627685546875当前代数:87，当前loss为:644.410888671875当前代数:88，当前loss为:642.9930419921875当前代数:89，当前loss为:641.402099609375当前代数:90，当前loss为:524.3102416992188当前代数:91，当前loss为:521.52880859375当前代数:92，当前loss为:518.2946166992188当前代数:93，当前loss为:676.001220703125当前代数:94，当前loss为:633.2501220703125当前代数:95，当前loss为:674.614501953125当前代数:96，当前loss为:673.8367919921875当前代数:97，当前loss为:628.274169921875当前代数:98，当前loss为:626.4828491210938当前代数:99，当前loss为:325.72052001953125</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;TensorFlow-静态图和PyTorch-动态图区别&lt;/h1&gt;
&lt;p&gt;最近在重新学习一遍pytorch，之前对于自动求导中的计算图的概念不是很清楚，这里从头看了一遍，有了解一下，简单的写一下自己的笔记。&lt;/p&gt;
&lt;p&gt;PyTorch自动求导看起来非常像TensorFl
      
    
    </summary>
    
    
      <category term="Knowledge" scheme="www.strivezs.com/categories/Knowledge/"/>
    
      <category term="PyTorch" scheme="www.strivezs.com/categories/Knowledge/PyTorch/"/>
    
    
      <category term="Knowledge" scheme="www.strivezs.com/tags/Knowledge/"/>
    
      <category term="PyTorch" scheme="www.strivezs.com/tags/PyTorch/"/>
    
      <category term="TensorFlow" scheme="www.strivezs.com/tags/TensorFlow/"/>
    
      <category term="计算图" scheme="www.strivezs.com/tags/%E8%AE%A1%E7%AE%97%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.136</title>
    <link href="www.strivezs.com/2021/07/02/LeetCode%E7%AC%AC136%E9%A2%98/"/>
    <id>www.strivezs.com/2021/07/02/LeetCode%E7%AC%AC136%E9%A2%98/</id>
    <published>2021-07-02T02:58:00.249Z</published>
    <updated>2021-07-02T02:58:00.249Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第136题—只出现一次的数字</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>说明：</p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: [<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: [<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="number">4</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        考虑用字典存储就好了</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res_dict = dict()</span><br><span class="line">        min_index = <span class="number">-1</span></span><br><span class="line">        min_count = <span class="number">10000</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] <span class="keyword">not</span> <span class="keyword">in</span> res_dict.keys():</span><br><span class="line">                res_dict[nums[i]] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res_dict[nums[i]] += <span class="number">1</span></span><br><span class="line">        res_dict = dict(sorted(res_dict.items(), key=<span class="keyword">lambda</span> item:item[<span class="number">1</span>]))</span><br><span class="line">        <span class="keyword">return</span> list(res_dict.keys())[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">faster_OR</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        参考大佬们的想法，采用异或操作: 还是要结合题意的，只有一个元素出现一次，其他元素出现两次，按照异或的规则，是可以进行操作的，如果其他的元素出现任意次，则不行</span></span><br><span class="line"><span class="string">            异或满足:</span></span><br><span class="line"><span class="string">                1.交换律：a ^ b ^ c &lt;=&gt; a ^ c ^ b</span></span><br><span class="line"><span class="string">                2.任何数于0异或为任何数 0 ^ n =&gt; n</span></span><br><span class="line"><span class="string">                3.相同的数异或为0: n ^ n =&gt; 0</span></span><br><span class="line"><span class="string">            因此可以考虑如下:</span></span><br><span class="line"><span class="string">            比如a = [2,3,3,3,4,4,2,1]</span></span><br><span class="line"><span class="string">            2^3^3^4^4^2^1 = 2^2^3^3^3^4^4^4^1 = 0^3^3^4^4^4^1 = 3^3^4^4^1 = 0^4^4^1 = 4^4^1 = 0^1 = 1</span></span><br><span class="line"><span class="string">        :param num:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">            res = res ^ nums[i]</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.faster_OR([<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>]))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第136题—只出现一次的数字&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)&lt;
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.134</title>
    <link href="www.strivezs.com/2021/07/01/LeetCode%E7%AC%AC135%E9%A2%98/"/>
    <id>www.strivezs.com/2021/07/01/LeetCode%E7%AC%AC135%E9%A2%98/</id>
    <published>2021-07-01T03:56:41.380Z</published>
    <updated>2021-07-01T03:56:41.380Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第135题—分发糖果</h1><p>今天是建党100周年，祝愿祖国繁荣富强！</p><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。</p><p>你需要按照以下要求，帮助老师给这些孩子分发糖果：</p><p>每个孩子至少分配到 1 个糖果。<br>评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果。<br>那么这样下来，老师至少需要准备多少颗糖果呢？</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：[<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：你可以分别给这三个孩子分发 <span class="number">2</span>、<span class="number">1</span>、<span class="number">2</span> 颗糖果。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：你可以分别给这三个孩子分发 <span class="number">1</span>、<span class="number">2</span>、<span class="number">1</span> 颗糖果。</span><br><span class="line">     第三个孩子只得到 <span class="number">1</span> 颗糖果，这已满足上述两个条件。</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">candy</span><span class="params">(self, ratings)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        题目分析:</span></span><br><span class="line"><span class="string">            N个孩子站成一条直线，每个孩子的评分提前给出</span></span><br><span class="line"><span class="string">            分配规则:</span></span><br><span class="line"><span class="string">            1.每个孩子至少分配到一个糖果</span></span><br><span class="line"><span class="string">            2.评分更高的孩子必须比他两侧的相邻的孩子获得更多地糖果, 但是如果这个孩子和旁边孩子分数相同，则它可以为1</span></span><br><span class="line"><span class="string">            3.如果一个孩子比他旁边的一个孩子分低，则只需要保证他分配的糖果比这个孩子少就行，同时保证比他另一个分低的孩子糖果多</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            相邻分配情况:</span></span><br><span class="line"><span class="string">            1. 分数相同: 1</span></span><br><span class="line"><span class="string">            2. 分数为3 1 2: 中间分配1个</span></span><br><span class="line"><span class="string">            3. 分数为3 2 1: 中间分配2个</span></span><br><span class="line"><span class="string">            4. 分数为1 3 2: 中间分配3个</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            需求:老师至少需要多少个糖果?</span></span><br><span class="line"><span class="string">        解题思路:</span></span><br><span class="line"><span class="string">            必然是秉持着贪心的思想来进行分配的，最小化分配的原则，默认初始所有人分配1个</span></span><br><span class="line"><span class="string">            分两个方向进行遍历，不要同时兼顾左边和右边，否则会顾此失彼</span></span><br><span class="line"><span class="string">            ① 正序遍历，先处理中间孩子和前面一个孩子进行比较</span></span><br><span class="line"><span class="string">            ② 倒序遍历，再处理中间孩子和后面一个孩子进行比较</span></span><br><span class="line"><span class="string">            如果中间孩子大于前面孩子则他的基础上+1，同理中间孩子如果大于后面孩子则他的基础上+1</span></span><br><span class="line"><span class="string">            其他小于等于均不作处理</span></span><br><span class="line"><span class="string">            在糖果个数本来就大的情况下，就不需要再加了</span></span><br><span class="line"><span class="string">        (还有一种暴力的方法，就是先处理分数最低的孩子，然后依次处理分数高得孩子，有点类似于对位处理，但是估计会超时)</span></span><br><span class="line"><span class="string">        :type ratings: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        candies = [<span class="number">1</span>] * len(ratings)</span><br><span class="line">        <span class="comment"># 正序遍历</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(ratings)):</span><br><span class="line">            <span class="comment"># 在糖果个数本来就大的情况下，就不需要再加了</span></span><br><span class="line">            <span class="keyword">if</span> ratings[i] &gt; ratings[i<span class="number">-1</span>] <span class="keyword">and</span> candies[i] &lt;= candies[i<span class="number">-1</span>]:</span><br><span class="line">                candies[i] = candies[i<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 倒序遍历</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(ratings)):</span><br><span class="line">            <span class="comment"># # 在糖果个数本来就大的情况下，就不需要再加了</span></span><br><span class="line">            <span class="keyword">if</span> ratings[len(ratings) - i] &lt; ratings[len(ratings) - i - <span class="number">1</span>] <span class="keyword">and</span> candies[len(ratings) - i] &gt;= candies[len(ratings) - i - <span class="number">1</span>]:</span><br><span class="line">                candies[len(ratings) - i - <span class="number">1</span>] = candies[len(ratings) - i] + <span class="number">1</span></span><br><span class="line">        <span class="comment">#print(candies)</span></span><br><span class="line">        <span class="keyword">return</span> sum(candies)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.candy([<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>]))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第135题—分发糖果&lt;/h1&gt;
&lt;p&gt;今天是建党100周年，祝愿祖国繁荣富强！&lt;/p&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click h
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>给服务器上的Jupyter Lab安装Kite进行自动代码补全设置</title>
    <link href="www.strivezs.com/2021/06/30/%E7%BB%99%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84Jupyter%20Lab%E5%AE%89%E8%A3%85Kite%E8%BF%9B%E8%A1%8C%E8%87%AA%E5%8A%A8%E4%BB%A3%E7%A0%81%E8%A1%A5%E5%85%A8%E8%AE%BE%E7%BD%AE/"/>
    <id>www.strivezs.com/2021/06/30/%E7%BB%99%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84Jupyter%20Lab%E5%AE%89%E8%A3%85Kite%E8%BF%9B%E8%A1%8C%E8%87%AA%E5%8A%A8%E4%BB%A3%E7%A0%81%E8%A1%A5%E5%85%A8%E8%AE%BE%E7%BD%AE/</id>
    <published>2021-06-30T03:33:05.924Z</published>
    <updated>2021-06-30T03:33:05.924Z</updated>
    
    <content type="html"><![CDATA[<h1>给服务器上的Jupyter Lab安装Kite进行自动代码补全设置</h1><h2 id="安装Jupyter-Lab"><a class="header-anchor" href="#安装Jupyter-Lab">¶</a>安装Jupyter Lab</h2><p>使用如下命令安装Jupyter Lab:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda <span class="keyword">install</span> juputerlab</span><br></pre></td></tr></table></figure><h2 id="安装Kite"><a class="header-anchor" href="#安装Kite">¶</a>安装Kite</h2><p>这里我是在docker中安装的kite，需要下载kite的安装包，又因为docker容器内没有wget，因此现需要安装wget，使用如下命令:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> install wget</span><br></pre></td></tr></table></figure><p>安装完成wget之后使用如下命令安装kite：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bash </span>-c <span class="string">"$(wget -q -O - https://linux.kite.com/dls/linux/current)"</span></span><br></pre></td></tr></table></figure><p>想要关闭的时候直接在 htop 面板中找到 pid 然后将进程 kill 掉即可。</p><h2 id="设置Kite开机自启"><a class="header-anchor" href="#设置Kite开机自启">¶</a>设置Kite开机自启</h2><p>根据给的提示可以看出需要使用命令进行如下操作:</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[installer] kite <span class="keyword">is</span> installed! launching now! happy coding! :)</span><br><span class="line">[installer] <span class="keyword">with</span> systemd, <span class="built_in">run</span> systemctl <span class="comment">--user start kite-autostart</span></span><br><span class="line">[installer] <span class="keyword">without</span> systemd, <span class="built_in">run</span> /home/user/.<span class="keyword">local</span>/share/kite/kited</span><br><span class="line">[installer] <span class="keyword">or</span> <span class="built_in">launch</span> <span class="keyword">it</span> using <span class="keyword">the</span> Applications Menu</span><br><span class="line">Removing kite-installer</span><br></pre></td></tr></table></figure><p>由于我是在docker中运行的，没有systemd命令，因此需要先使用如下命令安装systemd:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> install --reinstall systemd</span><br><span class="line">sudo apt-<span class="builtin-name">get</span> install systemd</span><br></pre></td></tr></table></figure><p>安装完成之后，使用如下命令设置kite自动运行:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl --<span class="keyword">user</span> <span class="title">start</span> kite-autostart</span><br></pre></td></tr></table></figure><h3 id="手动开启-每次启动docker都要打开"><a class="header-anchor" href="#手动开启-每次启动docker都要打开">¶</a>手动开启 每次启动docker都要打开</h3><p>如果没有安装systemctl成功的话，可以使用手动的方式进行启动, 命令如下:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/home/u</span>ser<span class="regexp">/.local/</span>share<span class="regexp">/kite/</span>kited</span><br></pre></td></tr></table></figure><h2 id="为Jupyter-Lab安装Kite扩展"><a class="header-anchor" href="#为Jupyter-Lab安装Kite扩展">¶</a>为Jupyter Lab安装Kite扩展</h2><p>对于 3.0 版本以上的 JupyterLab，运行如下命令:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install</span> <span class="string">"jupyterlab-kite&gt;=2.0.2"</span></span><br></pre></td></tr></table></figure><p>亲测conda install安装失败了不知道为啥。</p><p>完成以上两步以后重启 JupyterLab，会自动弹出一个 Kite 的教程。</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/OSNQAf.png" alt="figure.1"></p><p>等待kite ready即可</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/JNV0ls.png" alt="figure.2"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;给服务器上的Jupyter Lab安装Kite进行自动代码补全设置&lt;/h1&gt;
&lt;h2 id=&quot;安装Jupyter-Lab&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#安装Jupyter-Lab&quot;&gt;¶&lt;/a&gt;安装Jupyter Lab&lt;/h2&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="Linux" scheme="www.strivezs.com/categories/Linux/"/>
    
      <category term="Jupyter" scheme="www.strivezs.com/categories/Linux/Jupyter/"/>
    
      <category term="服务器" scheme="www.strivezs.com/categories/Linux/Jupyter/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="Python" scheme="www.strivezs.com/tags/Python/"/>
    
      <category term="Linux" scheme="www.strivezs.com/tags/Linux/"/>
    
      <category term="服务器" scheme="www.strivezs.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="Jupyter" scheme="www.strivezs.com/tags/Jupyter/"/>
    
      <category term="Kite" scheme="www.strivezs.com/tags/Kite/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.134</title>
    <link href="www.strivezs.com/2021/06/30/LeetCode%E7%AC%AC134%E9%A2%98/"/>
    <id>www.strivezs.com/2021/06/30/LeetCode%E7%AC%AC134%E9%A2%98/</id>
    <published>2021-06-30T03:26:44.400Z</published>
    <updated>2021-06-30T03:26:44.400Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第134题—加油站</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p><p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</p><p>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p><p>说明:</p><ul><li>如果题目有解，该答案即为唯一答案。</li><li>输入数组均为非空数组，且长度相同。</li><li>输入数组中的元素均为非负数。</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: </span><br><span class="line">gas  = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">cost = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">从 <span class="number">3</span> 号加油站(索引为 <span class="number">3</span> 处)出发，可获得 <span class="number">4</span> 升汽油。此时油箱有 = <span class="number">0</span> + <span class="number">4</span> = <span class="number">4</span> 升汽油</span><br><span class="line">开往 <span class="number">4</span> 号加油站，此时油箱有 <span class="number">4</span> - <span class="number">1</span> + <span class="number">5</span> = <span class="number">8</span> 升汽油</span><br><span class="line">开往 <span class="number">0</span> 号加油站，此时油箱有 <span class="number">8</span> - <span class="number">2</span> + <span class="number">1</span> = <span class="number">7</span> 升汽油</span><br><span class="line">开往 <span class="number">1</span> 号加油站，此时油箱有 <span class="number">7</span> - <span class="number">3</span> + <span class="number">2</span> = <span class="number">6</span> 升汽油</span><br><span class="line">开往 <span class="number">2</span> 号加油站，此时油箱有 <span class="number">6</span> - <span class="number">4</span> + <span class="number">3</span> = <span class="number">5</span> 升汽油</span><br><span class="line">开往 <span class="number">3</span> 号加油站，你需要消耗 <span class="number">5</span> 升汽油，正好足够你返回到 <span class="number">3</span> 号加油站。</span><br><span class="line">因此，<span class="number">3</span> 可为起始索引。</span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: </span><br><span class="line">gas  = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">cost = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">输出: <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">你不能从 <span class="number">0</span> 号或 <span class="number">1</span> 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。</span><br><span class="line">我们从 <span class="number">2</span> 号加油站出发，可以获得 <span class="number">4</span> 升汽油。 此时油箱有 = <span class="number">0</span> + <span class="number">4</span> = <span class="number">4</span> 升汽油</span><br><span class="line">开往 <span class="number">0</span> 号加油站，此时油箱有 <span class="number">4</span> - <span class="number">3</span> + <span class="number">2</span> = <span class="number">3</span> 升汽油</span><br><span class="line">开往 <span class="number">1</span> 号加油站，此时油箱有 <span class="number">3</span> - <span class="number">3</span> + <span class="number">3</span> = <span class="number">3</span> 升汽油</span><br><span class="line">你无法返回 <span class="number">2</span> 号加油站，因为返程需要消耗 <span class="number">4</span> 升汽油，但是你的油箱只有 <span class="number">3</span> 升汽油。</span><br><span class="line">因此，无论怎样，你都不可能绕环路行驶一周。</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canCompleteCircuit</span><span class="params">(self, gas, cost)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        分析：</span></span><br><span class="line"><span class="string">            第i个加油站有gas[i]升汽油，从第i个加油站开往第i+1个加油站需要消耗汽油cost[i]升，从这里可以看出，行驶方向只能正序0-&gt;1-&gt;2这种</span></span><br><span class="line"><span class="string">            油箱容量无限，从其中一个加油站出发，初始油箱为空</span></span><br><span class="line"><span class="string">            目标：绕环路一圈，则返回出发加油站编号，否则返回-1  (如果有解则解唯一)</span></span><br><span class="line"><span class="string">        思路:</span></span><br><span class="line"><span class="string">            1. 用gas对应位去减去cost得到一个subtraction</span></span><br><span class="line"><span class="string">            2. subtraction的总和大于等于0的话，则一定是有解的</span></span><br><span class="line"><span class="string">            3. 如果有解的话，subtraction为负值的地方，则表示不能作为初始的位置, 所有非负的地方都可以作为候选起始位置，这个时候要要根据subtraction来判断那个位置作为初始位置(唯一)</span></span><br><span class="line"><span class="string">            4. 依次判断上面非负位置</span></span><br><span class="line"><span class="string">            5. 可能会出现几种结束条件</span></span><br><span class="line"><span class="string">              i) i=0 j=4 总和满足大于等于0的合法情况</span></span><br><span class="line"><span class="string">              ii) i=3 j=2 总和满足大于等于0的合法情况</span></span><br><span class="line"><span class="string">              iii) 总和小于0的非法情况</span></span><br><span class="line"><span class="string">        :type gas: List[int]</span></span><br><span class="line"><span class="string">        :type cost: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        subtraction = list(map(<span class="keyword">lambda</span> x:x[<span class="number">0</span>]-x[<span class="number">1</span>],zip(gas,cost))) <span class="comment"># 进行数组对应位相减</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(subtraction)):</span><br><span class="line">            <span class="keyword">if</span> subtraction[i] &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            j = i</span><br><span class="line">            curSum = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                curSum += subtraction[j]</span><br><span class="line">                <span class="comment"># i=4 j=3这种情况的结束条件</span></span><br><span class="line">                <span class="keyword">if</span> j == i<span class="number">-1</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="comment"># j=4 i=0这种情况的结束条件</span></span><br><span class="line">                <span class="keyword">if</span> j - i + <span class="number">1</span> == len(subtraction):</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> curSum &lt; <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> j &lt; len(subtraction)<span class="number">-1</span>:</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    j = <span class="number">0</span></span><br><span class="line">            <span class="comment"># 符合的判决条件</span></span><br><span class="line">            <span class="keyword">if</span> (j == i<span class="number">-1</span> <span class="keyword">or</span> j - i + <span class="number">1</span> == len(subtraction)) <span class="keyword">and</span> curSum &gt;=<span class="number">0</span> :</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.canCompleteCircuit([<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第134题—加油站&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.133</title>
    <link href="www.strivezs.com/2021/06/16/LeetCode%E7%AC%AC133%E9%A2%98/"/>
    <id>www.strivezs.com/2021/06/16/LeetCode%E7%AC%AC133%E9%A2%98/</id>
    <published>2021-06-16T11:53:17.361Z</published>
    <updated>2021-06-16T11:53:17.361Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第133题—克隆图</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。</p><p>图中的每个节点都包含它的值 val（int） 和其邻居的列表（list[Node]）。</p><p>class Node {<br>public int val;<br>public List<Node> neighbors;<br>}</p><p>测试用例格式：</p><p>简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（val = 1），第二个节点值为 2（val = 2），以此类推。该图在测试用例中使用邻接列表表示。</p><p>邻接列表 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。</p><p>给定节点将始终是图中的第一个节点（值为 1）。你必须将 给定节点的拷贝 作为对克隆图的引用返回。</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/8GP8e1.jpg" alt="figure.1"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：adjList = [[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">3</span>]]</span><br><span class="line">输出：[[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">3</span>]]</span><br><span class="line">解释：</span><br><span class="line">图中有 <span class="number">4</span> 个节点。</span><br><span class="line">节点 <span class="number">1</span> 的值是 <span class="number">1</span>，它有两个邻居：节点 <span class="number">2</span> 和 <span class="number">4</span> 。</span><br><span class="line">节点 <span class="number">2</span> 的值是 <span class="number">2</span>，它有两个邻居：节点 <span class="number">1</span> 和 <span class="number">3</span> 。</span><br><span class="line">节点 <span class="number">3</span> 的值是 <span class="number">3</span>，它有两个邻居：节点 <span class="number">2</span> 和 <span class="number">4</span> 。</span><br><span class="line">节点 <span class="number">4</span> 的值是 <span class="number">4</span>，它有两个邻居：节点 <span class="number">1</span> 和 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/zyp521/upload_image/raw/master/u922LX.jpg" alt="figure.2"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：adjList = <span class="string">[[]]</span></span><br><span class="line">输出：<span class="string">[[]]</span></span><br><span class="line">解释：输入包含一个空列表。该图仅仅只有一个值为 <span class="number">1</span> 的节点，它没有任何邻居。</span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：adjList = []</span><br><span class="line">输出：[]</span><br><span class="line">解释：这个图是空的，它不含任何节点。</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/zyp521/upload_image/raw/master/iaX0Mu.jpg" alt="figure.3"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">4</span>：</span><br><span class="line"></span><br><span class="line">输入：adjList = <span class="string">[[2],[1]]</span></span><br><span class="line">输出：<span class="string">[[2],[1]]</span></span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">节点数不超过 <span class="number">100</span> 。</span><br><span class="line">每个节点值 Node.val 都是唯一的，<span class="number">1</span> &lt;= Node.val &lt;= <span class="number">100</span>。</span><br><span class="line">无向图是一个简单图，这意味着图中没有重复的边，也没有自环。</span><br><span class="line">由于图是无向的，如果节点 p 是节点 q 的邻居，那么节点 q 也必须是节点 p 的邻居。</span><br><span class="line">图是连通图，你可以从给定节点访问到所有节点。</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><p>好奇挖，自己写的命名逻辑一点问题都没有，硬是不接受！！！</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a Node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, val = <span class="number">0</span>, neighbors = None)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.val = val</span><br><span class="line">        <span class="keyword">self</span>.neighbors = neighbors <span class="keyword">if</span> neighbors is <span class="keyword">not</span> None <span class="keyword">else</span> []</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="title">object</span>):</span></span><br><span class="line">    node_neighbors_relation_dict = dict()</span><br><span class="line">    val_node = dict()</span><br><span class="line">    <span class="comment"># fixme:DFS建图</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(<span class="keyword">self</span>, node)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">if</span> node.val <span class="keyword">not</span> <span class="keyword">in</span> <span class="keyword">self</span>.node_neighbors_relation_dict.keys()<span class="symbol">:</span></span><br><span class="line">            <span class="keyword">if</span> node.val <span class="keyword">not</span> <span class="keyword">in</span> <span class="keyword">self</span>.val_node.keys()<span class="symbol">:</span></span><br><span class="line">                <span class="keyword">self</span>.val_node[node.val] = Node(node.val)</span><br><span class="line">            <span class="keyword">self</span>.node_neighbors_relation_dict[node.val] = []</span><br><span class="line">            <span class="keyword">if</span> len(node.neighbors) != <span class="number">0</span><span class="symbol">:</span></span><br><span class="line">                <span class="keyword">for</span> item <span class="keyword">in</span> node.<span class="symbol">neighbors:</span></span><br><span class="line">                    <span class="keyword">self</span>.node_neighbors_relation_dict[node.val].append(item.val)</span><br><span class="line">                    <span class="keyword">self</span>.dfs(item)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(<span class="keyword">self</span>, node)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        :type node: Node</span></span><br><span class="line"><span class="string">        :rtype: Node</span></span><br><span class="line"><span class="string">        几个前提条件:</span></span><br><span class="line"><span class="string">            1. 每个节点值 Node.val 都是唯一的，利用这一点就可以建立一个访问过节点的列表，保证不会再次被访问</span></span><br><span class="line"><span class="string">            2. 图是连通图，你可以从给定节点访问到所有节点</span></span><br><span class="line"><span class="string">            3. 由于图是无向的，如果节点 p 是节点 q 的邻居，那么节点 q 也必须是节点 p 的邻居</span></span><br><span class="line"><span class="string">        然后采用深度DFS形成邻居关系字典，其实这里考虑使用邻接矩阵或者邻接表也可以</span></span><br><span class="line"><span class="string">        然后最后再利用字典关系进行建图</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        <span class="keyword">self</span>.node_neighbors_relation_dict = dict()</span><br><span class="line">        <span class="keyword">self</span>.val_node = dict()</span><br><span class="line">        <span class="keyword">if</span> node == <span class="symbol">None:</span></span><br><span class="line">            <span class="keyword">return</span> None</span><br><span class="line">        <span class="keyword">self</span>.dfs(node)</span><br><span class="line">        <span class="comment"># 利用构建的节点邻居关系字典来建图</span></span><br><span class="line">        res = None</span><br><span class="line">        num = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> <span class="keyword">self</span>.node_neighbors_relation_dict.keys()<span class="symbol">:</span></span><br><span class="line">            temp = Node(item)</span><br><span class="line">            <span class="keyword">if</span> num == <span class="number">1</span><span class="symbol">:</span></span><br><span class="line">                res = temp</span><br><span class="line">                num +=<span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> iNode <span class="keyword">in</span> <span class="keyword">self</span>.node_neighbors_relation_dict[item]<span class="symbol">:</span></span><br><span class="line">                temp.neighbors.append(<span class="keyword">self</span>.val_node[iNode])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    res = dict()</span><br><span class="line">    <span class="comment"># fixme:上一个版本出问题了，下面是修正版本，虽然没找出来什么问题</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">DFS_NV</span><span class="params">(<span class="keyword">self</span>, node)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.res[node] = Node(node.val) <span class="comment"># 新建节点</span></span><br><span class="line">        <span class="keyword">for</span> iNode <span class="keyword">in</span> node.<span class="symbol">neighbors:</span></span><br><span class="line">            <span class="keyword">if</span> iNode <span class="keyword">not</span> <span class="keyword">in</span> <span class="keyword">self</span>.res.keys()<span class="symbol">:</span></span><br><span class="line">                <span class="keyword">self</span>.res[node].neighbors = [<span class="keyword">self</span>.DFS_NV(iNode)]</span><br><span class="line">            <span class="symbol">else:</span></span><br><span class="line">                <span class="keyword">self</span>.res[node].neighbors = [<span class="keyword">self</span>.res[iNode]]</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.res[node]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cloneGraph</span><span class="params">(<span class="keyword">self</span>, node)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        :type node: Node</span></span><br><span class="line"><span class="string">        :rtype: Node</span></span><br><span class="line"><span class="string">        几个前提条件:</span></span><br><span class="line"><span class="string">            1. 每个节点值 Node.val 都是唯一的，利用这一点就可以建立一个访问过节点的列表，保证不会再次被访问</span></span><br><span class="line"><span class="string">            2. 图是连通图，你可以从给定节点访问到所有节点</span></span><br><span class="line"><span class="string">            3. 由于图是无向的，如果节点 p 是节点 q 的邻居，那么节点 q 也必须是节点 p 的邻居</span></span><br><span class="line"><span class="string">        然后采用深度DFS形成邻居关系字典，其实这里考虑使用邻接矩阵或者邻接表也可以</span></span><br><span class="line"><span class="string">        然后最后再利用字典关系进行建图</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        <span class="keyword">if</span> node == <span class="symbol">None:</span></span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        <span class="keyword">self</span>.res = dict()</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.DFS_NV(node)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name_<span class="number">_</span> == <span class="string">'__main__'</span><span class="symbol">:</span></span><br><span class="line">    node1 = Node(<span class="number">1</span>)</span><br><span class="line">    node2 = Node(<span class="number">2</span>)</span><br><span class="line">    node3 = Node(<span class="number">3</span>)</span><br><span class="line">    node4 = Node(<span class="number">4</span>)</span><br><span class="line">    node1.neighbors.append(node2)</span><br><span class="line">    node1.neighbors.append(node4)</span><br><span class="line">    node2.neighbors.append(node1)</span><br><span class="line">    node2.neighbors.append(node3)</span><br><span class="line">    node3.neighbors.append(node2)</span><br><span class="line">    node3.neighbors.append(node4)</span><br><span class="line">    node4.neighbors.append(node1)</span><br><span class="line">    node4.neighbors.append(node3)</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.cloneGraph(node1).val)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第133题—克隆图&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.132</title>
    <link href="www.strivezs.com/2021/06/14/LeetCode%E7%AC%AC132%E9%A2%98/"/>
    <id>www.strivezs.com/2021/06/14/LeetCode%E7%AC%AC132%E9%A2%98/</id>
    <published>2021-06-14T14:35:37.191Z</published>
    <updated>2021-06-14T14:35:37.191Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第132题—分隔回文串II</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是回文。</p><p>返回符合要求的 最少分割次数 。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"aab"</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：只需一次分割就可将 s 分割成 [<span class="string">"aa"</span>,<span class="string">"b"</span>] 这样两个回文子串。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"a"</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"ab"</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= s.length &lt;= <span class="number">2000</span></span><br><span class="line">s 仅由小写英文字母组成</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># fixme:判断是否是回文串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> s == s[::<span class="number">-1</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="comment"># fixme:回溯法超时版本</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">time_out</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        最终的结果，每个字符单独拿出来肯定是一个回文串, 因此不存在空字符串结果的情况，除非输入就是空串</span></span><br><span class="line"><span class="string">        算法考虑的话，有两种方法:</span></span><br><span class="line"><span class="string">            1. 动态规划</span></span><br><span class="line"><span class="string">            2. 回溯法</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: List[List[str]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># 回溯法</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(s, res, path)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">                res.append(len(path))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s) + <span class="number">1</span>):  <span class="comment"># 注意起始和结束位置</span></span><br><span class="line">                <span class="keyword">if</span> self.isPalindrome(s[:i]):</span><br><span class="line">                    backtrack(s[i:], res, path + [s[:i]])</span><br><span class="line">        backtrack(s,res,[])</span><br><span class="line">        <span class="keyword">return</span> min(res)<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># fixme:动态规划版本</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCut</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        dp = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s))] <span class="comment"># 创建dp数组  0-len(s)-1 最少划分0次最多都划分完</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>):</span><br><span class="line">                temp = s[j:i+<span class="number">1</span>]</span><br><span class="line">                <span class="comment"># 如果是回文串</span></span><br><span class="line">                <span class="keyword">if</span> temp == temp[::<span class="number">-1</span>]:</span><br><span class="line">                    <span class="keyword">if</span> j &gt; <span class="number">0</span>:</span><br><span class="line">                        dp[i] = min(dp[i], dp[j - <span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> dp[len(s) - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第132题—分隔回文串II&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)&lt;/
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.131</title>
    <link href="www.strivezs.com/2021/06/13/LeetCode%E7%AC%AC131%E9%A2%98/"/>
    <id>www.strivezs.com/2021/06/13/LeetCode%E7%AC%AC131%E9%A2%98/</id>
    <published>2021-06-13T03:52:35.085Z</published>
    <updated>2021-06-13T03:52:35.085Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第131题—分隔回文串</h1><p>昨天端午鸽了塞</p><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。</p><p>回文串 是正着读和反着读都一样的字符串。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"aab"</span></span><br><span class="line">输出：[[<span class="string">"a"</span>,<span class="string">"a"</span>,<span class="string">"b"</span>],[<span class="string">"aa"</span>,<span class="string">"b"</span>]]</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"a"</span></span><br><span class="line">输出：[[<span class="string">"a"</span>]]</span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= s.length &lt;= <span class="number">16</span></span><br><span class="line">s 仅由小写英文字母组成</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="comment"># fixme:判断是否是回文串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> s == s[::<span class="number">-1</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        最终的结果，每个字符单独拿出来肯定是一个回文串, 因此不存在空字符串结果的情况，除非输入就是空串</span></span><br><span class="line"><span class="string">        算法考虑的话，有两种方法:</span></span><br><span class="line"><span class="string">            1. 动态规划</span></span><br><span class="line"><span class="string">            2. 回溯法</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: List[List[str]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.res = []</span><br><span class="line">        <span class="comment"># 回溯法</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(s, path)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(s) == <span class="number">0</span>:</span><br><span class="line">                tt = copy.copy(path) <span class="comment"># 如果直接用self.res.append(path)的话，由于是浅拷贝，后面再path.remove的话，res中的结果也会被修改</span></span><br><span class="line">                self.res.append(tt)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s) + <span class="number">1</span>):  <span class="comment"># 注意起始和结束位置</span></span><br><span class="line">                <span class="keyword">if</span> self.isPalindrome(s[:i]):</span><br><span class="line">                    path.append(s[:i])</span><br><span class="line">                    backtrack(s[i:], path)</span><br><span class="line">                    path.remove(s[:i])</span><br><span class="line">        backtrack(s,[])</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.partition(<span class="string">"a"</span>))</span><br></pre></td></tr></table></figure><h3 id="更加推荐的写法"><a class="header-anchor" href="#更加推荐的写法">¶</a>更加推荐的写法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># fixme:判断是否是回文串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> s == s[::<span class="number">-1</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        最终的结果，每个字符单独拿出来肯定是一个回文串, 因此不存在空字符串结果的情况，除非输入就是空串</span></span><br><span class="line"><span class="string">        算法考虑的话，有两种方法:</span></span><br><span class="line"><span class="string">            1. 动态规划</span></span><br><span class="line"><span class="string">            2. 回溯法</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: List[List[str]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># 回溯法</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(s, res, path)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">                res.append(path)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s) + <span class="number">1</span>):  <span class="comment"># 注意起始和结束位置</span></span><br><span class="line">                <span class="keyword">if</span> self.isPalindrome(s[:i]):</span><br><span class="line">                    backtrack(s[i:], res, path + [s[:i]])</span><br><span class="line">        backtrack(s,res,[])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第131题—分隔回文串&lt;/h1&gt;
&lt;p&gt;昨天端午鸽了塞&lt;/p&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎S
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>PyCharm连接远程服务器</title>
    <link href="www.strivezs.com/2021/06/10/PyCharm%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>www.strivezs.com/2021/06/10/PyCharm%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2021-06-10T04:48:12.812Z</published>
    <updated>2021-06-10T04:48:12.812Z</updated>
    
    <content type="html"><![CDATA[<h1>PyCharm连接远程服务器</h1><p>使用PyCharm连接远程服务器，并使用服务器的解释器和代码文件来进行运行。</p><h2 id="配置Deplotment"><a class="header-anchor" href="#配置Deplotment">¶</a>配置Deplotment</h2><p>在这之前首先建议，要单独创建一个项目文件夹，因为当前项目的文件都会被自动上传上去。</p><p><img src="https://pic1.zhimg.com/80/v2-b499139f685fe9d8615d4287c0bff230_1440w.jpg" alt="figure.1"></p><p><img src="https://pic3.zhimg.com/80/v2-c2be0d6a5587784bcac2658aac39d106_1440w.jpg" alt="figure.2"></p><p>选择你的服务器的地址和你本地的地址:</p><p><img src="https://pic4.zhimg.com/80/v2-ad6ee2f63c3d36236a5c796f7810aa2f_1440w.jpg" alt="figure.3"></p><h2 id="配置解释器"><a class="header-anchor" href="#配置解释器">¶</a>配置解释器</h2><p>该项目现在使用的就是远程服务器上的Python解释器了。以后的项目若想/不想使用该解释器，手动更改解释器即可。<br>目前来说直接配置解释器就可以完成上面的Deployment的操作.</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/D2JQ9A.png" alt="figure.4"></p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/G8MUAj.png" alt="figure.5"></p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/V9UfmX.png" alt="figure.6"></p><h2 id="测试"><a class="header-anchor" href="#测试">¶</a>测试</h2><p>新建一个文件，然后同步上去直接使用如下代码进行测试:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">print</span>(<span class="string">'hello'</span>)</span><br><span class="line">import torch</span><br><span class="line">flag = torch.cuda.is_available()</span><br><span class="line"><span class="builtin-name">print</span>(flag)</span><br><span class="line">ngpu= 1</span><br><span class="line"><span class="comment"># Decide which device we want to run on</span></span><br><span class="line">device = torch.device(<span class="string">"cuda:0"</span> <span class="keyword">if</span> (torch.cuda.is_available() <span class="keyword">and</span> ngpu &gt; 0) <span class="keyword">else</span> <span class="string">"cpu"</span>)</span><br><span class="line"><span class="builtin-name">print</span>(device)</span><br><span class="line"><span class="builtin-name">print</span>(torch.cuda.get_device_name(0))</span><br><span class="line"><span class="builtin-name">print</span>(torch.rand(3,3).cuda())</span><br></pre></td></tr></table></figure><p>出现如下结果:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">True</span><br><span class="line">cuda:<span class="number">0</span></span><br><span class="line">GeForce RTX <span class="number">2080</span></span><br><span class="line">tensor([[<span class="number">0.3170</span>, <span class="number">0.4412</span>, <span class="number">0.3377</span>],</span><br><span class="line">        [<span class="number">0.5438</span>, <span class="number">0.0894</span>, <span class="number">0.6420</span>],</span><br><span class="line">        [<span class="number">0.0981</span>, <span class="number">0.2753</span>, <span class="number">0.0179</span>]], device=<span class="string">'cuda:0'</span>)</span><br></pre></td></tr></table></figure><p>则表明成功了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;PyCharm连接远程服务器&lt;/h1&gt;
&lt;p&gt;使用PyCharm连接远程服务器，并使用服务器的解释器和代码文件来进行运行。&lt;/p&gt;
&lt;h2 id=&quot;配置Deplotment&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#配置Deplotment&quot;&gt;¶&lt;
      
    
    </summary>
    
    
      <category term="Python" scheme="www.strivezs.com/categories/Python/"/>
    
    
      <category term="Python" scheme="www.strivezs.com/tags/Python/"/>
    
      <category term="PyCharm" scheme="www.strivezs.com/tags/PyCharm/"/>
    
      <category term="Linux" scheme="www.strivezs.com/tags/Linux/"/>
    
      <category term="服务器" scheme="www.strivezs.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.130</title>
    <link href="www.strivezs.com/2021/06/10/LeetCode%E7%AC%AC130%E9%A2%98/"/>
    <id>www.strivezs.com/2021/06/10/LeetCode%E7%AC%AC130%E9%A2%98/</id>
    <published>2021-06-10T04:45:26.129Z</published>
    <updated>2021-06-10T04:45:26.129Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第130题—被围绕的区域</h1><p>恢复正常！！</p><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给你一个 m x n 的矩阵 board ，由若干字符 ‘X’ 和 ‘O’ ，找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。</p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/xogrid.jpg" alt="figure.1"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：board = [[<span class="string">"X"</span>,<span class="string">"X"</span>,<span class="string">"X"</span>,<span class="string">"X"</span>],[<span class="string">"X"</span>,<span class="string">"O"</span>,<span class="string">"O"</span>,<span class="string">"X"</span>],[<span class="string">"X"</span>,<span class="string">"X"</span>,<span class="string">"O"</span>,<span class="string">"X"</span>],[<span class="string">"X"</span>,<span class="string">"O"</span>,<span class="string">"X"</span>,<span class="string">"X"</span>]]</span><br><span class="line">输出：[[<span class="string">"X"</span>,<span class="string">"X"</span>,<span class="string">"X"</span>,<span class="string">"X"</span>],[<span class="string">"X"</span>,<span class="string">"X"</span>,<span class="string">"X"</span>,<span class="string">"X"</span>],[<span class="string">"X"</span>,<span class="string">"X"</span>,<span class="string">"X"</span>,<span class="string">"X"</span>],[<span class="string">"X"</span>,<span class="string">"O"</span>,<span class="string">"X"</span>,<span class="string">"X"</span>]]</span><br><span class="line">解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的 <span class="string">'O'</span> 都不会被填充为 <span class="string">'X'</span>。 任何不在边界上，或不与边界上的 <span class="string">'O'</span> 相连的 <span class="string">'O'</span> 最终都会被填充为 <span class="string">'X'</span>。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：board = [[<span class="string">"X"</span>]]</span><br><span class="line">输出：[[<span class="string">"X"</span>]]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">m == board.length</span><br><span class="line">n == board[i].length</span><br><span class="line"><span class="number">1</span> &lt;= m, n &lt;= <span class="number">200</span></span><br><span class="line">board[i][j] 为 <span class="string">'X'</span> 或 <span class="string">'O'</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># fixme: BFS</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">BFS</span><span class="params">(self,board, row, col)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :param board: List[List]棋盘</span></span><br><span class="line"><span class="string">        :param row: Int 行</span></span><br><span class="line"><span class="string">        :param col: Int 列</span></span><br><span class="line"><span class="string">        :return: Boolean</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        row_limit, col_limit = len(board), len(board[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 检查越界情况</span></span><br><span class="line">        <span class="keyword">if</span> row &lt; <span class="number">0</span> <span class="keyword">or</span> row &gt;= row_limit <span class="keyword">or</span> col &lt; <span class="number">0</span> <span class="keyword">or</span> col &gt;= col_limit:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> board[row][col] == <span class="string">'O'</span>:</span><br><span class="line">            board[row][col] = <span class="string">'#'</span></span><br><span class="line">            <span class="comment"># 上下左右查找</span></span><br><span class="line">            self.BFS(board, row + <span class="number">1</span>, col)</span><br><span class="line">            self.BFS(board, row - <span class="number">1</span>, col)</span><br><span class="line">            self.BFS(board, row, col - <span class="number">1</span>)</span><br><span class="line">            self.BFS(board, row, col + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(self, board)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        考虑BFS，分析可得如果边界存在O的话，则可能会出现不能全部为X的情况，当然也存在边界为O，但是内部全为X的情况</span></span><br><span class="line"><span class="string">        如果边界全为X的话，则必然最终结果全为X</span></span><br><span class="line"><span class="string">        边界上O可到的的O均为不可以变为X的</span></span><br><span class="line"><span class="string">        边界O上不可达的O均为可以变为X的</span></span><br><span class="line"><span class="string">        :type board: List[List[str]]</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify board in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(board) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        dim1,dim2 = len(board),len(board[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 从边界非X的开始查找  边界上O可到的的O均为不可以变为X的</span></span><br><span class="line">        <span class="comment">## 上下边界</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(dim1):</span><br><span class="line">            self.BFS(board, i, <span class="number">0</span>)</span><br><span class="line">            self.BFS(board, i, dim2<span class="number">-1</span>)</span><br><span class="line">        <span class="comment">## 左右边界</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(dim2):</span><br><span class="line">            self.BFS(board, <span class="number">0</span>, j)</span><br><span class="line">            self.BFS(board, dim1<span class="number">-1</span>, j)</span><br><span class="line">        <span class="comment"># 处理所有的# # 表示不可以变为X的</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(dim1):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(dim2):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">'#'</span>:</span><br><span class="line">                    board[i][j] = <span class="string">'O'</span></span><br><span class="line">                <span class="keyword">elif</span> board[i][j] == <span class="string">'O'</span>:</span><br><span class="line">                    board[i][j] = <span class="string">'X'</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    print((s.solve(board = [[<span class="string">"X"</span>,<span class="string">"X"</span>,<span class="string">"X"</span>,<span class="string">"X"</span>],[<span class="string">"X"</span>,<span class="string">"O"</span>,<span class="string">"O"</span>,<span class="string">"X"</span>],[<span class="string">"X"</span>,<span class="string">"X"</span>,<span class="string">"O"</span>,<span class="string">"X"</span>],[<span class="string">"X"</span>,<span class="string">"O"</span>,<span class="string">"X"</span>,<span class="string">"X"</span>]])))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第130题—被围绕的区域&lt;/h1&gt;
&lt;p&gt;恢复正常！！&lt;/p&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎S
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.129</title>
    <link href="www.strivezs.com/2021/06/09/LeetCode%E7%AC%AC129%E9%A2%98/"/>
    <id>www.strivezs.com/2021/06/09/LeetCode%E7%AC%AC129%E9%A2%98/</id>
    <published>2021-06-09T12:43:52.655Z</published>
    <updated>2021-06-09T12:43:52.655Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第129题—求根节点到叶节点数字之和</h1><p>好久没更新了，最近事情太多了，天天忙的要死，英语也没来得及背，后面会慢慢恢复的，同时也会更新一大堆学习到的东西，敬请期待。</p><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。<br>每条从根节点到叶节点的路径都代表一个数字：</p><p>例如，从根节点到叶节点的路径 1 -&gt; 2 -&gt; 3 表示数字 123 。<br>计算从根节点到叶节点生成的 所有数字之和 。</p><p>叶节点 是指没有子节点的节点。</p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/num1tree.jpg" alt="figure.1"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">25</span></span><br><span class="line">解释：</span><br><span class="line">从根到叶子节点路径 <span class="number">1</span>-&gt;<span class="number">2</span> 代表数字 <span class="number">12</span></span><br><span class="line">从根到叶子节点路径 <span class="number">1</span>-&gt;<span class="number">3</span> 代表数字 <span class="number">13</span></span><br><span class="line">因此，数字总和 = <span class="number">12</span> + <span class="number">13</span> = <span class="number">25</span></span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2021/02/19/num2tree.jpg" alt="figure.2"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">2</span>：</span><br><span class="line">输入：root = [<span class="number">4</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">1026</span></span><br><span class="line">解释：</span><br><span class="line">从根到叶子节点路径 <span class="number">4</span>-&gt;<span class="number">9</span>-&gt;<span class="number">5</span> 代表数字 <span class="number">495</span></span><br><span class="line">从根到叶子节点路径 <span class="number">4</span>-&gt;<span class="number">9</span>-&gt;<span class="number">1</span> 代表数字 <span class="number">491</span></span><br><span class="line">从根到叶子节点路径 <span class="number">4</span>-&gt;<span class="number">0</span> 代表数字 <span class="number">40</span></span><br><span class="line">因此，数字总和 = <span class="number">495</span> + <span class="number">491</span> + <span class="number">40</span> = <span class="number">1026</span></span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">树中节点的数目在范围 [<span class="number">1</span>, <span class="number">1000</span>] 内</span><br><span class="line"><span class="number">0</span> &lt;= Node.val &lt;= <span class="number">9</span></span><br><span class="line">树的深度不超过 <span class="number">10</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val=<span class="number">0</span>, left=None, right=None)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, node, curStr)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> node != <span class="literal">None</span>:</span><br><span class="line">            curStr += str(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.right == <span class="literal">None</span> <span class="keyword">and</span> node.left == <span class="literal">None</span>:</span><br><span class="line">                self.sum += int(curStr)</span><br><span class="line">            self.dfs(node.left, curStr)</span><br><span class="line">            self.dfs(node.right, curStr)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumNumbers</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        D FS 强制类型转换并且记录就好了</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.sum =<span class="number">0</span></span><br><span class="line">        self.dfs(root, <span class="string">''</span>)</span><br><span class="line">        <span class="keyword">return</span> self.sum</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    root = TreeNode(<span class="number">1</span>)</span><br><span class="line">    node1 = TreeNode(<span class="number">2</span>)</span><br><span class="line">    node2 = TreeNode(<span class="number">3</span>)</span><br><span class="line">    root.left = node1</span><br><span class="line">    root.right = node2</span><br><span class="line">    print(s.sumNumbers(root))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第129题—求根节点到叶节点数字之和&lt;/h1&gt;
&lt;p&gt;好久没更新了，最近事情太多了，天天忙的要死，英语也没来得及背，后面会慢慢恢复的，同时也会更新一大堆学习到的东西，敬请期待。&lt;/p&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://githu
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.128</title>
    <link href="www.strivezs.com/2021/06/08/LeetCode%E7%AC%AC128%E9%A2%98/"/>
    <id>www.strivezs.com/2021/06/08/LeetCode%E7%AC%AC128%E9%A2%98/</id>
    <published>2021-06-08T15:17:48.827Z</published>
    <updated>2021-06-08T15:17:48.827Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第128题—最长连续序列</h1><p>好久没更新了，最近事情太多了，天天忙的要死，英语也没来得及背，后面会慢慢恢复的，同时也会更新一大堆学习到的东西，敬请期待。</p><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><p>进阶：你可以设计并实现时间复杂度为 O(n) 的解决方案吗？</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">100</span>,<span class="number">4</span>,<span class="number">200</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：最长数字连续序列是 [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]。它的长度为 <span class="number">4</span>。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">9</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> &lt;= nums.length &lt;= <span class="number">104</span></span><br><span class="line"><span class="number">-109</span> &lt;= nums[i] &lt;= <span class="number">109</span></span><br><span class="line"></span><br><span class="line">`</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestConsecutive</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        核心思想:</span></span><br><span class="line"><span class="string">            考虑用字典存储当前长度</span></span><br><span class="line"><span class="string">            dict[a] = b 表示这个每个端点值对应连续区间的长度</span></span><br><span class="line"><span class="string">            键值是顺序从小到大的</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        max_length = <span class="number">0</span></span><br><span class="line">        res_dict = dict()</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment"># 去掉重复情况</span></span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> res_dict.keys():</span><br><span class="line">                <span class="comment"># 找到它的左端值和右端值</span></span><br><span class="line">                left_length = res_dict.get(num<span class="number">-1</span>,<span class="number">0</span>) <span class="comment"># 如果左边值存在则和左边值连续，否则返回0</span></span><br><span class="line">                right_length = res_dict.get(num+<span class="number">1</span>,<span class="number">0</span>) <span class="comment"># 如果右边值存在，则和右边值连续，否则返回0</span></span><br><span class="line">                length = left_length + right_length + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> length &gt; max_length:</span><br><span class="line">                    max_length = length</span><br><span class="line">                <span class="comment"># 更新字典值</span></span><br><span class="line">                res_dict[num] = length</span><br><span class="line">                <span class="comment"># 更新左邻域最大长度(没有的话不更新)</span></span><br><span class="line">                res_dict[num-left_length] = length</span><br><span class="line">                <span class="comment"># 更新有邻域最大长度(如果没有的话，则不更新)</span></span><br><span class="line">                res_dict[num+right_length] = length</span><br><span class="line">        <span class="keyword">return</span> max_length</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第128题—最长连续序列&lt;/h1&gt;
&lt;p&gt;好久没更新了，最近事情太多了，天天忙的要死，英语也没来得及背，后面会慢慢恢复的，同时也会更新一大堆学习到的东西，敬请期待。&lt;/p&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.127</title>
    <link href="www.strivezs.com/2021/06/03/LeetCode%E7%AC%AC127%E9%A2%98/"/>
    <id>www.strivezs.com/2021/06/03/LeetCode%E7%AC%AC127%E9%A2%98/</id>
    <published>2021-06-03T11:56:11.305Z</published>
    <updated>2021-06-03T11:56:11.305Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode第127题—单词接龙"><a href="#LeetCode第127题—单词接龙" class="headerlink" title="LeetCode第127题—单词接龙"></a>LeetCode第127题—单词接龙</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>字典 wordList 中从单词 beginWord 和 endWord 的 转换序列 是一个按下述规格形成的序列：</p><p>序列中第一个单词是 beginWord 。<br>序列中最后一个单词是 endWord 。<br>每次转换只能改变一个字母。<br>转换过程中的中间单词必须是字典 wordList 中的单词。<br>给你两个单词 beginWord 和 endWord 和一个字典 wordList ，找到从 beginWord 到 endWord 的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回 0。</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：<span class="keyword">begin</span>Word = <span class="string">"hit"</span>, <span class="keyword">end</span>Word = <span class="string">"cog"</span>, wordList = [<span class="string">"hot"</span>,<span class="string">"dot"</span>,<span class="string">"dog"</span>,<span class="string">"lot"</span>,<span class="string">"log"</span>,<span class="string">"cog"</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：一个最短转换序列是 <span class="string">"hit"</span> -&gt; <span class="string">"hot"</span> -&gt; <span class="string">"dot"</span> -&gt; <span class="string">"dog"</span> -&gt; <span class="string">"cog"</span>, 返回它的长度 <span class="number">5</span>。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：<span class="keyword">begin</span>Word = <span class="string">"hit"</span>, <span class="keyword">end</span>Word = <span class="string">"cog"</span>, wordList = [<span class="string">"hot"</span>,<span class="string">"dot"</span>,<span class="string">"dog"</span>,<span class="string">"lot"</span>,<span class="string">"log"</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：<span class="keyword">end</span>Word <span class="string">"cog"</span> 不在字典中，所以无法进行转换。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= <span class="keyword">begin</span>Word.length &lt;= <span class="number">10</span></span><br><span class="line"><span class="keyword">end</span>Word.length == <span class="keyword">begin</span>Word.length</span><br><span class="line"><span class="number">1</span> &lt;= wordList.length &lt;= <span class="number">5000</span></span><br><span class="line">wordList[i].length == <span class="keyword">begin</span>Word.length</span><br><span class="line"><span class="keyword">begin</span>Word、<span class="keyword">end</span>Word 和 wordList[i] 由小写英文字母组成</span><br><span class="line"><span class="keyword">begin</span>Word != <span class="keyword">end</span>Word</span><br><span class="line">wordList 中的所有字符串 互不相同</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p><img src="https://gitee.com/zyp521/upload_image/raw/master/OJ.png" alt="figure.1"></p><p>Python使用BFS的话，还是会超时，最长的那个过不去，这里就参考大佬的方法。<br>反正都是小写字母，每次只变动一位，干脆拿到一个节点时生成所有可能的下一个节点，新生成的节点只要再列表中就参与计算。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="使用了邻接矩阵的超时版本"><a href="#使用了邻接矩阵的超时版本" class="headerlink" title="使用了邻接矩阵的超时版本"></a>使用了邻接矩阵的超时版本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">one_chart_different</span><span class="params">(self, str1, str2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        判断输入的两个字符串是不是只有一个不一样, 默认输入的两个字符串长度相同</span></span><br><span class="line"><span class="string">        :param str1: String</span></span><br><span class="line"><span class="string">        :param str2: String</span></span><br><span class="line"><span class="string">        :return: Boolean True/False</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(str1)):</span><br><span class="line">            <span class="keyword">if</span> str1[i] != str2[i]:</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> num &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="comment"># fixme: 使用BFS进行广度优先搜索</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">BFS_memory_search</span><span class="params">(self, start, end_num, adjacent_matrix)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        使用带有记忆的BFS来进行搜索，层数逐渐增加就可以了，直到最先扩展到最终节点就结束</span></span><br><span class="line"><span class="string">        有点类似树扩展的方法,用字典来记录深度</span></span><br><span class="line"><span class="string">        :param start: Int 给点初始节点在邻接矩阵中的下标</span></span><br><span class="line"><span class="string">        :param end_num: 终止节点</span></span><br><span class="line"><span class="string">        :param adjacent_matrix: 邻接矩阵</span></span><br><span class="line"><span class="string">        :return: distance, path 返回距离和路径</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        inf = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="comment"># 初始化操作</span></span><br><span class="line">        depth_dict = &#123;&#125; <span class="comment"># 记忆深度词典</span></span><br><span class="line">        depth_dict[start] = <span class="number">1</span> <span class="comment"># 初始化</span></span><br><span class="line">        quene = [] <span class="comment"># 队列</span></span><br><span class="line">        quene.append(start)</span><br><span class="line">        n = len(adjacent_matrix) <span class="comment"># 节点个数</span></span><br><span class="line">        step = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> len(quene) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> step</span><br><span class="line">            node = quene.pop(<span class="number">0</span>) <span class="comment"># 队首出列</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> adjacent_matrix[node][j] != inf <span class="keyword">and</span> j <span class="keyword">not</span> <span class="keyword">in</span> depth_dict.keys(): <span class="comment"># 证明可以扩展</span></span><br><span class="line">                    quene.append(j) <span class="comment"># 入队</span></span><br><span class="line">                    depth_dict[j] = depth_dict[node] + <span class="number">1</span> <span class="comment"># 深度记录</span></span><br><span class="line">                <span class="keyword">if</span> j == end_num <span class="keyword">and</span> end_num <span class="keyword">in</span> depth_dict.keys():</span><br><span class="line">                    step = depth_dict[j]</span><br><span class="line">                    <span class="keyword">return</span> step</span><br><span class="line">        <span class="keyword">return</span> step</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ladderLength</span><span class="params">(self, beginWord, endWord, wordList)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type beginWord: str</span></span><br><span class="line"><span class="string">        :type endWord: str</span></span><br><span class="line"><span class="string">        :type wordList: List[str]</span></span><br><span class="line"><span class="string">        :rtype: List[List[str]]</span></span><br><span class="line"><span class="string">        根据给定的字典list构造一个图，考虑使用邻接矩阵构建一个图</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        inf = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">if</span> endWord <span class="keyword">not</span> <span class="keyword">in</span> wordList:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> beginWord <span class="keyword">not</span> <span class="keyword">in</span> wordList:</span><br><span class="line">            nodeList = [beginWord] + wordList  <span class="comment"># 构造所有节点列表</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            nodeList = wordList</span><br><span class="line">            nodeList.remove(nodeList[nodeList.index(beginWord)])</span><br><span class="line">            nodeList = [beginWord] + wordList <span class="comment"># 将初始节点至为第一个</span></span><br><span class="line">        numList = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nodeList))] <span class="comment"># 构造每个节点对应的数字状态</span></span><br><span class="line">        node_num_dict = dict(zip(nodeList,numList)) <span class="comment"># 构建对应关系的字典</span></span><br><span class="line">        num_node_dict = dict(zip(numList,nodeList)) <span class="comment"># 构造反向对应关系</span></span><br><span class="line">        adjacent_matrix = [[inf <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(nodeList))] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(nodeList))] <span class="comment"># 邻接矩阵</span></span><br><span class="line">        <span class="comment"># 构建邻接矩阵</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nodeList:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> nodeList:</span><br><span class="line">                <span class="keyword">if</span> i != j:</span><br><span class="line">                    <span class="keyword">if</span> len(i) == len(j):</span><br><span class="line">                        <span class="keyword">if</span> self.one_chart_different(i,j):</span><br><span class="line">                            adjacent_matrix[node_num_dict[i]][node_num_dict[j]] = <span class="number">1</span></span><br><span class="line">                            adjacent_matrix[node_num_dict[j]][node_num_dict[i]] = <span class="number">1</span></span><br><span class="line">        step = self.BFS_memory_search(<span class="number">0</span>,nodeList.index(endWord),adjacent_matrix)</span><br><span class="line">        <span class="keyword">if</span> step == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> step</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.ladderLength(beginWord = <span class="string">"talk"</span>, endWord = <span class="string">"tail"</span>, wordList = [<span class="string">"talk"</span>,<span class="string">"tons"</span>,<span class="string">"fall"</span>,<span class="string">"tail"</span>,<span class="string">"gale"</span>,<span class="string">"hall"</span>,<span class="string">"negs"</span>]))</span><br></pre></td></tr></table></figure><h3 id="去掉邻接矩阵直接判断的版本"><a href="#去掉邻接矩阵直接判断的版本" class="headerlink" title="去掉邻接矩阵直接判断的版本"></a>去掉邻接矩阵直接判断的版本</h3><p>别人没超时，我用Python又又超时了，我爆哭.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">one_chart_different</span><span class="params">(self, str1, str2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        判断输入的两个字符串是不是只有一个不一样, 默认输入的两个字符串长度相同</span></span><br><span class="line"><span class="string">        :param str1: String</span></span><br><span class="line"><span class="string">        :param str2: String</span></span><br><span class="line"><span class="string">        :return: Boolean True/False</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(str1)):</span><br><span class="line">            <span class="keyword">if</span> str1[i] != str2[i]:</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> num &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new_version</span><span class="params">(self, beginWord, endWord, wordList)</span>:</span></span><br><span class="line">        quene = []</span><br><span class="line">        quene.append(beginWord)</span><br><span class="line">        step = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> len(quene) != <span class="number">0</span>:</span><br><span class="line">            step += <span class="number">1</span></span><br><span class="line">            sz = len(quene)</span><br><span class="line">            <span class="keyword">while</span> sz &gt; <span class="number">0</span>:</span><br><span class="line">                hope = quene.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> hope == endWord:</span><br><span class="line">                    <span class="keyword">return</span> step</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 对每个word进行判断</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(len(wordList)):</span><br><span class="line">                    <span class="keyword">if</span> len(wordList[i]) == <span class="number">0</span> <span class="keyword">or</span> len(wordList[i]) != len(beginWord):</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="comment"># 判断差异性</span></span><br><span class="line">                    <span class="keyword">if</span> self.one_chart_different(hope,wordList[i]):</span><br><span class="line">                        quene.append(wordList[i])</span><br><span class="line">                        wordList[i] = <span class="string">""</span></span><br><span class="line">                sz -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.new_version(beginWord = <span class="string">"hit"</span>, endWord = <span class="string">"cog"</span>, wordList = [<span class="string">"hot"</span>,<span class="string">"dot"</span>,<span class="string">"dog"</span>,<span class="string">"lot"</span>,<span class="string">"log"</span>]))</span><br></pre></td></tr></table></figure></p><h3 id="参考大佬的版本"><a href="#参考大佬的版本" class="headerlink" title="参考大佬的版本"></a>参考大佬的版本</h3><p>反正都是小写字母，每次只变动一位，干脆拿到一个节点时生成所有可能的下一个节点，新生成的节点只要再列表中就参与计算。</p><p>这次终于通过了，不过耗时几百毫秒。<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">def ladderLength(self, beginWord: str, endWord: str, wordLis<span class="variable">t:</span> List[str]) -&gt; in<span class="variable">t:</span></span><br><span class="line">        <span class="keyword">if</span> endWord not in wordLis<span class="variable">t:</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">l</span> = <span class="built_in">len</span>(endWord)</span><br><span class="line">        </span><br><span class="line">            </span><br><span class="line">        <span class="keyword">ws</span> = <span class="keyword">set</span>(wordList)</span><br><span class="line">        </span><br><span class="line">        head = &#123;beginWord&#125;</span><br><span class="line">        tail = &#123;endWord&#125;</span><br><span class="line">        tmp = <span class="keyword">list</span>(<span class="string">'abcdefghijklmnopqrstuvwxyz'</span>)</span><br><span class="line">        <span class="keyword">res</span> = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(head) &gt; <span class="built_in">len</span>(tail):</span><br><span class="line">                head, tail = tail, head</span><br><span class="line">            </span><br><span class="line">            q = <span class="keyword">set</span>()</span><br><span class="line">            <span class="keyword">for</span> cur in head:</span><br><span class="line">                <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="keyword">l</span>):</span><br><span class="line">                    <span class="keyword">for</span> <span class="keyword">j</span> in tmp:</span><br><span class="line">                        word = cur[:i] + <span class="keyword">j</span> + cur[i+<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> word in tai<span class="variable">l:</span></span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">res</span> + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> word in <span class="keyword">w</span><span class="variable">s:</span></span><br><span class="line">                            q.<span class="built_in">add</span>(word)</span><br><span class="line">                            <span class="keyword">ws</span>.<span class="built_in">remove</span>(word)</span><br><span class="line">            head = q</span><br><span class="line">            <span class="keyword">res</span> += <span class="number">1</span></span><br><span class="line">                    </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LeetCode第127题—单词接龙&quot;&gt;&lt;a href=&quot;#LeetCode第127题—单词接龙&quot; class=&quot;headerlink&quot; title=&quot;LeetCode第127题—单词接龙&quot;&gt;&lt;/a&gt;LeetCode第127题—单词接龙&lt;/h1&gt;&lt;p&gt;自己代码的开
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.126</title>
    <link href="www.strivezs.com/2021/06/02/LeetCode%E7%AC%AC126%E9%A2%98/"/>
    <id>www.strivezs.com/2021/06/02/LeetCode%E7%AC%AC126%E9%A2%98/</id>
    <published>2021-06-02T08:57:37.483Z</published>
    <updated>2021-06-02T08:57:37.483Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode第126题—单词接龙II"><a href="#LeetCode第126题—单词接龙II" class="headerlink" title="LeetCode第126题—单词接龙II"></a>LeetCode第126题—单词接龙II</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>按字典 wordList 完成从单词 beginWord 到单词 endWord 转化，一个表示此过程的 转换序列 是形式上像 beginWord -&gt; s1 -&gt; s2 -&gt; … -&gt; sk 这样的单词序列，并满足：</p><p>每对相邻的单词之间仅有单个字母不同。<br>转换过程中的每个单词 si（1 &lt;= i &lt;= k）必须是字典 wordList 中的单词。注意，beginWord 不必是字典 wordList 中的单词。<br>sk == endWord<br>给你两个单词 beginWord 和 endWord ，以及一个字典 wordList 。请你找出并返回所有从 beginWord 到 endWord 的 最短转换序列 ，如果不存在这样的转换序列，返回一个空列表。每个序列都应该以单词列表 [beginWord, s1, s2, …, sk] 的形式返回。</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：<span class="keyword">begin</span>Word = <span class="string">"hit"</span>, <span class="keyword">end</span>Word = <span class="string">"cog"</span>, wordList = [<span class="string">"hot"</span>,<span class="string">"dot"</span>,<span class="string">"dog"</span>,<span class="string">"lot"</span>,<span class="string">"log"</span>,<span class="string">"cog"</span>]</span><br><span class="line">输出：[[<span class="string">"hit"</span>,<span class="string">"hot"</span>,<span class="string">"dot"</span>,<span class="string">"dog"</span>,<span class="string">"cog"</span>],[<span class="string">"hit"</span>,<span class="string">"hot"</span>,<span class="string">"lot"</span>,<span class="string">"log"</span>,<span class="string">"cog"</span>]]</span><br><span class="line">解释：存在 <span class="number">2</span> 种最短的转换序列：</span><br><span class="line"><span class="string">"hit"</span> -&gt; <span class="string">"hot"</span> -&gt; <span class="string">"dot"</span> -&gt; <span class="string">"dog"</span> -&gt; <span class="string">"cog"</span></span><br><span class="line"><span class="string">"hit"</span> -&gt; <span class="string">"hot"</span> -&gt; <span class="string">"lot"</span> -&gt; <span class="string">"log"</span> -&gt; <span class="string">"cog"</span></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：<span class="keyword">begin</span>Word = <span class="string">"hit"</span>, <span class="keyword">end</span>Word = <span class="string">"cog"</span>, wordList = [<span class="string">"hot"</span>,<span class="string">"dot"</span>,<span class="string">"dog"</span>,<span class="string">"lot"</span>,<span class="string">"log"</span>]</span><br><span class="line">输出：[]</span><br><span class="line">解释：<span class="keyword">end</span>Word <span class="string">"cog"</span> 不在字典 wordList 中，所以不存在符合要求的转换序列。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= <span class="keyword">begin</span>Word.length &lt;= <span class="number">7</span></span><br><span class="line"><span class="keyword">end</span>Word.length == <span class="keyword">begin</span>Word.length</span><br><span class="line"><span class="number">1</span> &lt;= wordList.length &lt;= <span class="number">5000</span></span><br><span class="line">wordList[i].length == <span class="keyword">begin</span>Word.length</span><br><span class="line"><span class="keyword">begin</span>Word、<span class="keyword">end</span>Word 和 wordList[i] 由小写英文字母组成</span><br><span class="line"><span class="keyword">begin</span>Word != <span class="keyword">end</span>Word</span><br><span class="line">wordList 中的所有单词 互不相同</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p><img src="https://gitee.com/zyp521/upload_image/raw/master/IMG_0713.PNG" alt="figure.1"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>回溯法做的. 不知道为什么，我写的代码，一个测试用例提交报错，我同样在本地测试一点问题都没有。不知道啥情况了，代码整体思想没有问题。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def one_chart_different(self, str1, str2):</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        判断输入的两个字符串是不是只有一个不一样, 默认输入的两个字符串长度相同</span><br><span class="line">        :param str1: String</span><br><span class="line">        :param str2: String</span><br><span class="line">        :<span class="keyword">return</span>: Boolean True/False</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="built_in">len</span>(str1)):</span><br><span class="line">            <span class="keyword">if</span> str1[i] != str2[i]:</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> num &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> False</span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> False</span><br><span class="line">        <span class="keyword">return</span> True</span><br><span class="line">    # fixme: BFS深度度优先搜索寻找最短路径 实质上就是暴力搜索  回溯法</span><br><span class="line">    res_path = dict()</span><br><span class="line">    min_dist = float(<span class="string">'inf'</span>)</span><br><span class="line">    def BFS_Search(self, start, ends, path, visited, adjacent_matrix):</span><br><span class="line">        inf = float(<span class="string">'inf'</span>)</span><br><span class="line">        # 如果满足则存储路径和距离</span><br><span class="line">        <span class="keyword">if</span> start == end<span class="variable">s:</span></span><br><span class="line">            path_node = path.<span class="keyword">split</span>(<span class="string">','</span>)</span><br><span class="line">            distance = <span class="built_in">len</span>(path_node)</span><br><span class="line">            <span class="keyword">if</span> distance &lt; self.min_dis<span class="variable">t:</span></span><br><span class="line">                self.min_dist = distance</span><br><span class="line">            <span class="keyword">if</span> path not in self.res_path.<span class="built_in">keys</span>():</span><br><span class="line">                self.res_path[path] = distance</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        n = <span class="built_in">len</span>(adjacent_matrix)</span><br><span class="line">        <span class="keyword">for</span> i in <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> adjacent_matrix[start][i] != inf <span class="built_in">and</span> not visited[i]:</span><br><span class="line">                t = path</span><br><span class="line">                path = path + <span class="string">','</span> + str(i)</span><br><span class="line">                visited[i] = True</span><br><span class="line">                self.BFS_Search(i, ends, path, visited, adjacent_matrix)</span><br><span class="line">                path = t</span><br><span class="line">                visited[i] = False</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def findLadders(self, beginWord, endWord, wordList):</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        :<span class="built_in">type</span> beginWord: str</span><br><span class="line">        :<span class="built_in">type</span> endWord: str</span><br><span class="line">        :<span class="built_in">type</span> wordLis<span class="variable">t:</span> List[str]</span><br><span class="line">        :rtype: List[List[str]]</span><br><span class="line">        根据给定的字典<span class="keyword">list</span>构造一个图，考虑使用邻接矩阵构建一个图</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        inf = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">if</span> endWord not in wordLis<span class="variable">t:</span></span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> beginWord not in wordLis<span class="variable">t:</span></span><br><span class="line">            nodeList = [beginWord] + wordList  # 构造所有节点列表</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            nodeList = wordList</span><br><span class="line">        numList = [i <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="built_in">len</span>(nodeList))] # 构造每个节点对应的数字状态</span><br><span class="line">        node_num_dict = dict(zip(nodeList,numList)) # 构建对应关系的字典</span><br><span class="line">        num_node_dict = dict(zip(numList,nodeList)) # 构造反向对应关系</span><br><span class="line">        adjacent_matrix = [[inf <span class="keyword">for</span> _ in <span class="built_in">range</span>(<span class="built_in">len</span>(nodeList))] <span class="keyword">for</span> _ in <span class="built_in">range</span>(<span class="built_in">len</span>(nodeList))] # 邻接矩阵</span><br><span class="line">        # 构建邻接矩阵</span><br><span class="line">        <span class="keyword">for</span> i in nodeLis<span class="variable">t:</span></span><br><span class="line">            <span class="keyword">for</span> <span class="keyword">j</span> in nodeLis<span class="variable">t:</span></span><br><span class="line">                <span class="keyword">if</span> i != <span class="keyword">j</span>:</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">len</span>(i) == <span class="built_in">len</span>(<span class="keyword">j</span>):</span><br><span class="line">                        <span class="keyword">if</span> self.one_chart_different(i,<span class="keyword">j</span>):</span><br><span class="line">                            adjacent_matrix[node_num_dict[i]][node_num_dict[<span class="keyword">j</span>]] = <span class="number">1</span></span><br><span class="line">                            adjacent_matrix[node_num_dict[<span class="keyword">j</span>]][node_num_dict[i]] = <span class="number">1</span></span><br><span class="line">        # 使用BFS回溯法搜索</span><br><span class="line">        visited = [False] * <span class="built_in">len</span>(adjacent_matrix)</span><br><span class="line">        visited[<span class="number">0</span>] = True</span><br><span class="line">        self.BFS_Search(nodeList.<span class="built_in">index</span>(beginWord),nodeList.<span class="built_in">index</span>(endWord),str(nodeList.<span class="built_in">index</span>(beginWord)),visited,adjacent_matrix)</span><br><span class="line">        <span class="keyword">res</span> = []</span><br><span class="line">        <span class="keyword">for</span> item in self.res_path.<span class="built_in">keys</span>():</span><br><span class="line">            <span class="keyword">if</span> self.res_path[item] == self.min_dis<span class="variable">t:</span></span><br><span class="line">                temp = []</span><br><span class="line">                path = item.<span class="keyword">split</span>(<span class="string">','</span>)</span><br><span class="line">                <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="built_in">len</span>(path)):</span><br><span class="line">                    temp.<span class="keyword">append</span>(num_node_dict[<span class="keyword">int</span>(path[i])])</span><br><span class="line">                <span class="keyword">res</span>.<span class="keyword">append</span>(temp)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">res</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    <span class="keyword">print</span>(s.findLadders(beginWord = <span class="string">"hot"</span>, endWord = <span class="string">"dog"</span>, wordList = [<span class="string">"hot"</span>,<span class="string">"dog"</span>,<span class="string">"dot"</span>]))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LeetCode第126题—单词接龙II&quot;&gt;&lt;a href=&quot;#LeetCode第126题—单词接龙II&quot; class=&quot;headerlink&quot; title=&quot;LeetCode第126题—单词接龙II&quot;&gt;&lt;/a&gt;LeetCode第126题—单词接龙II&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 基于邻接矩阵的Dijkstra算法</title>
    <link href="www.strivezs.com/2021/06/02/%E5%9F%BA%E4%BA%8E%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E7%9A%84Dijkstra%E7%AE%97%E6%B3%95/"/>
    <id>www.strivezs.com/2021/06/02/%E5%9F%BA%E4%BA%8E%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E7%9A%84Dijkstra%E7%AE%97%E6%B3%95/</id>
    <published>2021-06-02T08:52:14.412Z</published>
    <updated>2021-06-02T08:52:14.412Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于邻接矩阵的Dijkstra算法"><a href="#基于邻接矩阵的Dijkstra算法" class="headerlink" title="基于邻接矩阵的Dijkstra算法"></a>基于邻接矩阵的Dijkstra算法</h1><p>如果你的图不是邻接矩阵，转换成矩阵的形式就可以了。这里节点我就是用index表示的。  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">fixme:</span> Dijkstra算法寻找最短路径，从给定初始点到每个节点的最短路径</span></span><br><span class="line">    def Dijkstra(self, <span class="keyword">start</span>, adjacent_matrix):</span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :param start: Int 给点初始节点在邻接矩阵中的下标</span></span><br><span class="line"><span class="string">        :param adjacent_matrix: 邻接矩阵</span></span><br><span class="line"><span class="string">        :return: distance, path 返回到每个节点的最短距离，返回路径</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 初始化操作</span></span><br><span class="line">        n = <span class="keyword">len</span>(adjacent_matrix) <span class="comment"># 节点个数</span></span><br><span class="line">        inf = <span class="built_in">float</span>(<span class="string">'inf'</span>)</span><br><span class="line">        distance = [inf] * n <span class="comment"># 用于存放从某个点到其他点的最短路径长度</span></span><br><span class="line">        <span class="keyword">path</span> = [<span class="keyword">None</span>] * n <span class="comment"># 用于存放从初始点到其他点的路径</span></span><br><span class="line">        <span class="keyword">final</span> = [<span class="keyword">None</span>] * n <span class="comment"># 用于存放从初始点到其他点的最短路径</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">range</span>(n):</span><br><span class="line">            <span class="keyword">final</span>[i] = <span class="literal">False</span></span><br><span class="line">            distance[i] = adjacent_matrix[<span class="keyword">start</span>][i]</span><br><span class="line">            <span class="keyword">path</span>[i] = <span class="string">""</span>  <span class="comment"># 路径置空</span></span><br><span class="line">            <span class="keyword">if</span> distance[i] &lt; inf:</span><br><span class="line">                <span class="keyword">path</span>[i] = <span class="keyword">str</span>(i)</span><br><span class="line">        distance[<span class="keyword">start</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">final</span>[<span class="keyword">start</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 算法</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">min</span> = inf</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="keyword">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">final</span>[k] <span class="keyword">and</span> distance[k] &lt; <span class="keyword">min</span>:</span><br><span class="line">                    v = k</span><br><span class="line">                    <span class="keyword">min</span> = distance[k]</span><br><span class="line">            <span class="keyword">final</span>[v] = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="keyword">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">final</span>[k] <span class="keyword">and</span> <span class="keyword">min</span> + adjacent_matrix[v][k] &lt; distance[k]:</span><br><span class="line">                    distance[k] = <span class="keyword">min</span> + adjacent_matrix[v][k]</span><br><span class="line">                    <span class="keyword">path</span>[k] = <span class="keyword">path</span>[v] + <span class="string">','</span> + <span class="keyword">str</span>(k)</span><br><span class="line">        <span class="keyword">return</span> distance, <span class="keyword">path</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基于邻接矩阵的Dijkstra算法&quot;&gt;&lt;a href=&quot;#基于邻接矩阵的Dijkstra算法&quot; class=&quot;headerlink&quot; title=&quot;基于邻接矩阵的Dijkstra算法&quot;&gt;&lt;/a&gt;基于邻接矩阵的Dijkstra算法&lt;/h1&gt;&lt;p&gt;如果你的图不是邻接矩
      
    
    </summary>
    
    
      <category term="算法" scheme="www.strivezs.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="算法" scheme="www.strivezs.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图" scheme="www.strivezs.com/tags/%E5%9B%BE/"/>
    
      <category term="最短路径" scheme="www.strivezs.com/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    
      <category term="Dijkstra" scheme="www.strivezs.com/tags/Dijkstra/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.125</title>
    <link href="www.strivezs.com/2021/06/01/LeetCode%E7%AC%AC125%E9%A2%98/"/>
    <id>www.strivezs.com/2021/06/01/LeetCode%E7%AC%AC125%E9%A2%98/</id>
    <published>2021-06-01T11:17:18.841Z</published>
    <updated>2021-06-01T11:17:18.841Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode第125题—验证回文串"><a href="#LeetCode第125题—验证回文串" class="headerlink" title="LeetCode第125题—验证回文串"></a>LeetCode第125题—验证回文串</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p><p>说明：本题中，我们将空字符串定义为有效的回文串。<br><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: <span class="comment">"A man, a plan, a canal: Panama"</span></span><br><span class="line">输出: <span class="keyword">true</span></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: <span class="comment">"race a car"</span></span><br><span class="line">输出: <span class="keyword">false</span></span><br></pre></td></tr></table></figure></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>执行用时：88 ms, 在所有 Python3 提交中击败了7.76%的用户内存消耗：14.9 MB, 在所有 Python3 提交中击败了96.98%的用户<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">judeRange</span><span class="params">(self, c)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> c &gt;= <span class="string">'a'</span> <span class="keyword">and</span> c &lt;= <span class="string">'z'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> c &gt;= <span class="string">'A'</span> <span class="keyword">and</span> c &lt;= <span class="string">'Z'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> c &gt;=<span class="string">'0'</span> <span class="keyword">and</span> c &lt;= <span class="string">'9'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        核心思想:</span></span><br><span class="line"><span class="string">            双向指针，自动去除出字母和数字之外的字符串</span></span><br><span class="line"><span class="string">            统一将字母转换为小写</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        ends = len(s)<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> start &lt; ends:</span><br><span class="line">            flag1 = self.judeRange(s[start])</span><br><span class="line">            flag2 = self.judeRange(s[ends])</span><br><span class="line">            <span class="keyword">if</span> flag1 <span class="keyword">and</span> flag2:</span><br><span class="line">                s1 = s[start].lower()</span><br><span class="line">                s2 = s[ends].lower()</span><br><span class="line">                <span class="keyword">if</span> s1 != s2:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">                ends -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> flag1 <span class="keyword">and</span> ~flag2:</span><br><span class="line">                ends -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> ~flag1 <span class="keyword">and</span> flag2:</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">                ends -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LeetCode第125题—验证回文串&quot;&gt;&lt;a href=&quot;#LeetCode第125题—验证回文串&quot; class=&quot;headerlink&quot; title=&quot;LeetCode第125题—验证回文串&quot;&gt;&lt;/a&gt;LeetCode第125题—验证回文串&lt;/h1&gt;&lt;p&gt;自己
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.123=4</title>
    <link href="www.strivezs.com/2021/05/31/LeetCode%E7%AC%AC124%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/31/LeetCode%E7%AC%AC124%E9%A2%98/</id>
    <published>2021-05-31T14:43:30.630Z</published>
    <updated>2021-05-31T14:43:30.630Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode第123题—买卖股票的最佳时机III"><a href="#LeetCode第123题—买卖股票的最佳时机III" class="headerlink" title="LeetCode第123题—买卖股票的最佳时机III"></a>LeetCode第123题—买卖股票的最佳时机III</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</p><p>路径和 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点 root ，返回其 最大路径和 。</p><p><img src="https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg" alt="figure.1"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：最优路径是 <span class="number">2</span> -&gt; <span class="number">1</span> -&gt; <span class="number">3</span> ，路径和为 <span class="number">2</span> + <span class="number">1</span> + <span class="number">3</span> = <span class="number">6</span></span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg" alt="figure.2"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">-10</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">42</span></span><br><span class="line">解释：最优路径是 <span class="number">15</span> -&gt; <span class="number">20</span> -&gt; <span class="number">7</span> ，路径和为 <span class="number">15</span> + <span class="number">20</span> + <span class="number">7</span> = <span class="number">42</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">树中节点数目范围是 [<span class="number">1</span>, <span class="number">3</span> * <span class="number">104</span>]</span><br><span class="line"><span class="number">-1000</span> &lt;= Node.val &lt;= <span class="number">1000</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, val=<span class="number">0</span>, left=None, right=None)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.val = val</span><br><span class="line">        <span class="keyword">self</span>.left = left</span><br><span class="line">        <span class="keyword">self</span>.right = right</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="title">object</span>):</span></span><br><span class="line">    max_sum = -sys.maxsize</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs_statistic_path</span><span class="params">(<span class="keyword">self</span>, root)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="symbol">None:</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left_sum = max(<span class="number">0</span>, <span class="keyword">self</span>.dfs_statistic_path(root.left)) <span class="comment"># 统计左子树的路径总和</span></span><br><span class="line">        right_sum = max(<span class="number">0</span>, <span class="keyword">self</span>.dfs_statistic_path(root.right)) <span class="comment"># 统计右子树的路径总和</span></span><br><span class="line">        temp = left_sum + root.val + right_sum <span class="comment"># 统计当前路径总和</span></span><br><span class="line">        <span class="keyword">self</span>.max_sum = max(<span class="keyword">self</span>.max_sum, temp) <span class="comment"># 和当前最大路径进行比较</span></span><br><span class="line">        <span class="keyword">return</span> max(left_sum,right_sum) + root.val <span class="comment"># 由于不能够返回(节点不能够重复)，因此只能选择出最大的一个子树再加上当前根节点值来返回</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxPathSum</span><span class="params">(<span class="keyword">self</span>, root)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        整体上是分而治之的思想，看成一个个子问题</span></span><br><span class="line"><span class="string">        将每个节点看成是它子树的路径和(左子树和右子树)+他本来的值</span></span><br><span class="line"><span class="string">        只有子路径和大于0的时候才会去统计它</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        <span class="keyword">self</span>.dfs_statistic_path(root)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.max_sum</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name_<span class="number">_</span> == <span class="string">'__main__'</span><span class="symbol">:</span></span><br><span class="line">    root = TreeNode(<span class="number">1</span>)</span><br><span class="line">    node1 = TreeNode(<span class="number">2</span>)</span><br><span class="line">    node2 = TreeNode(<span class="number">3</span>)</span><br><span class="line">    root.left = node1</span><br><span class="line">    root.right = node2</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.maxPathSum(root))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LeetCode第123题—买卖股票的最佳时机III&quot;&gt;&lt;a href=&quot;#LeetCode第123题—买卖股票的最佳时机III&quot; class=&quot;headerlink&quot; title=&quot;LeetCode第123题—买卖股票的最佳时机III&quot;&gt;&lt;/a&gt;LeetCode
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
</feed>
