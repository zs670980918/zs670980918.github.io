<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>StriveZs的博客</title>
  
  <subtitle>Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="www.strivezs.com/"/>
  <updated>2021-06-03T11:56:11.305Z</updated>
  <id>www.strivezs.com/</id>
  
  <author>
    <name>StriveZs</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode No.127</title>
    <link href="www.strivezs.com/2021/06/03/LeetCode%E7%AC%AC127%E9%A2%98/"/>
    <id>www.strivezs.com/2021/06/03/LeetCode%E7%AC%AC127%E9%A2%98/</id>
    <published>2021-06-03T11:56:11.305Z</published>
    <updated>2021-06-03T11:56:11.305Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode第127题—单词接龙"><a href="#LeetCode第127题—单词接龙" class="headerlink" title="LeetCode第127题—单词接龙"></a>LeetCode第127题—单词接龙</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>字典 wordList 中从单词 beginWord 和 endWord 的 转换序列 是一个按下述规格形成的序列：</p><p>序列中第一个单词是 beginWord 。<br>序列中最后一个单词是 endWord 。<br>每次转换只能改变一个字母。<br>转换过程中的中间单词必须是字典 wordList 中的单词。<br>给你两个单词 beginWord 和 endWord 和一个字典 wordList ，找到从 beginWord 到 endWord 的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回 0。</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：<span class="keyword">begin</span>Word = <span class="string">"hit"</span>, <span class="keyword">end</span>Word = <span class="string">"cog"</span>, wordList = [<span class="string">"hot"</span>,<span class="string">"dot"</span>,<span class="string">"dog"</span>,<span class="string">"lot"</span>,<span class="string">"log"</span>,<span class="string">"cog"</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：一个最短转换序列是 <span class="string">"hit"</span> -&gt; <span class="string">"hot"</span> -&gt; <span class="string">"dot"</span> -&gt; <span class="string">"dog"</span> -&gt; <span class="string">"cog"</span>, 返回它的长度 <span class="number">5</span>。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：<span class="keyword">begin</span>Word = <span class="string">"hit"</span>, <span class="keyword">end</span>Word = <span class="string">"cog"</span>, wordList = [<span class="string">"hot"</span>,<span class="string">"dot"</span>,<span class="string">"dog"</span>,<span class="string">"lot"</span>,<span class="string">"log"</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：<span class="keyword">end</span>Word <span class="string">"cog"</span> 不在字典中，所以无法进行转换。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= <span class="keyword">begin</span>Word.length &lt;= <span class="number">10</span></span><br><span class="line"><span class="keyword">end</span>Word.length == <span class="keyword">begin</span>Word.length</span><br><span class="line"><span class="number">1</span> &lt;= wordList.length &lt;= <span class="number">5000</span></span><br><span class="line">wordList[i].length == <span class="keyword">begin</span>Word.length</span><br><span class="line"><span class="keyword">begin</span>Word、<span class="keyword">end</span>Word 和 wordList[i] 由小写英文字母组成</span><br><span class="line"><span class="keyword">begin</span>Word != <span class="keyword">end</span>Word</span><br><span class="line">wordList 中的所有字符串 互不相同</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p><img src="https://gitee.com/zyp521/upload_image/raw/master/OJ.png" alt="figure.1"></p><p>Python使用BFS的话，还是会超时，最长的那个过不去，这里就参考大佬的方法。<br>反正都是小写字母，每次只变动一位，干脆拿到一个节点时生成所有可能的下一个节点，新生成的节点只要再列表中就参与计算。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="使用了邻接矩阵的超时版本"><a href="#使用了邻接矩阵的超时版本" class="headerlink" title="使用了邻接矩阵的超时版本"></a>使用了邻接矩阵的超时版本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">one_chart_different</span><span class="params">(self, str1, str2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        判断输入的两个字符串是不是只有一个不一样, 默认输入的两个字符串长度相同</span></span><br><span class="line"><span class="string">        :param str1: String</span></span><br><span class="line"><span class="string">        :param str2: String</span></span><br><span class="line"><span class="string">        :return: Boolean True/False</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(str1)):</span><br><span class="line">            <span class="keyword">if</span> str1[i] != str2[i]:</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> num &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="comment"># fixme: 使用BFS进行广度优先搜索</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">BFS_memory_search</span><span class="params">(self, start, end_num, adjacent_matrix)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        使用带有记忆的BFS来进行搜索，层数逐渐增加就可以了，直到最先扩展到最终节点就结束</span></span><br><span class="line"><span class="string">        有点类似树扩展的方法,用字典来记录深度</span></span><br><span class="line"><span class="string">        :param start: Int 给点初始节点在邻接矩阵中的下标</span></span><br><span class="line"><span class="string">        :param end_num: 终止节点</span></span><br><span class="line"><span class="string">        :param adjacent_matrix: 邻接矩阵</span></span><br><span class="line"><span class="string">        :return: distance, path 返回距离和路径</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        inf = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="comment"># 初始化操作</span></span><br><span class="line">        depth_dict = &#123;&#125; <span class="comment"># 记忆深度词典</span></span><br><span class="line">        depth_dict[start] = <span class="number">1</span> <span class="comment"># 初始化</span></span><br><span class="line">        quene = [] <span class="comment"># 队列</span></span><br><span class="line">        quene.append(start)</span><br><span class="line">        n = len(adjacent_matrix) <span class="comment"># 节点个数</span></span><br><span class="line">        step = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> len(quene) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> step</span><br><span class="line">            node = quene.pop(<span class="number">0</span>) <span class="comment"># 队首出列</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> adjacent_matrix[node][j] != inf <span class="keyword">and</span> j <span class="keyword">not</span> <span class="keyword">in</span> depth_dict.keys(): <span class="comment"># 证明可以扩展</span></span><br><span class="line">                    quene.append(j) <span class="comment"># 入队</span></span><br><span class="line">                    depth_dict[j] = depth_dict[node] + <span class="number">1</span> <span class="comment"># 深度记录</span></span><br><span class="line">                <span class="keyword">if</span> j == end_num <span class="keyword">and</span> end_num <span class="keyword">in</span> depth_dict.keys():</span><br><span class="line">                    step = depth_dict[j]</span><br><span class="line">                    <span class="keyword">return</span> step</span><br><span class="line">        <span class="keyword">return</span> step</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ladderLength</span><span class="params">(self, beginWord, endWord, wordList)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type beginWord: str</span></span><br><span class="line"><span class="string">        :type endWord: str</span></span><br><span class="line"><span class="string">        :type wordList: List[str]</span></span><br><span class="line"><span class="string">        :rtype: List[List[str]]</span></span><br><span class="line"><span class="string">        根据给定的字典list构造一个图，考虑使用邻接矩阵构建一个图</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        inf = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">if</span> endWord <span class="keyword">not</span> <span class="keyword">in</span> wordList:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> beginWord <span class="keyword">not</span> <span class="keyword">in</span> wordList:</span><br><span class="line">            nodeList = [beginWord] + wordList  <span class="comment"># 构造所有节点列表</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            nodeList = wordList</span><br><span class="line">            nodeList.remove(nodeList[nodeList.index(beginWord)])</span><br><span class="line">            nodeList = [beginWord] + wordList <span class="comment"># 将初始节点至为第一个</span></span><br><span class="line">        numList = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nodeList))] <span class="comment"># 构造每个节点对应的数字状态</span></span><br><span class="line">        node_num_dict = dict(zip(nodeList,numList)) <span class="comment"># 构建对应关系的字典</span></span><br><span class="line">        num_node_dict = dict(zip(numList,nodeList)) <span class="comment"># 构造反向对应关系</span></span><br><span class="line">        adjacent_matrix = [[inf <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(nodeList))] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(nodeList))] <span class="comment"># 邻接矩阵</span></span><br><span class="line">        <span class="comment"># 构建邻接矩阵</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nodeList:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> nodeList:</span><br><span class="line">                <span class="keyword">if</span> i != j:</span><br><span class="line">                    <span class="keyword">if</span> len(i) == len(j):</span><br><span class="line">                        <span class="keyword">if</span> self.one_chart_different(i,j):</span><br><span class="line">                            adjacent_matrix[node_num_dict[i]][node_num_dict[j]] = <span class="number">1</span></span><br><span class="line">                            adjacent_matrix[node_num_dict[j]][node_num_dict[i]] = <span class="number">1</span></span><br><span class="line">        step = self.BFS_memory_search(<span class="number">0</span>,nodeList.index(endWord),adjacent_matrix)</span><br><span class="line">        <span class="keyword">if</span> step == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> step</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.ladderLength(beginWord = <span class="string">"talk"</span>, endWord = <span class="string">"tail"</span>, wordList = [<span class="string">"talk"</span>,<span class="string">"tons"</span>,<span class="string">"fall"</span>,<span class="string">"tail"</span>,<span class="string">"gale"</span>,<span class="string">"hall"</span>,<span class="string">"negs"</span>]))</span><br></pre></td></tr></table></figure><h3 id="去掉邻接矩阵直接判断的版本"><a href="#去掉邻接矩阵直接判断的版本" class="headerlink" title="去掉邻接矩阵直接判断的版本"></a>去掉邻接矩阵直接判断的版本</h3><p>别人没超时，我用Python又又超时了，我爆哭.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">one_chart_different</span><span class="params">(self, str1, str2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        判断输入的两个字符串是不是只有一个不一样, 默认输入的两个字符串长度相同</span></span><br><span class="line"><span class="string">        :param str1: String</span></span><br><span class="line"><span class="string">        :param str2: String</span></span><br><span class="line"><span class="string">        :return: Boolean True/False</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(str1)):</span><br><span class="line">            <span class="keyword">if</span> str1[i] != str2[i]:</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> num &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new_version</span><span class="params">(self, beginWord, endWord, wordList)</span>:</span></span><br><span class="line">        quene = []</span><br><span class="line">        quene.append(beginWord)</span><br><span class="line">        step = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> len(quene) != <span class="number">0</span>:</span><br><span class="line">            step += <span class="number">1</span></span><br><span class="line">            sz = len(quene)</span><br><span class="line">            <span class="keyword">while</span> sz &gt; <span class="number">0</span>:</span><br><span class="line">                hope = quene.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> hope == endWord:</span><br><span class="line">                    <span class="keyword">return</span> step</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 对每个word进行判断</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(len(wordList)):</span><br><span class="line">                    <span class="keyword">if</span> len(wordList[i]) == <span class="number">0</span> <span class="keyword">or</span> len(wordList[i]) != len(beginWord):</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="comment"># 判断差异性</span></span><br><span class="line">                    <span class="keyword">if</span> self.one_chart_different(hope,wordList[i]):</span><br><span class="line">                        quene.append(wordList[i])</span><br><span class="line">                        wordList[i] = <span class="string">""</span></span><br><span class="line">                sz -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.new_version(beginWord = <span class="string">"hit"</span>, endWord = <span class="string">"cog"</span>, wordList = [<span class="string">"hot"</span>,<span class="string">"dot"</span>,<span class="string">"dog"</span>,<span class="string">"lot"</span>,<span class="string">"log"</span>]))</span><br></pre></td></tr></table></figure></p><h3 id="参考大佬的版本"><a href="#参考大佬的版本" class="headerlink" title="参考大佬的版本"></a>参考大佬的版本</h3><p>反正都是小写字母，每次只变动一位，干脆拿到一个节点时生成所有可能的下一个节点，新生成的节点只要再列表中就参与计算。</p><p>这次终于通过了，不过耗时几百毫秒。<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">def ladderLength(self, beginWord: str, endWord: str, wordLis<span class="variable">t:</span> List[str]) -&gt; in<span class="variable">t:</span></span><br><span class="line">        <span class="keyword">if</span> endWord not in wordLis<span class="variable">t:</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">l</span> = <span class="built_in">len</span>(endWord)</span><br><span class="line">        </span><br><span class="line">            </span><br><span class="line">        <span class="keyword">ws</span> = <span class="keyword">set</span>(wordList)</span><br><span class="line">        </span><br><span class="line">        head = &#123;beginWord&#125;</span><br><span class="line">        tail = &#123;endWord&#125;</span><br><span class="line">        tmp = <span class="keyword">list</span>(<span class="string">'abcdefghijklmnopqrstuvwxyz'</span>)</span><br><span class="line">        <span class="keyword">res</span> = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(head) &gt; <span class="built_in">len</span>(tail):</span><br><span class="line">                head, tail = tail, head</span><br><span class="line">            </span><br><span class="line">            q = <span class="keyword">set</span>()</span><br><span class="line">            <span class="keyword">for</span> cur in head:</span><br><span class="line">                <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="keyword">l</span>):</span><br><span class="line">                    <span class="keyword">for</span> <span class="keyword">j</span> in tmp:</span><br><span class="line">                        word = cur[:i] + <span class="keyword">j</span> + cur[i+<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> word in tai<span class="variable">l:</span></span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">res</span> + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> word in <span class="keyword">w</span><span class="variable">s:</span></span><br><span class="line">                            q.<span class="built_in">add</span>(word)</span><br><span class="line">                            <span class="keyword">ws</span>.<span class="built_in">remove</span>(word)</span><br><span class="line">            head = q</span><br><span class="line">            <span class="keyword">res</span> += <span class="number">1</span></span><br><span class="line">                    </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LeetCode第127题—单词接龙&quot;&gt;&lt;a href=&quot;#LeetCode第127题—单词接龙&quot; class=&quot;headerlink&quot; title=&quot;LeetCode第127题—单词接龙&quot;&gt;&lt;/a&gt;LeetCode第127题—单词接龙&lt;/h1&gt;&lt;p&gt;自己代码的开
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.126</title>
    <link href="www.strivezs.com/2021/06/02/LeetCode%E7%AC%AC126%E9%A2%98/"/>
    <id>www.strivezs.com/2021/06/02/LeetCode%E7%AC%AC126%E9%A2%98/</id>
    <published>2021-06-02T08:57:37.483Z</published>
    <updated>2021-06-02T08:57:37.483Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode第126题—单词接龙II"><a href="#LeetCode第126题—单词接龙II" class="headerlink" title="LeetCode第126题—单词接龙II"></a>LeetCode第126题—单词接龙II</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>按字典 wordList 完成从单词 beginWord 到单词 endWord 转化，一个表示此过程的 转换序列 是形式上像 beginWord -&gt; s1 -&gt; s2 -&gt; … -&gt; sk 这样的单词序列，并满足：</p><p>每对相邻的单词之间仅有单个字母不同。<br>转换过程中的每个单词 si（1 &lt;= i &lt;= k）必须是字典 wordList 中的单词。注意，beginWord 不必是字典 wordList 中的单词。<br>sk == endWord<br>给你两个单词 beginWord 和 endWord ，以及一个字典 wordList 。请你找出并返回所有从 beginWord 到 endWord 的 最短转换序列 ，如果不存在这样的转换序列，返回一个空列表。每个序列都应该以单词列表 [beginWord, s1, s2, …, sk] 的形式返回。</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：<span class="keyword">begin</span>Word = <span class="string">"hit"</span>, <span class="keyword">end</span>Word = <span class="string">"cog"</span>, wordList = [<span class="string">"hot"</span>,<span class="string">"dot"</span>,<span class="string">"dog"</span>,<span class="string">"lot"</span>,<span class="string">"log"</span>,<span class="string">"cog"</span>]</span><br><span class="line">输出：[[<span class="string">"hit"</span>,<span class="string">"hot"</span>,<span class="string">"dot"</span>,<span class="string">"dog"</span>,<span class="string">"cog"</span>],[<span class="string">"hit"</span>,<span class="string">"hot"</span>,<span class="string">"lot"</span>,<span class="string">"log"</span>,<span class="string">"cog"</span>]]</span><br><span class="line">解释：存在 <span class="number">2</span> 种最短的转换序列：</span><br><span class="line"><span class="string">"hit"</span> -&gt; <span class="string">"hot"</span> -&gt; <span class="string">"dot"</span> -&gt; <span class="string">"dog"</span> -&gt; <span class="string">"cog"</span></span><br><span class="line"><span class="string">"hit"</span> -&gt; <span class="string">"hot"</span> -&gt; <span class="string">"lot"</span> -&gt; <span class="string">"log"</span> -&gt; <span class="string">"cog"</span></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：<span class="keyword">begin</span>Word = <span class="string">"hit"</span>, <span class="keyword">end</span>Word = <span class="string">"cog"</span>, wordList = [<span class="string">"hot"</span>,<span class="string">"dot"</span>,<span class="string">"dog"</span>,<span class="string">"lot"</span>,<span class="string">"log"</span>]</span><br><span class="line">输出：[]</span><br><span class="line">解释：<span class="keyword">end</span>Word <span class="string">"cog"</span> 不在字典 wordList 中，所以不存在符合要求的转换序列。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= <span class="keyword">begin</span>Word.length &lt;= <span class="number">7</span></span><br><span class="line"><span class="keyword">end</span>Word.length == <span class="keyword">begin</span>Word.length</span><br><span class="line"><span class="number">1</span> &lt;= wordList.length &lt;= <span class="number">5000</span></span><br><span class="line">wordList[i].length == <span class="keyword">begin</span>Word.length</span><br><span class="line"><span class="keyword">begin</span>Word、<span class="keyword">end</span>Word 和 wordList[i] 由小写英文字母组成</span><br><span class="line"><span class="keyword">begin</span>Word != <span class="keyword">end</span>Word</span><br><span class="line">wordList 中的所有单词 互不相同</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p><img src="https://gitee.com/zyp521/upload_image/raw/master/IMG_0713.PNG" alt="figure.1"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>回溯法做的. 不知道为什么，我写的代码，一个测试用例提交报错，我同样在本地测试一点问题都没有。不知道啥情况了，代码整体思想没有问题。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def one_chart_different(self, str1, str2):</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        判断输入的两个字符串是不是只有一个不一样, 默认输入的两个字符串长度相同</span><br><span class="line">        :param str1: String</span><br><span class="line">        :param str2: String</span><br><span class="line">        :<span class="keyword">return</span>: Boolean True/False</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="built_in">len</span>(str1)):</span><br><span class="line">            <span class="keyword">if</span> str1[i] != str2[i]:</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> num &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> False</span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> False</span><br><span class="line">        <span class="keyword">return</span> True</span><br><span class="line">    # fixme: BFS深度度优先搜索寻找最短路径 实质上就是暴力搜索  回溯法</span><br><span class="line">    res_path = dict()</span><br><span class="line">    min_dist = float(<span class="string">'inf'</span>)</span><br><span class="line">    def BFS_Search(self, start, ends, path, visited, adjacent_matrix):</span><br><span class="line">        inf = float(<span class="string">'inf'</span>)</span><br><span class="line">        # 如果满足则存储路径和距离</span><br><span class="line">        <span class="keyword">if</span> start == end<span class="variable">s:</span></span><br><span class="line">            path_node = path.<span class="keyword">split</span>(<span class="string">','</span>)</span><br><span class="line">            distance = <span class="built_in">len</span>(path_node)</span><br><span class="line">            <span class="keyword">if</span> distance &lt; self.min_dis<span class="variable">t:</span></span><br><span class="line">                self.min_dist = distance</span><br><span class="line">            <span class="keyword">if</span> path not in self.res_path.<span class="built_in">keys</span>():</span><br><span class="line">                self.res_path[path] = distance</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        n = <span class="built_in">len</span>(adjacent_matrix)</span><br><span class="line">        <span class="keyword">for</span> i in <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> adjacent_matrix[start][i] != inf <span class="built_in">and</span> not visited[i]:</span><br><span class="line">                t = path</span><br><span class="line">                path = path + <span class="string">','</span> + str(i)</span><br><span class="line">                visited[i] = True</span><br><span class="line">                self.BFS_Search(i, ends, path, visited, adjacent_matrix)</span><br><span class="line">                path = t</span><br><span class="line">                visited[i] = False</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def findLadders(self, beginWord, endWord, wordList):</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        :<span class="built_in">type</span> beginWord: str</span><br><span class="line">        :<span class="built_in">type</span> endWord: str</span><br><span class="line">        :<span class="built_in">type</span> wordLis<span class="variable">t:</span> List[str]</span><br><span class="line">        :rtype: List[List[str]]</span><br><span class="line">        根据给定的字典<span class="keyword">list</span>构造一个图，考虑使用邻接矩阵构建一个图</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        inf = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">if</span> endWord not in wordLis<span class="variable">t:</span></span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> beginWord not in wordLis<span class="variable">t:</span></span><br><span class="line">            nodeList = [beginWord] + wordList  # 构造所有节点列表</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            nodeList = wordList</span><br><span class="line">        numList = [i <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="built_in">len</span>(nodeList))] # 构造每个节点对应的数字状态</span><br><span class="line">        node_num_dict = dict(zip(nodeList,numList)) # 构建对应关系的字典</span><br><span class="line">        num_node_dict = dict(zip(numList,nodeList)) # 构造反向对应关系</span><br><span class="line">        adjacent_matrix = [[inf <span class="keyword">for</span> _ in <span class="built_in">range</span>(<span class="built_in">len</span>(nodeList))] <span class="keyword">for</span> _ in <span class="built_in">range</span>(<span class="built_in">len</span>(nodeList))] # 邻接矩阵</span><br><span class="line">        # 构建邻接矩阵</span><br><span class="line">        <span class="keyword">for</span> i in nodeLis<span class="variable">t:</span></span><br><span class="line">            <span class="keyword">for</span> <span class="keyword">j</span> in nodeLis<span class="variable">t:</span></span><br><span class="line">                <span class="keyword">if</span> i != <span class="keyword">j</span>:</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">len</span>(i) == <span class="built_in">len</span>(<span class="keyword">j</span>):</span><br><span class="line">                        <span class="keyword">if</span> self.one_chart_different(i,<span class="keyword">j</span>):</span><br><span class="line">                            adjacent_matrix[node_num_dict[i]][node_num_dict[<span class="keyword">j</span>]] = <span class="number">1</span></span><br><span class="line">                            adjacent_matrix[node_num_dict[<span class="keyword">j</span>]][node_num_dict[i]] = <span class="number">1</span></span><br><span class="line">        # 使用BFS回溯法搜索</span><br><span class="line">        visited = [False] * <span class="built_in">len</span>(adjacent_matrix)</span><br><span class="line">        visited[<span class="number">0</span>] = True</span><br><span class="line">        self.BFS_Search(nodeList.<span class="built_in">index</span>(beginWord),nodeList.<span class="built_in">index</span>(endWord),str(nodeList.<span class="built_in">index</span>(beginWord)),visited,adjacent_matrix)</span><br><span class="line">        <span class="keyword">res</span> = []</span><br><span class="line">        <span class="keyword">for</span> item in self.res_path.<span class="built_in">keys</span>():</span><br><span class="line">            <span class="keyword">if</span> self.res_path[item] == self.min_dis<span class="variable">t:</span></span><br><span class="line">                temp = []</span><br><span class="line">                path = item.<span class="keyword">split</span>(<span class="string">','</span>)</span><br><span class="line">                <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="built_in">len</span>(path)):</span><br><span class="line">                    temp.<span class="keyword">append</span>(num_node_dict[<span class="keyword">int</span>(path[i])])</span><br><span class="line">                <span class="keyword">res</span>.<span class="keyword">append</span>(temp)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">res</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    <span class="keyword">print</span>(s.findLadders(beginWord = <span class="string">"hot"</span>, endWord = <span class="string">"dog"</span>, wordList = [<span class="string">"hot"</span>,<span class="string">"dog"</span>,<span class="string">"dot"</span>]))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LeetCode第126题—单词接龙II&quot;&gt;&lt;a href=&quot;#LeetCode第126题—单词接龙II&quot; class=&quot;headerlink&quot; title=&quot;LeetCode第126题—单词接龙II&quot;&gt;&lt;/a&gt;LeetCode第126题—单词接龙II&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 基于邻接矩阵的Dijkstra算法</title>
    <link href="www.strivezs.com/2021/06/02/%E5%9F%BA%E4%BA%8E%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E7%9A%84Dijkstra%E7%AE%97%E6%B3%95/"/>
    <id>www.strivezs.com/2021/06/02/%E5%9F%BA%E4%BA%8E%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E7%9A%84Dijkstra%E7%AE%97%E6%B3%95/</id>
    <published>2021-06-02T08:52:14.412Z</published>
    <updated>2021-06-02T08:52:14.412Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于邻接矩阵的Dijkstra算法"><a href="#基于邻接矩阵的Dijkstra算法" class="headerlink" title="基于邻接矩阵的Dijkstra算法"></a>基于邻接矩阵的Dijkstra算法</h1><p>如果你的图不是邻接矩阵，转换成矩阵的形式就可以了。这里节点我就是用index表示的。  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">fixme:</span> Dijkstra算法寻找最短路径，从给定初始点到每个节点的最短路径</span></span><br><span class="line">    def Dijkstra(self, <span class="keyword">start</span>, adjacent_matrix):</span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :param start: Int 给点初始节点在邻接矩阵中的下标</span></span><br><span class="line"><span class="string">        :param adjacent_matrix: 邻接矩阵</span></span><br><span class="line"><span class="string">        :return: distance, path 返回到每个节点的最短距离，返回路径</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 初始化操作</span></span><br><span class="line">        n = <span class="keyword">len</span>(adjacent_matrix) <span class="comment"># 节点个数</span></span><br><span class="line">        inf = <span class="built_in">float</span>(<span class="string">'inf'</span>)</span><br><span class="line">        distance = [inf] * n <span class="comment"># 用于存放从某个点到其他点的最短路径长度</span></span><br><span class="line">        <span class="keyword">path</span> = [<span class="keyword">None</span>] * n <span class="comment"># 用于存放从初始点到其他点的路径</span></span><br><span class="line">        <span class="keyword">final</span> = [<span class="keyword">None</span>] * n <span class="comment"># 用于存放从初始点到其他点的最短路径</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">range</span>(n):</span><br><span class="line">            <span class="keyword">final</span>[i] = <span class="literal">False</span></span><br><span class="line">            distance[i] = adjacent_matrix[<span class="keyword">start</span>][i]</span><br><span class="line">            <span class="keyword">path</span>[i] = <span class="string">""</span>  <span class="comment"># 路径置空</span></span><br><span class="line">            <span class="keyword">if</span> distance[i] &lt; inf:</span><br><span class="line">                <span class="keyword">path</span>[i] = <span class="keyword">str</span>(i)</span><br><span class="line">        distance[<span class="keyword">start</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">final</span>[<span class="keyword">start</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 算法</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">min</span> = inf</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="keyword">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">final</span>[k] <span class="keyword">and</span> distance[k] &lt; <span class="keyword">min</span>:</span><br><span class="line">                    v = k</span><br><span class="line">                    <span class="keyword">min</span> = distance[k]</span><br><span class="line">            <span class="keyword">final</span>[v] = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="keyword">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">final</span>[k] <span class="keyword">and</span> <span class="keyword">min</span> + adjacent_matrix[v][k] &lt; distance[k]:</span><br><span class="line">                    distance[k] = <span class="keyword">min</span> + adjacent_matrix[v][k]</span><br><span class="line">                    <span class="keyword">path</span>[k] = <span class="keyword">path</span>[v] + <span class="string">','</span> + <span class="keyword">str</span>(k)</span><br><span class="line">        <span class="keyword">return</span> distance, <span class="keyword">path</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基于邻接矩阵的Dijkstra算法&quot;&gt;&lt;a href=&quot;#基于邻接矩阵的Dijkstra算法&quot; class=&quot;headerlink&quot; title=&quot;基于邻接矩阵的Dijkstra算法&quot;&gt;&lt;/a&gt;基于邻接矩阵的Dijkstra算法&lt;/h1&gt;&lt;p&gt;如果你的图不是邻接矩
      
    
    </summary>
    
    
      <category term="算法" scheme="www.strivezs.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="算法" scheme="www.strivezs.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图" scheme="www.strivezs.com/tags/%E5%9B%BE/"/>
    
      <category term="最短路径" scheme="www.strivezs.com/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    
      <category term="Dijkstra" scheme="www.strivezs.com/tags/Dijkstra/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.125</title>
    <link href="www.strivezs.com/2021/06/01/LeetCode%E7%AC%AC125%E9%A2%98/"/>
    <id>www.strivezs.com/2021/06/01/LeetCode%E7%AC%AC125%E9%A2%98/</id>
    <published>2021-06-01T11:17:18.841Z</published>
    <updated>2021-06-01T11:17:18.841Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode第125题—验证回文串"><a href="#LeetCode第125题—验证回文串" class="headerlink" title="LeetCode第125题—验证回文串"></a>LeetCode第125题—验证回文串</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p><p>说明：本题中，我们将空字符串定义为有效的回文串。<br><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: <span class="comment">"A man, a plan, a canal: Panama"</span></span><br><span class="line">输出: <span class="keyword">true</span></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: <span class="comment">"race a car"</span></span><br><span class="line">输出: <span class="keyword">false</span></span><br></pre></td></tr></table></figure></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>执行用时：88 ms, 在所有 Python3 提交中击败了7.76%的用户内存消耗：14.9 MB, 在所有 Python3 提交中击败了96.98%的用户<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">judeRange</span><span class="params">(self, c)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> c &gt;= <span class="string">'a'</span> <span class="keyword">and</span> c &lt;= <span class="string">'z'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> c &gt;= <span class="string">'A'</span> <span class="keyword">and</span> c &lt;= <span class="string">'Z'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> c &gt;=<span class="string">'0'</span> <span class="keyword">and</span> c &lt;= <span class="string">'9'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        核心思想:</span></span><br><span class="line"><span class="string">            双向指针，自动去除出字母和数字之外的字符串</span></span><br><span class="line"><span class="string">            统一将字母转换为小写</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        ends = len(s)<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> start &lt; ends:</span><br><span class="line">            flag1 = self.judeRange(s[start])</span><br><span class="line">            flag2 = self.judeRange(s[ends])</span><br><span class="line">            <span class="keyword">if</span> flag1 <span class="keyword">and</span> flag2:</span><br><span class="line">                s1 = s[start].lower()</span><br><span class="line">                s2 = s[ends].lower()</span><br><span class="line">                <span class="keyword">if</span> s1 != s2:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">                ends -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> flag1 <span class="keyword">and</span> ~flag2:</span><br><span class="line">                ends -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> ~flag1 <span class="keyword">and</span> flag2:</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">                ends -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LeetCode第125题—验证回文串&quot;&gt;&lt;a href=&quot;#LeetCode第125题—验证回文串&quot; class=&quot;headerlink&quot; title=&quot;LeetCode第125题—验证回文串&quot;&gt;&lt;/a&gt;LeetCode第125题—验证回文串&lt;/h1&gt;&lt;p&gt;自己
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.123=4</title>
    <link href="www.strivezs.com/2021/05/31/LeetCode%E7%AC%AC124%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/31/LeetCode%E7%AC%AC124%E9%A2%98/</id>
    <published>2021-05-31T14:43:30.630Z</published>
    <updated>2021-05-31T14:43:30.630Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode第123题—买卖股票的最佳时机III"><a href="#LeetCode第123题—买卖股票的最佳时机III" class="headerlink" title="LeetCode第123题—买卖股票的最佳时机III"></a>LeetCode第123题—买卖股票的最佳时机III</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</p><p>路径和 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点 root ，返回其 最大路径和 。</p><p><img src="https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg" alt="figure.1"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：最优路径是 <span class="number">2</span> -&gt; <span class="number">1</span> -&gt; <span class="number">3</span> ，路径和为 <span class="number">2</span> + <span class="number">1</span> + <span class="number">3</span> = <span class="number">6</span></span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg" alt="figure.2"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">-10</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">42</span></span><br><span class="line">解释：最优路径是 <span class="number">15</span> -&gt; <span class="number">20</span> -&gt; <span class="number">7</span> ，路径和为 <span class="number">15</span> + <span class="number">20</span> + <span class="number">7</span> = <span class="number">42</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">树中节点数目范围是 [<span class="number">1</span>, <span class="number">3</span> * <span class="number">104</span>]</span><br><span class="line"><span class="number">-1000</span> &lt;= Node.val &lt;= <span class="number">1000</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, val=<span class="number">0</span>, left=None, right=None)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.val = val</span><br><span class="line">        <span class="keyword">self</span>.left = left</span><br><span class="line">        <span class="keyword">self</span>.right = right</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="title">object</span>):</span></span><br><span class="line">    max_sum = -sys.maxsize</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs_statistic_path</span><span class="params">(<span class="keyword">self</span>, root)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="symbol">None:</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left_sum = max(<span class="number">0</span>, <span class="keyword">self</span>.dfs_statistic_path(root.left)) <span class="comment"># 统计左子树的路径总和</span></span><br><span class="line">        right_sum = max(<span class="number">0</span>, <span class="keyword">self</span>.dfs_statistic_path(root.right)) <span class="comment"># 统计右子树的路径总和</span></span><br><span class="line">        temp = left_sum + root.val + right_sum <span class="comment"># 统计当前路径总和</span></span><br><span class="line">        <span class="keyword">self</span>.max_sum = max(<span class="keyword">self</span>.max_sum, temp) <span class="comment"># 和当前最大路径进行比较</span></span><br><span class="line">        <span class="keyword">return</span> max(left_sum,right_sum) + root.val <span class="comment"># 由于不能够返回(节点不能够重复)，因此只能选择出最大的一个子树再加上当前根节点值来返回</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxPathSum</span><span class="params">(<span class="keyword">self</span>, root)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        整体上是分而治之的思想，看成一个个子问题</span></span><br><span class="line"><span class="string">        将每个节点看成是它子树的路径和(左子树和右子树)+他本来的值</span></span><br><span class="line"><span class="string">        只有子路径和大于0的时候才会去统计它</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        <span class="keyword">self</span>.dfs_statistic_path(root)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.max_sum</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name_<span class="number">_</span> == <span class="string">'__main__'</span><span class="symbol">:</span></span><br><span class="line">    root = TreeNode(<span class="number">1</span>)</span><br><span class="line">    node1 = TreeNode(<span class="number">2</span>)</span><br><span class="line">    node2 = TreeNode(<span class="number">3</span>)</span><br><span class="line">    root.left = node1</span><br><span class="line">    root.right = node2</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.maxPathSum(root))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LeetCode第123题—买卖股票的最佳时机III&quot;&gt;&lt;a href=&quot;#LeetCode第123题—买卖股票的最佳时机III&quot; class=&quot;headerlink&quot; title=&quot;LeetCode第123题—买卖股票的最佳时机III&quot;&gt;&lt;/a&gt;LeetCode
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.123</title>
    <link href="www.strivezs.com/2021/05/30/LeetCode%E7%AC%AC123%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/30/LeetCode%E7%AC%AC123%E9%A2%98/</id>
    <published>2021-05-30T11:32:17.739Z</published>
    <updated>2021-05-30T11:32:17.739Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode第123题—买卖股票的最佳时机III"><a href="#LeetCode第123题—买卖股票的最佳时机III" class="headerlink" title="LeetCode第123题—买卖股票的最佳时机III"></a>LeetCode第123题—买卖股票的最佳时机III</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入：prices = [<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：在第 <span class="number">4</span> 天（股票价格 = <span class="number">0</span>）的时候买入，在第 <span class="number">6</span> 天（股票价格 = <span class="number">3</span>）的时候卖出，这笔交易所能获得利润 = <span class="number">3</span><span class="number">-0</span> = <span class="number">3</span> 。</span><br><span class="line">     随后，在第 <span class="number">7</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">8</span> 天 （股票价格 = <span class="number">4</span>）的时候卖出，这笔交易所能获得利润 = <span class="number">4</span><span class="number">-1</span> = <span class="number">3</span> 。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：prices = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：在第 <span class="number">1</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">5</span> 天 （股票价格 = <span class="number">5</span>）的时候卖出, 这笔交易所能获得利润 = <span class="number">5</span><span class="number">-1</span> = <span class="number">4</span> 。   </span><br><span class="line">     注意你不能在第 <span class="number">1</span> 天和第 <span class="number">2</span> 天接连购买股票，之后再将它们卖出。   </span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：prices = [<span class="number">7</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>] </span><br><span class="line">输出：<span class="number">0</span> </span><br><span class="line">解释：在这个情况下, 没有交易完成, 所以最大利润为 <span class="number">0</span>。</span><br><span class="line">示例 <span class="number">4</span>：</span><br><span class="line"></span><br><span class="line">输入：prices = [<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= prices.length &lt;= <span class="number">105</span></span><br><span class="line"><span class="number">0</span> &lt;= prices[i] &lt;= <span class="number">105</span></span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>参考大佬的动态规划思想做出来的。我是菜逼我是菜逼</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/IMG_0712.PNG" alt="figure.1"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        利用动态规划</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(prices) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 五种状态初始化</span></span><br><span class="line">        dp0 = <span class="number">0</span></span><br><span class="line">        dp1 = -prices[<span class="number">0</span>]</span><br><span class="line">        dp2 = -sys.maxsize</span><br><span class="line">        dp3 = -sys.maxsize</span><br><span class="line">        dp4 = -sys.maxsize</span><br><span class="line">        <span class="comment"># 状态转移</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(prices)):</span><br><span class="line">            dp1 = max(dp1, dp0-prices[i]) <span class="comment"># 可能是从dp0买入一笔转移过来的，但是没有卖出因此为-prices[i]，也可能是一直处于dp1没有卖出</span></span><br><span class="line">            dp2 = max(dp2, dp1+prices[i]) <span class="comment"># 可能是从dp1卖出一笔转移过来的，因为卖出了所以为+prices[i],也可能是因为没有买一直停留在dp2</span></span><br><span class="line">            dp3 = max(dp3, dp2-prices[i])</span><br><span class="line">            dp4 = max(dp4, dp3+prices[i])</span><br><span class="line">        <span class="keyword">return</span> dp4 <span class="comment">#返回最终状态，就是最终的利润</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s  = Solution()</span><br><span class="line">    print(s.maxProfit([<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>]))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LeetCode第123题—买卖股票的最佳时机III&quot;&gt;&lt;a href=&quot;#LeetCode第123题—买卖股票的最佳时机III&quot; class=&quot;headerlink&quot; title=&quot;LeetCode第123题—买卖股票的最佳时机III&quot;&gt;&lt;/a&gt;LeetCode
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.122</title>
    <link href="www.strivezs.com/2021/05/29/LeetCode%E7%AC%AC122%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/29/LeetCode%E7%AC%AC122%E9%A2%98/</id>
    <published>2021-05-29T12:46:43.308Z</published>
    <updated>2021-05-29T12:46:43.308Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode第122题—买卖股票的最佳时机II"><a href="#LeetCode第122题—买卖股票的最佳时机II" class="headerlink" title="LeetCode第122题—买卖股票的最佳时机II"></a>LeetCode第122题—买卖股票的最佳时机II</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: prices = [<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="number">7</span></span><br><span class="line">解释: 在第 <span class="number">2</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">3</span> 天（股票价格 = <span class="number">5</span>）的时候卖出, 这笔交易所能获得利润 = <span class="number">5</span><span class="number">-1</span> = <span class="number">4</span> 。</span><br><span class="line">     随后，在第 <span class="number">4</span> 天（股票价格 = <span class="number">3</span>）的时候买入，在第 <span class="number">5</span> 天（股票价格 = <span class="number">6</span>）的时候卖出, 这笔交易所能获得利润 = <span class="number">6</span><span class="number">-3</span> = <span class="number">3</span> 。</span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: prices = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line">解释: 在第 <span class="number">1</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">5</span> 天 （股票价格 = <span class="number">5</span>）的时候卖出, 这笔交易所能获得利润 = <span class="number">5</span><span class="number">-1</span> = <span class="number">4</span> 。</span><br><span class="line">     注意你不能在第 <span class="number">1</span> 天和第 <span class="number">2</span> 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br><span class="line">示例 <span class="number">3</span>:</span><br><span class="line"></span><br><span class="line">输入: prices = [<span class="number">7</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">0</span></span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 <span class="number">0</span>。</span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= prices.length &lt;= <span class="number">3</span> * <span class="number">104</span></span><br><span class="line"><span class="number">0</span> &lt;= prices[i] &lt;= <span class="number">104</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        使用贪心的方法，考虑有盈利就卖的思想</span></span><br><span class="line"><span class="string">        [7, 1, 5, 6] 第二天买入，第四天卖出，收益最大（6-1），所以一般人可能会想，怎么判断不是第三天就卖出了呢? 这里就把问题复杂化了，根据题目的意思，当天卖出以后，当天还可以买入，所以其实可以第三天卖出，第三天买入，第四天又卖出（（5-1）+ （6-5） === 6 - 1）。</span></span><br><span class="line"><span class="string">        所以算法可以直接简化为只要今天比昨天大，就卖出。</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(prices)):</span><br><span class="line">            temp  = prices[i] - prices[i<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span> temp &gt; <span class="number">0</span>:</span><br><span class="line">                res += temp</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LeetCode第122题—买卖股票的最佳时机II&quot;&gt;&lt;a href=&quot;#LeetCode第122题—买卖股票的最佳时机II&quot; class=&quot;headerlink&quot; title=&quot;LeetCode第122题—买卖股票的最佳时机II&quot;&gt;&lt;/a&gt;LeetCode第12
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>向量点乘和叉乘</title>
    <link href="www.strivezs.com/2021/05/29/%E5%90%91%E9%87%8F%E7%82%B9%E4%B9%98%E5%92%8C%E5%8F%89%E4%B9%98/"/>
    <id>www.strivezs.com/2021/05/29/%E5%90%91%E9%87%8F%E7%82%B9%E4%B9%98%E5%92%8C%E5%8F%89%E4%B9%98/</id>
    <published>2021-05-29T12:46:38.214Z</published>
    <updated>2021-05-29T12:46:38.214Z</updated>
    
    <content type="html"><![CDATA[<h1 id="向量点乘和叉乘"><a href="#向量点乘和叉乘" class="headerlink" title="向量点乘和叉乘"></a>向量点乘和叉乘</h1><p>假设存在向量a和向量b:<script type="math/tex">a=[a_{1},a_{2},a_{3}],b=[b_{1},b_{2},b_{3}]</script></p><h2 id="点乘"><a href="#点乘" class="headerlink" title="点乘"></a>点乘</h2><p>向量a和向量b的点乘公式如下:</p><script type="math/tex; mode=display">a\bullet b=a_{1}b_{1}+a_{2}b_{2}+a_{3}b_{3}</script><p>要求是向量a和向量的b的维度要相同。</p><h3 id="点乘的几何意义"><a href="#点乘的几何意义" class="headerlink" title="点乘的几何意义"></a>点乘的几何意义</h3><p>点乘的几何意义是可以用来表征或者计算两个向量之间的夹角，以及在b向量或在a向量方向上的投影，公式如下:</p><script type="math/tex; mode=display">a\bullet b=a_{1}b_{1}+a_{2}b_{2}+a_{3}b_{3}=|a||b|cos \theta</script><p>首先假设一下向量构成:</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/itRaNO.png" alt="figure.1"></p><p><strong>推导过程如下</strong>:</p><ul><li>根据上图可以得到c=a-b</li><li>根据三角余弦定理可以得到: <script type="math/tex">c^{2}=a^{2}+b^{2}-2|a||b|cos \theta</script></li><li>根据c=a-b，我们可以对上式变换得到 <script type="math/tex">(a-b) \bullet(a-b)=a^{2}+b^{2}-2 a \bullet b=a^{2}+b^{2}-2|a \| b| \cos \theta</script></li><li>化简上式我们可以得到: <script type="math/tex">a\bullet b=|a||b|cos \theta</script></li><li>因此在已知向量a和向量b长度的情况下，我们可以计算得到a和b的夹角θ</li><li><script type="math/tex; mode=display">\theta=arc\: cos\left ( \frac{a \bullet b}{|a||b|} \right )</script></li></ul><p>根据上述公式就可以计算向量a和向量b之间的夹角，从而就进一步判断出这两个向量是否是同一方向，是否正交，具体对应关系如下:</p><ul><li>a·b&gt;0 : 方向基本相同，夹角在0到90度之间</li><li>a·b=0 : 两个向量正交，相互垂直</li><li>a·b&lt;0 : 方向基本相反，夹角在90度到180度之间</li></ul><h2 id="叉乘"><a href="#叉乘" class="headerlink" title="叉乘"></a>叉乘</h2><p>两个向量的叉乘，又叫向量积、叉积，叉乘的运算结果是一个向量而不是一个标量。并且<strong>两个向量的叉乘与这两个向量组成的坐标平面垂直</strong><br>同样是使用之前假设的向量a和向量b，我们可以得到向量a和向量b的叉乘公式:</p><script type="math/tex; mode=display">a \times b=\left|\begin{array}{lll}\mathrm{i} & \mathrm{j} & \mathrm{k} \\a_{1} & a_{2} & a_{3} \\b_{1} & b_{2} & b_{3}\end{array}\right|=\left(a_{2}b_{3}-a_{3}b_{2}\right) i-\left(a_{1}b_{3}-a_{3}b_{1}\right) j+\left(a_{1}b_{2}-a_{2}b_{1}\right) k</script><p>其中<script type="math/tex">i=(1,0,0),j=(0,1,0),k=(0,0,1)</script>, 其中ijk均为单位向量，最后叉乘的结果为一个向量，所以ijk要为向量，因此单纯的ab相乘再相减得到的标量。<br>因此根据上述i、j、k间的关系，有如下式子(直接用向量表示):</p><script type="math/tex; mode=display">a\times b=\left( a_{2}b_{3}-a_{3}b_{2}, a_{1}b_{3}-a_{3}b_{1}, a_{1}b_{2}-a_{2}b_{1}  \right)</script><p><strong>注意</strong>: 一个向量叉乘自己得到的是0向量，根据右手定则，叉乘得到的结果无论怎么旋转都会永远会垂直这个向量，因此只有0向量满足。</p><h3 id="叉乘的几何意义"><a href="#叉乘的几何意义" class="headerlink" title="叉乘的几何意义"></a>叉乘的几何意义</h3><p>在三维几何中，向量a和向量b的叉乘结果是一个向量，这个向量又称为法向量，它是a和b构成的平面的法向量(垂直)。</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/TRPkZC.png" alt="figure.2"></p><p>如上图。</p><p><strong>右手法则</strong>：使用右手法则来判断a×b向量的方向,如下图所示</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/ttwC2c.png" alt="figuer.3"></p><p>判断方法如下:</p><ul><li>右手手掌张开，四指并拢，大拇指垂直于四指指向的方向</li><li>伸出右手，四指弯曲，四指与A旋转到B方向一致，那么大拇指指向为C向量的方向</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;向量点乘和叉乘&quot;&gt;&lt;a href=&quot;#向量点乘和叉乘&quot; class=&quot;headerlink&quot; title=&quot;向量点乘和叉乘&quot;&gt;&lt;/a&gt;向量点乘和叉乘&lt;/h1&gt;&lt;p&gt;假设存在向量a和向量b:&lt;script type=&quot;math/tex&quot;&gt;a=[a_{1},a_{2}
      
    
    </summary>
    
    
      <category term="Math" scheme="www.strivezs.com/categories/Math/"/>
    
    
      <category term="Knowledge" scheme="www.strivezs.com/tags/Knowledge/"/>
    
      <category term="Math" scheme="www.strivezs.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.121</title>
    <link href="www.strivezs.com/2021/05/28/LeetCode%E7%AC%AC121%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/28/LeetCode%E7%AC%AC121%E9%A2%98/</id>
    <published>2021-05-28T13:14:32.685Z</published>
    <updated>2021-05-28T13:14:32.685Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第121题—买卖股票的最佳时机</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p><p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：[<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：在第 <span class="number">2</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">5</span> 天（股票价格 = <span class="number">6</span>）的时候卖出，最大利润 = <span class="number">6</span><span class="number">-1</span> = <span class="number">5</span> 。</span><br><span class="line">     注意利润不能是 <span class="number">7</span><span class="number">-1</span> = <span class="number">6</span>, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：prices = [<span class="number">7</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：在这种情况下, 没有交易完成, 所以最大利润为 <span class="number">0</span>。</span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= prices.length &lt;= <span class="number">105</span></span><br><span class="line"><span class="number">0</span> &lt;= prices[i] &lt;= <span class="number">104</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        核心思想:</span></span><br><span class="line"><span class="string">            采用动态规划的方法</span></span><br><span class="line"><span class="string">            时间复杂度为O(n)</span></span><br><span class="line"><span class="string">            记录在i之前的最大利润，并和当前利润比较</span></span><br><span class="line"><span class="string">            记录i天之前的最小值</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(prices) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">0</span>] * len(prices)</span><br><span class="line">        min_value = prices[<span class="number">0</span>]</span><br><span class="line">        max_value = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(prices)):</span><br><span class="line">            max_value = max(max_value, prices[i] - min_value) <span class="comment"># 记录最大利润</span></span><br><span class="line">            min_value = min(min_value,prices[i]) <span class="comment"># 记录第i天之前的最小值</span></span><br><span class="line">        <span class="keyword">return</span> max_value</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.maxProfit([<span class="number">7</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>]))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第121题—买卖股票的最佳时机&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.120</title>
    <link href="www.strivezs.com/2021/05/27/LeetCode%E7%AC%AC120%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/27/LeetCode%E7%AC%AC120%E9%A2%98/</id>
    <published>2021-05-27T15:39:01.452Z</published>
    <updated>2021-05-27T15:39:01.452Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第120题—三角形最小路径和</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定一个三角形 triangle ，找出自顶向下的最小路径和。</p><p>每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。</p><p>示例 1：</p><p>输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]<br>输出：11<br>解释：如下面简图所示：<br>2<br>3 4<br>6 5 7<br>4 1 8 3<br>自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。<br>示例 2：</p><p>输入：triangle = [[-10]]<br>输出：-10</p><p>提示：</p><p>1 &lt;= triangle.length &lt;= 200<br>triangle[0].length == 1<br>triangle[i].length == triangle[i - 1].length + 1<br>-104 &lt;= triangle[i][j] &lt;= 104</p><p>进阶：</p><p>你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题吗？</p><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    maxSum = sys.maxsize <span class="comment"># 设置足底啊之</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">limit_dfs</span><span class="params">(self,triangle,j,iList,curSum,curDepth,depth)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :param triangle: List[List[Int]] 所有数值</span></span><br><span class="line"><span class="string">        :param j: Int 上一个节点的纵坐标</span></span><br><span class="line"><span class="string">        :param iList: List[Int] 当前节点所在的层</span></span><br><span class="line"><span class="string">        :param curParam: Int 当前层之前的路径和</span></span><br><span class="line"><span class="string">        :param curDepth: Int 当前深度</span></span><br><span class="line"><span class="string">        :param depth: 最大深度</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        t = iList[j]</span><br><span class="line">        curSum += iList[j]</span><br><span class="line">        <span class="keyword">if</span> depth == curDepth:</span><br><span class="line">            <span class="keyword">if</span> curSum &lt; self.maxSum:</span><br><span class="line">                self.maxSum = curSum</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.limit_dfs(triangle, j, triangle[curDepth+<span class="number">1</span>], curSum, curDepth+<span class="number">1</span>, depth)</span><br><span class="line">        <span class="keyword">if</span> j+<span class="number">1</span> &lt; len(triangle[curDepth+<span class="number">1</span>]):</span><br><span class="line">            self.limit_dfs(triangle, j+<span class="number">1</span>, triangle[curDepth + <span class="number">1</span>], curSum, curDepth+<span class="number">1</span>, depth)</span><br><span class="line">    <span class="comment"># 超时版本</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span><span class="params">(self, triangle)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        核心思想:</span></span><br><span class="line"><span class="string">            每个节点，只能访问它的[i+1][j]/[i+1][j+1] 两个节点</span></span><br><span class="line"><span class="string">            考虑采用递归来判断, 有点类似限制二叉树的访问方法</span></span><br><span class="line"><span class="string">        :type triangle: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int 返回最大值</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.limit_dfs(triangle,<span class="number">0</span>,triangle[<span class="number">0</span>],<span class="number">0</span>,<span class="number">0</span>,len(triangle)<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> self.maxSum</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 参考大佬的版本</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new_version</span><span class="params">(self,triangle)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(triangle) - <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                triangle[i - <span class="number">1</span>][j] += min(triangle[i][j], triangle[i][j + <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> triangle[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.minimumTotal([[<span class="number">-1</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-3</span>]]))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第120题—三角形最小路径和&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)&lt;
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.119</title>
    <link href="www.strivezs.com/2021/05/26/LeetCode%E7%AC%AC119%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/26/LeetCode%E7%AC%AC119%E9%A2%98/</id>
    <published>2021-05-26T14:10:06.243Z</published>
    <updated>2021-05-26T14:10:06.243Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第119题—杨辉三角II</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif" alt="fiogure.1"></p><p>在杨辉三角中，每个数是它左上方和右上方的数的和。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: <span class="number">3</span></span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    res = []  <span class="comment"># 全局结果</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># fixme: 递归分治生成数组</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">genrate_iList</span><span class="params">(self, pre_list, depth, goal_depth)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        采用递归分治的方法来生成每一层的数组</span></span><br><span class="line"><span class="string">        :param pre_list: List 上一层生成的数组</span></span><br><span class="line"><span class="string">        :param depth: Int 当前深度</span></span><br><span class="line"><span class="string">        :param goal_depth: Int 目标深度</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> depth == goal_depth + <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        temp = []</span><br><span class="line">        temp.append(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(pre_list) - <span class="number">1</span>):</span><br><span class="line">            temp.append(pre_list[i] + pre_list[i + <span class="number">1</span>])</span><br><span class="line">        temp.append(<span class="number">1</span>)</span><br><span class="line">        self.res.append(temp)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 递归调用</span></span><br><span class="line">        self.genrate_iList(temp, depth + <span class="number">1</span>, goal_depth)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRow</span><span class="params">(self, numRows)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type numRows: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">            由于每个值都是它上面两个值的加和，因此考虑为分治问题</span></span><br><span class="line"><span class="string">            考虑还是使用递归的方法，因此每次传入的数组就是上一次递归生成的数组.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.res = []</span><br><span class="line">        <span class="keyword">if</span> numRows == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.res</span><br><span class="line">        self.res.append([<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">if</span> numRows == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> self.res</span><br><span class="line">        self.res.append([<span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">if</span> numRows == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> self.res</span><br><span class="line">        self.genrate_iList([<span class="number">1</span>, <span class="number">1</span>], <span class="number">3</span>, numRows+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> self.res[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第119题—杨辉三角II&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)&lt;/p
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.118</title>
    <link href="www.strivezs.com/2021/05/24/LeetCode%E7%AC%AC118%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/24/LeetCode%E7%AC%AC118%E9%A2%98/</id>
    <published>2021-05-24T09:15:39.983Z</published>
    <updated>2021-05-24T09:15:39.983Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第118题—杨辉三角</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif" alt="figure.1"></p><p>在杨辉三角中，每个数是它左上方和右上方的数的和。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: <span class="number">5</span></span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">     [<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">   [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line"> [<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第118题—杨辉三角&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.117</title>
    <link href="www.strivezs.com/2021/05/24/LeetCode%E7%AC%AC117%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/24/LeetCode%E7%AC%AC117%E9%A2%98/</id>
    <published>2021-05-24T09:02:24.802Z</published>
    <updated>2021-05-24T09:02:24.802Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第117题—填充每个节点的下一个右侧节点指针II</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定一个二叉树</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct <span class="keyword">Node</span> <span class="title">&#123;</span></span><br><span class="line"><span class="title">  int</span> val;</span><br><span class="line">  <span class="keyword">Node</span> <span class="title">*left</span>;</span><br><span class="line">  <span class="keyword">Node</span> <span class="title">*right</span>;</span><br><span class="line">  <span class="keyword">Node</span> <span class="title">*next</span>;</span><br><span class="line">&#125;</span><br><span class="line">填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</span><br><span class="line"></span><br><span class="line">初始状态下，所有 next 指针都被设置为 NULL。</span><br><span class="line"></span><br><span class="line">进阶：</span><br><span class="line"></span><br><span class="line">你只能使用常量级额外空间。</span><br><span class="line">使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/15/117_sample.png" alt="figure.1"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="literal">null</span>,<span class="number">7</span>]</span><br><span class="line">输出：[<span class="number">1</span>,#,<span class="number">2</span>,<span class="number">3</span>,#,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,#]</span><br><span class="line">解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化输出按层序遍历顺序（由 next 指针连接），<span class="string">'#'</span> 表示每层的末尾。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">树中的节点数小于 <span class="number">6000</span></span><br><span class="line"><span class="number">-100</span> &lt;= node.val &lt;= <span class="number">100</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, val=<span class="number">0</span>, left=None, right=None, <span class="keyword">next</span>=None)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.val = val</span><br><span class="line">        <span class="keyword">self</span>.left = left</span><br><span class="line">        <span class="keyword">self</span>.right = right</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">next</span> = <span class="keyword">next</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="title">object</span>):</span></span><br><span class="line">    depth_dict = dict() <span class="comment"># 深度字典</span></span><br><span class="line">    <span class="comment"># fixme:采用bfs添加深度，将相同的深度放在同一个列表中</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(<span class="keyword">self</span>, node, depth)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        采用前序遍历</span></span><br><span class="line"><span class="string">        :param node: Node</span></span><br><span class="line"><span class="string">        :param depth: Int 深度</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        <span class="keyword">if</span> node == <span class="symbol">None:</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 创建深度层次</span></span><br><span class="line">        <span class="keyword">if</span> depth <span class="keyword">not</span> <span class="keyword">in</span> <span class="keyword">self</span>.depth_dict.keys()<span class="symbol">:</span></span><br><span class="line">            <span class="keyword">self</span>.depth_dict[depth] = list()</span><br><span class="line">        <span class="comment"># 处理在同一深度的节点</span></span><br><span class="line">        <span class="symbol">else:</span></span><br><span class="line">            <span class="comment"># 带记忆的处理方式，将链尾的值指向下一个同深度的节点</span></span><br><span class="line">            <span class="keyword">self</span>.depth_dict[depth][-<span class="number">1</span>].<span class="keyword">next</span> = node</span><br><span class="line">        <span class="keyword">self</span>.depth_dict[depth].append(node) <span class="comment"># 将结点存进去</span></span><br><span class="line">        <span class="keyword">self</span>.bfs(node.left,depth+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">self</span>.bfs(node.right,depth+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(<span class="keyword">self</span>, root)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        :type root: Node</span></span><br><span class="line"><span class="string">        :rtype: Node</span></span><br><span class="line"><span class="string">        核心思想:</span></span><br><span class="line"><span class="string">            和前面一题的代码一毛一样</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            类似DFS的感觉，将节点分层，一层的都添加到一个队列中。</span></span><br><span class="line"><span class="string">            可以考虑设置深度，将一个深度的放在同一个列表中，构建深度字典</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        depth_dict = dict() <span class="comment"># 深度词典初始化</span></span><br><span class="line">        <span class="keyword">self</span>.bfs(root,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第117题—填充每个节点的下一个右侧节点指针II&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Sta
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.116</title>
    <link href="www.strivezs.com/2021/05/23/LeetCode%E7%AC%AC116%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/23/LeetCode%E7%AC%AC116%E9%A2%98/</id>
    <published>2021-05-23T13:52:45.816Z</published>
    <updated>2021-05-23T13:52:45.816Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第116题—填充每个节点的下一个右侧节点指针</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct <span class="keyword">Node</span> <span class="title">&#123;</span></span><br><span class="line"><span class="title">  int</span> val;</span><br><span class="line">  <span class="keyword">Node</span> <span class="title">*left</span>;</span><br><span class="line">  <span class="keyword">Node</span> <span class="title">*right</span>;</span><br><span class="line">  <span class="keyword">Node</span> <span class="title">*next</span>;</span><br><span class="line">&#125;</span><br><span class="line">填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</span><br><span class="line"></span><br><span class="line">初始状态下，所有 next 指针都被设置为 NULL。</span><br><span class="line"></span><br><span class="line">进阶：</span><br><span class="line"></span><br><span class="line">你只能使用常量级额外空间。</span><br><span class="line">使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2019/02/14/116_sample.png" alt="figure.1"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">输出：[<span class="number">1</span>,#,<span class="number">2</span>,<span class="number">3</span>,#,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,#]</span><br><span class="line">解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，<span class="string">'#'</span> 标志着每一层的结束。</span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">树中节点的数量少于 <span class="number">4096</span></span><br><span class="line"><span class="number">-1000</span> &lt;= node.val &lt;= <span class="number">1000</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><p>采用带记忆的前序遍历即可。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, val=<span class="number">0</span>, left=None, right=None, <span class="keyword">next</span>=None)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.val = val</span><br><span class="line">        <span class="keyword">self</span>.left = left</span><br><span class="line">        <span class="keyword">self</span>.right = right</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">next</span> = <span class="keyword">next</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="title">object</span>):</span></span><br><span class="line">    depth_dict = dict() <span class="comment"># 深度字典</span></span><br><span class="line">    <span class="comment"># fixme:采用bfs添加深度，将相同的深度放在同一个列表中</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(<span class="keyword">self</span>, node, depth)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        采用前序遍历</span></span><br><span class="line"><span class="string">        :param node: Node</span></span><br><span class="line"><span class="string">        :param depth: Int 深度</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        <span class="keyword">if</span> node == <span class="symbol">None:</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 创建深度层次</span></span><br><span class="line">        <span class="keyword">if</span> depth <span class="keyword">not</span> <span class="keyword">in</span> <span class="keyword">self</span>.depth_dict.keys()<span class="symbol">:</span></span><br><span class="line">            <span class="keyword">self</span>.depth_dict[depth] = list()</span><br><span class="line">        <span class="comment"># 处理在同一深度的节点</span></span><br><span class="line">        <span class="symbol">else:</span></span><br><span class="line">            <span class="comment"># 带记忆的处理方式，将链尾的值指向下一个同深度的节点</span></span><br><span class="line">            <span class="keyword">self</span>.depth_dict[depth][-<span class="number">1</span>].<span class="keyword">next</span> = node</span><br><span class="line">        <span class="keyword">self</span>.depth_dict[depth].append(node) <span class="comment"># 将结点存进去</span></span><br><span class="line">        <span class="keyword">self</span>.bfs(node.left,depth+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">self</span>.bfs(node.right,depth+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(<span class="keyword">self</span>, root)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        :type root: Node</span></span><br><span class="line"><span class="string">        :rtype: Node</span></span><br><span class="line"><span class="string">        核心思想:</span></span><br><span class="line"><span class="string">            完美二叉树：它的所有叶子节点都在同一层，每个父结点都有两个叶子结点</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            类似DFS的感觉，将节点分层，一层的都添加到一个队列中。</span></span><br><span class="line"><span class="string">            可以考虑设置深度，将一个深度的放在同一个列表中，构建深度字典</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        depth_dict = dict() <span class="comment"># 深度词典初始化</span></span><br><span class="line">        <span class="keyword">self</span>.bfs(root,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第116题—填充每个节点的下一个右侧节点指针&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.115</title>
    <link href="www.strivezs.com/2021/05/22/LeetCode%E7%AC%AC115%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/22/LeetCode%E7%AC%AC115%E9%A2%98/</id>
    <published>2021-05-22T11:31:58.743Z</published>
    <updated>2021-05-22T11:31:58.743Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第115题—不同的子序列</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。</p><p>字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，“ACE” 是 “ABCDE” 的一个子序列，而 “AEC” 不是）</p><p>题目数据保证答案符合 32 位带符号整数范围。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"rabbbit"</span>, t = <span class="string">"rabbit"</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line">如下图所示, 有 <span class="number">3</span> 种可以从 s 中得到 <span class="string">"rabbit"</span> 的方案。</span><br><span class="line">(上箭头符号 ^ 表示选取的字母)</span><br><span class="line">rabbbit</span><br><span class="line">^^^^ ^^</span><br><span class="line">rabbbit</span><br><span class="line">^^ ^^^^</span><br><span class="line">rabbbit</span><br><span class="line">^^^ ^^^</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"babgbag"</span>, t = <span class="string">"bag"</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：</span><br><span class="line">如下图所示, 有 <span class="number">5</span> 种可以从 s 中得到 <span class="string">"bag"</span> 的方案。 </span><br><span class="line">(上箭头符号 ^ 表示选取的字母)</span><br><span class="line">babgbag</span><br><span class="line">^^ ^</span><br><span class="line">babgbag</span><br><span class="line">^^    ^</span><br><span class="line">babgbag</span><br><span class="line">^    ^^</span><br><span class="line">babgbag</span><br><span class="line">  ^  ^^</span><br><span class="line">babgbag</span><br><span class="line">    ^^^</span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> &lt;= s.length, t.length &lt;= <span class="number">1000</span></span><br><span class="line">s 和 t 由英文字母组成</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def numDistinct(self, s, t):</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        :<span class="built_in">type</span> <span class="variable">s:</span> str</span><br><span class="line">        :<span class="built_in">type</span> <span class="variable">t:</span> str</span><br><span class="line">        :rtype: <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">        核心思想:</span><br><span class="line"></span><br><span class="line">            字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。</span><br><span class="line">            （例如，<span class="string">"ACE"</span> 是 <span class="string">"ABCDE"</span> 的一个子序列，而 <span class="string">"AEC"</span> 不是</span><br><span class="line">            动态规划和递归的区别:</span><br><span class="line">                <span class="keyword">dp</span>是一种不带重复计算的递归，想出<span class="keyword">dp</span>往往也是像想出递归那样，都需要从子问题入手，正确定义子问题，递归想出结束条件，</span><br><span class="line">                <span class="keyword">dp</span>想出base case，递归想出递归公式，<span class="keyword">dp</span>想出递推公式。递归加入记忆化后，</span><br><span class="line">                往往稍作修改，就是<span class="keyword">dp</span>的解法</span><br><span class="line"></span><br><span class="line">            考虑使用二维动态规划</span><br><span class="line">            <span class="keyword">dp</span>[i][<span class="keyword">j</span>]：从开头到s[i-<span class="number">1</span>]的子串中，出现『从开头到t[<span class="keyword">j</span>-<span class="number">1</span>]的子串』的 次数。</span><br><span class="line">            即：前i个字符的s子串中，出现前<span class="keyword">j</span>个字符的t子串的次数。</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        len_s = <span class="built_in">len</span>(s)</span><br><span class="line">        len_t = <span class="built_in">len</span>(t)</span><br><span class="line">        <span class="keyword">dp</span> = [[<span class="number">0</span>] * (len_s + <span class="number">1</span>) <span class="keyword">for</span> i in <span class="built_in">range</span>(len_t+<span class="number">1</span>)] # 生成<span class="keyword">dp</span>数组, +<span class="number">1</span>是为了考虑空串的情况</span><br><span class="line">        # <span class="keyword">print</span>(<span class="keyword">dp</span>)</span><br><span class="line">        # 当t的子字符串为空字符串时</span><br><span class="line">        <span class="keyword">for</span> i in <span class="built_in">range</span>(len_s + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">dp</span>[<span class="number">0</span>][i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="number">1</span>,len_t+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> <span class="keyword">j</span> in <span class="built_in">range</span>(<span class="number">1</span>,len_s+<span class="number">1</span>):</span><br><span class="line">                # 当s的子字符串为空字符串时</span><br><span class="line">                # s为空串，无论怎么删去元素，s还是无法变成t</span><br><span class="line">                # 处理其他情况</span><br><span class="line">                # 数组i不变<span class="keyword">j</span>+<span class="number">1</span>的时候，这时就相当于s增加了一个元素，以s=<span class="string">'ba'</span> t=<span class="string">'b'</span>为例</span><br><span class="line">                # 此时<span class="keyword">dp</span>[<span class="number">1</span>][<span class="number">2</span>]=<span class="number">1</span>，<span class="keyword">j</span>要加<span class="number">1</span>变成<span class="keyword">dp</span>[<span class="number">1</span>][<span class="number">3</span>]了，这时s就变成了<span class="string">'bab'</span></span><br><span class="line">                # 因此需要判断t[i]和新增的s[<span class="keyword">j</span>+<span class="number">1</span>]是否相等，如果不等的话，则<span class="keyword">dp</span>[i][<span class="keyword">j</span>+<span class="number">1</span>]=<span class="keyword">dp</span>[i][<span class="keyword">j</span>]</span><br><span class="line">                # 如果相等的话，同时去掉i和<span class="keyword">j</span>+<span class="number">1</span>分别看剩下的s和t是否有多个匹配，因此<span class="keyword">dp</span>[i][<span class="keyword">j</span>+<span class="number">1</span>] = <span class="keyword">dp</span>[i][<span class="keyword">j</span>]+<span class="keyword">dp</span>[i-<span class="number">1</span>][<span class="keyword">j</span>]</span><br><span class="line">                <span class="keyword">if</span> s[<span class="keyword">j</span>-<span class="number">1</span>] == t[i-<span class="number">1</span>]: # -<span class="number">1</span>是因为上面循环算上了<span class="string">""</span>字符串的情况</span><br><span class="line">                    <span class="keyword">dp</span>[i][<span class="keyword">j</span>] = <span class="keyword">dp</span>[i][<span class="keyword">j</span>-<span class="number">1</span>] + <span class="keyword">dp</span>[i-<span class="number">1</span>][<span class="keyword">j</span>-<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">dp</span>[i][<span class="keyword">j</span>] = <span class="keyword">dp</span>[i][<span class="keyword">j</span>-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">dp</span>[-<span class="number">1</span>][-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    <span class="keyword">print</span>(s.numDistinct(s = <span class="string">"rabbbit"</span>, t = <span class="string">"rabbit"</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第115题—不同的子序列&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)&lt;/p
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.114</title>
    <link href="www.strivezs.com/2021/05/21/LeetCode%E7%AC%AC114%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/21/LeetCode%E7%AC%AC114%E9%A2%98/</id>
    <published>2021-05-21T15:39:58.907Z</published>
    <updated>2021-05-21T15:39:58.907Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第114题—二叉树展开为链表</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给你二叉树的根结点 root ，请你将它展开为一个单链表：</p><p>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。<br>展开后的单链表应该与二叉树 先序遍历 顺序相同。</p><p><img src="https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg" alt="figure.1"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="number">6</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="literal">null</span>,<span class="number">2</span>,<span class="literal">null</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="number">5</span>,<span class="literal">null</span>,<span class="number">6</span>]</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">0</span>]</span><br><span class="line">输出：[<span class="number">0</span>]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">树中结点数在范围 [<span class="number">0</span>, <span class="number">2000</span>] 内</span><br><span class="line"><span class="number">-100</span> &lt;= Node.val &lt;= <span class="number">100</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val=<span class="number">0</span>, left=None, right=None)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flatten</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.flatten(root.left)</span><br><span class="line">        self.flatten(root.right)</span><br><span class="line"></span><br><span class="line">        right = root.right</span><br><span class="line">        <span class="comment"># 将左子树替换掉右子树</span></span><br><span class="line">        root.right = root.left</span><br><span class="line">        root.left = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 找到右子树最右的节点，接上原右子树</span></span><br><span class="line">        p = root</span><br><span class="line">        <span class="keyword">while</span> (p.right != <span class="literal">None</span>):</span><br><span class="line">            p = p.right</span><br><span class="line">        p.right = right</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第114题—二叉树展开为链表&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)&lt;
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.113</title>
    <link href="www.strivezs.com/2021/05/19/LeetCode%E7%AC%AC113%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/19/LeetCode%E7%AC%AC113%E9%A2%98/</id>
    <published>2021-05-19T12:10:21.212Z</published>
    <updated>2021-05-19T12:10:21.212Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第113题—路径总和II</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p><p>叶子节点 是指没有子节点的节点。</p><p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsumii1.jpg" alt="figure.1"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="literal">null</span>,<span class="number">13</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">5</span>,<span class="number">1</span>], targetSum = <span class="number">22</span></span><br><span class="line">输出：[[<span class="number">5</span>,<span class="number">4</span>,<span class="number">11</span>,<span class="number">2</span>],[<span class="number">5</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>]]</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg" alt="figure.2"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], targetSum = <span class="number">5</span></span><br><span class="line">输出：[]</span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>], targetSum = <span class="number">0</span></span><br><span class="line">输出：[]</span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">树中节点总数在范围 [<span class="number">0</span>, <span class="number">5000</span>] 内</span><br><span class="line"><span class="number">-1000</span> &lt;= Node.val &lt;= <span class="number">1000</span></span><br><span class="line"><span class="number">-1000</span> &lt;= targetSum &lt;= <span class="number">1000</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><p>在上一题的基础上，引入了一个记录路径的数组，这里面不知道为什么</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.sum<span class="constructor">Path(<span class="params">node</span>.<span class="params">right</span>, <span class="params">curSum</span> + <span class="params">node</span>.<span class="params">val</span>, <span class="params">targetSum</span>, <span class="params">curPath</span>.<span class="params">append</span>(<span class="params">node</span>.<span class="params">val</span>)</span>)</span><br></pre></td></tr></table></figure><p>会报错，因此这里使用了temp列表来最后和curPaht+temp来得到下一层的路径。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">python</span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val=<span class="number">0</span>, left=None, right=None)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    pathList = [] <span class="comment"># 路径集合</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumPath</span><span class="params">(self, node, curSum, targetSum, curPath)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        temp = []</span><br><span class="line">        temp.append(node.val)</span><br><span class="line">        <span class="comment"># 如果到达叶子节点，则进行总和判断</span></span><br><span class="line">        <span class="keyword">if</span> node.left == <span class="literal">None</span> <span class="keyword">and</span> node.right == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> curSum + node.val == targetSum:</span><br><span class="line">                self.pathList.append(curPath + temp)</span><br><span class="line">        self.sumPath(node.left, curSum + node.val, targetSum,curPath + temp)</span><br><span class="line">        self.sumPath(node.right, curSum + node.val, targetSum, curPath + temp)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span><span class="params">(self, root, targetSum)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type targetSum: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">            采用DFS，每当遇到叶子结点，就去计算当前路径总和，如果等于targetSum, 则将路径添加进去</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.pathList = []</span><br><span class="line">        self.sumPath(root, <span class="number">0</span>, targetSum, [])</span><br><span class="line">        <span class="keyword">return</span> self.pathList</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    root = TreeNode(<span class="number">5</span>)</span><br><span class="line">    node1 = TreeNode(<span class="number">4</span>)</span><br><span class="line">    node2 = TreeNode(<span class="number">11</span>)</span><br><span class="line">    node3 = TreeNode(<span class="number">7</span>)</span><br><span class="line">    node4 = TreeNode(<span class="number">2</span>)</span><br><span class="line">    node5 = TreeNode(<span class="number">8</span>)</span><br><span class="line">    node6 = TreeNode(<span class="number">13</span>)</span><br><span class="line">    node7 = TreeNode(<span class="number">4</span>)</span><br><span class="line">    node8 = TreeNode(<span class="number">5</span>)</span><br><span class="line">    node9 = TreeNode(<span class="number">1</span>)</span><br><span class="line">    root.left = node1</span><br><span class="line">    node1.left = node2</span><br><span class="line">    node2.left = node3</span><br><span class="line">    node2.right = node4</span><br><span class="line">    root.right = node5</span><br><span class="line">    node5.left = node6</span><br><span class="line">    node5.right = node7</span><br><span class="line">    node7.left = node8</span><br><span class="line">    node7.right = node9</span><br><span class="line"></span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.pathSum(root,<span class="number">22</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第113题—路径总和II&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)&lt;/p
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>实现Vue和Flask通信</title>
    <link href="www.strivezs.com/2021/05/18/%E5%AE%9E%E7%8E%B0Vue%E5%92%8CFlask%E9%80%9A%E4%BF%A1/"/>
    <id>www.strivezs.com/2021/05/18/%E5%AE%9E%E7%8E%B0Vue%E5%92%8CFlask%E9%80%9A%E4%BF%A1/</id>
    <published>2021-05-18T09:31:24.853Z</published>
    <updated>2021-05-18T09:31:24.853Z</updated>
    
    <content type="html"><![CDATA[<h1>实现Vue和Flask通信</h1><h2 id="安装axios和实现通信"><a class="header-anchor" href="#安装axios和实现通信">¶</a>安装axios和实现通信</h2><p>这里我们通过axios来连接Vue前端和Flask后端，使用AJAX请求进行通信。使用如下命令安装</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> axios</span><br></pre></td></tr></table></figure><p>axios的使用格式:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        serverResponse: <span class="string">'res_test'</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      getData() &#123;</span><br><span class="line">        <span class="comment">// 设置对应python的接口，这里使用的是localhost:5000</span></span><br><span class="line">        <span class="keyword">const</span> path = <span class="string">'http://127.0.0.1:5000/getMsg'</span>;</span><br><span class="line">        <span class="comment">// 这里要使用 res =&gt;表示返回的数据</span></span><br><span class="line">        axios.get(path).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 这里服务器返回response为一个json对象</span></span><br><span class="line">          <span class="comment">// 通过.data来访返回的数据，然后在通过.变量名进行访问</span></span><br><span class="line">          <span class="comment">// 可以直接通过response.data取得key-value</span></span><br><span class="line">          <span class="keyword">var</span> msg = res.data.msg;</span><br><span class="line">          <span class="keyword">this</span>.serverResponse = msg; <span class="comment">// 因为不能直接使用this作为指针，因此在这之前将this赋给了then指针</span></span><br><span class="line">          alter(<span class="string">'Success'</span> + response.status + <span class="string">','</span> + response.data + <span class="string">','</span> + msg); <span class="comment">// 成功后显示提示</span></span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.error(error);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="代码及演示"><a class="header-anchor" href="#代码及演示">¶</a>代码及演示</h2><h3 id="前端代码"><a class="header-anchor" href="#前端代码">¶</a>前端代码</h3><p>对./components/HelloWorld.vue文件进行改写。代码如下:</p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!-- html部分 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><span class="template-variable">&#123;&#123; serverResponse &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!--这里使用</span></span><span class="template-variable">&#123;&#123;&#125;&#125;</span><span class="xml"><span class="comment">来引用JavaScript中赋给this的值--&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"getData"</span>&gt;</span>get data<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- js部分 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">  import axios from 'axios';</span></span><br><span class="line"><span class="xml">  export default &#123;</span></span><br><span class="line"><span class="xml">    data: function () &#123;</span></span><br><span class="line"><span class="xml">      return &#123;</span></span><br><span class="line"><span class="xml">        serverResponse: 'res_test'</span></span><br><span class="line"><span class="xml">      &#125;;</span></span><br><span class="line"><span class="xml">    &#125;,</span></span><br><span class="line"><span class="xml">    methods: &#123;</span></span><br><span class="line"><span class="xml">      getData() &#123;</span></span><br><span class="line"><span class="xml">        // 设置对应python的接口，这里使用的是localhost:5000</span></span><br><span class="line"><span class="xml">        const path = 'http://127.0.0.1:5000/getMsg';</span></span><br><span class="line"><span class="xml">        axios.get(path).then(res =&gt; &#123;</span></span><br><span class="line"><span class="xml">          // 这里服务器返回response为一个json对象</span></span><br><span class="line"><span class="xml">          // 通过.data来访返回的数据，然后在通过.变量名进行访问</span></span><br><span class="line"><span class="xml">          // 可以直接通过response.data取得key-value</span></span><br><span class="line"><span class="xml">          var msg = res.data.msg;</span></span><br><span class="line"><span class="xml">          this.serverResponse = msg; // 因为不能直接使用this作为指针，因此在这之前将this赋给了then指针</span></span><br><span class="line"><span class="xml">          alter('Success' + response.status + ',' + response.data + ',' + msg); // 成功后显示提示</span></span><br><span class="line"><span class="xml">        &#125;).catch(error =&gt; &#123;</span></span><br><span class="line"><span class="xml">          console.error(error);</span></span><br><span class="line"><span class="xml">        &#125;);</span></span><br><span class="line"><span class="xml">      &#125;</span></span><br><span class="line"><span class="xml">    &#125;,</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- css部分 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- Add "scoped" attribute to limit CSS to this component only --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span></span><br><span class="line"><span class="xml">  h1,</span></span><br><span class="line"><span class="xml">  h2 &#123;</span></span><br><span class="line"><span class="xml">    font-weight: normal;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="xml">  ul &#123;</span></span><br><span class="line"><span class="xml">    list-style-type: none;</span></span><br><span class="line"><span class="xml">    padding: 0;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="xml">  li &#123;</span></span><br><span class="line"><span class="xml">    display: inline-block;</span></span><br><span class="line"><span class="xml">    margin: 0 10px;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="xml">  a &#123;</span></span><br><span class="line"><span class="xml">    color: #42b983;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>这里主要实现了通过单击按钮来和服务器端进行交互获得数据并传回前端，将得到的数据重新来对前端进行渲染。</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/X6O7G9.png" alt="figure.1"></p><p>得到如上页面之后，我们单击get date按钮，就会像后端发送GET请求，后端服务器监听到请求之后就会返回对应的数据。</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/UZuYsL.png" alt="figure.2"></p><h3 id="客户端代码"><a class="header-anchor" href="#客户端代码">¶</a>客户端代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> jsonify</span><br><span class="line"><span class="keyword">from</span> flask_cors <span class="keyword">import</span> CORS</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">cors = CORS(app, resources=&#123;<span class="string">r"/getMsg"</span>: &#123;<span class="string">"origins"</span>: <span class="string">"*"</span>&#125;&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'test!'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 监听127.0.0.1:5000/getMsg请求</span></span><br><span class="line"><span class="meta">@app.route('/getMsg', methods=['GET', 'POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">home</span><span class="params">()</span>:</span></span><br><span class="line">    response = &#123;</span><br><span class="line">        <span class="string">'msg'</span>: <span class="string">'Hello, Python !'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;实现Vue和Flask通信&lt;/h1&gt;
&lt;h2 id=&quot;安装axios和实现通信&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#安装axios和实现通信&quot;&gt;¶&lt;/a&gt;安装axios和实现通信&lt;/h2&gt;
&lt;p&gt;这里我们通过axios来连接Vue前端和Fla
      
    
    </summary>
    
    
      <category term="Python" scheme="www.strivezs.com/categories/Python/"/>
    
      <category term="JavaScript" scheme="www.strivezs.com/categories/Python/JavaScript/"/>
    
    
      <category term="Python" scheme="www.strivezs.com/tags/Python/"/>
    
      <category term="JavaScript" scheme="www.strivezs.com/tags/JavaScript/"/>
    
      <category term="Vue" scheme="www.strivezs.com/tags/Vue/"/>
    
      <category term="Flask" scheme="www.strivezs.com/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.112</title>
    <link href="www.strivezs.com/2021/05/18/LeetCode%E7%AC%AC112%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/18/LeetCode%E7%AC%AC112%E9%A2%98/</id>
    <published>2021-05-18T09:28:53.785Z</published>
    <updated>2021-05-18T09:28:53.785Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第112题—路径总和</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。</p><p>叶子节点 是指没有子节点的节点。</p><p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg" alt="figure.1"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="literal">null</span>,<span class="number">13</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">1</span>], targetSum = <span class="number">22</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg" alt="figure.2"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], targetSum = <span class="number">5</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>], targetSum = <span class="number">0</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">树中节点的数目在范围 [<span class="number">0</span>, <span class="number">5000</span>] 内</span><br><span class="line"><span class="number">-1000</span> &lt;= Node.val &lt;= <span class="number">1000</span></span><br><span class="line"><span class="number">-1000</span> &lt;= targetSum &lt;= <span class="number">1000</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><p>执行用时：44 ms, 在所有 Python3 提交中击败了94.71%的用户内存消耗：16.6 MB, 在所有 Python3 提交中击败了47.96%的用户</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val=<span class="number">0</span>, left=None, right=None)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    flag = <span class="literal">False</span> <span class="comment"># 全局标志：表示是否存在一条路径数值加和等于目标值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumPath</span><span class="params">(self, node, curSum, targetSum)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :param node: 当前节点</span></span><br><span class="line"><span class="string">        :param curSum: 到当前节点之前的节点数值总和</span></span><br><span class="line"><span class="string">        :param targetSum: 目标总和</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 如果到达叶子节点，则进行总和判断</span></span><br><span class="line">        <span class="keyword">if</span> node.left == <span class="literal">None</span> <span class="keyword">and</span> node.right == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> curSum + node.val == targetSum:</span><br><span class="line">                self.flag = <span class="literal">True</span></span><br><span class="line">        self.sumPath(node.left,curSum+node.val,targetSum)</span><br><span class="line">        self.sumPath(node.right, curSum + node.val, targetSum)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span><span class="params">(self, root, targetSum)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type targetSum: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">            采用DFS，每当遇到叶子结点，就去计算当前路径总和，如果等于targetSum就将全局标志flag设置为True</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.sumPath(root,<span class="number">0</span>,targetSum)</span><br><span class="line">        <span class="keyword">return</span> self.flag</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第112题—路径总和&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>MAC+PyCharm+Flask+Vue.js</title>
    <link href="www.strivezs.com/2021/05/17/MAC+PyCharm+Flask+Vue.js/"/>
    <id>www.strivezs.com/2021/05/17/MAC+PyCharm+Flask+Vue.js/</id>
    <published>2021-05-17T12:47:31.582Z</published>
    <updated>2021-05-17T12:47:31.582Z</updated>
    
    <content type="html"><![CDATA[<h1>MAC+PyCharm+Flask+Vue.js</h1><h2 id="配置node-js-nvm-npm"><a class="header-anchor" href="#配置node-js-nvm-npm">¶</a>配置node.js+nvm+npm</h2><p>访问github官方地址，根据官方的文档来安装Mac版本的nvm，<a href="https://github.com/nvm-sh/nvm">click here</a></p><p>这里建议用<a href="https://github.com/nvm-sh/nvm">nvm</a>安装管理Node.js</p><p><strong>cURL:</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -<span class="keyword">o</span>- http<span class="variable">s:</span>//raw.githubusercontent.<span class="keyword">com</span>/nvm-<span class="keyword">sh</span>/nvm/v0.<span class="number">35.2</span>/install.<span class="keyword">sh</span> | bash</span><br></pre></td></tr></table></figure><p><strong>Wget:</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -qO- http<span class="variable">s:</span>//raw.githubusercontent.<span class="keyword">com</span>/nvm-<span class="keyword">sh</span>/nvm/v0.<span class="number">35.2</span>/install.<span class="keyword">sh</span> | bash</span><br></pre></td></tr></table></figure><p>nvm安装好后，重启终端，然后安装Node.js：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">nvm ls-remote</span></span><br></pre></td></tr></table></figure><p>使用上述命令来查看远程node版本，然后根据需要安装最新版本的Nodejs：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm install <span class="number">15.3</span><span class="number">.0</span></span><br></pre></td></tr></table></figure><p>安装完成之后可以使用</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm <span class="built_in">list</span></span><br></pre></td></tr></table></figure><p>来查看已经安装的nodejs版本，并且使用</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm <span class="keyword">use</span> 版本号</span><br></pre></td></tr></table></figure><p>来使用对应版本的nodejs。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm use <span class="number">15.3</span><span class="number">.0</span></span><br></pre></td></tr></table></figure><p>可以使用如下命令查看当前node版本</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">node</span> <span class="title">-v</span></span><br></pre></td></tr></table></figure><h3 id="npm切换淘宝镜像"><a class="header-anchor" href="#npm切换淘宝镜像">¶</a>npm切换淘宝镜像</h3><h4 id="临时的"><a class="header-anchor" href="#临时的">¶</a>临时的</h4><p>临时使用的命令:</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">npm</span> --registry https:<span class="regexp">//</span>registry.<span class="built_in">npm</span>.taobao.org install express</span><br></pre></td></tr></table></figure><h4 id="长久的"><a class="header-anchor" href="#长久的">¶</a>长久的</h4><p>通过如下面命令：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="built_in">config</span> <span class="built_in">set</span> registry https:<span class="comment">//registry.npm.taobao.org</span></span><br></pre></td></tr></table></figure><p>配置完成之后，可以使用如下命令来得到当前的配置。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm<span class="built_in"> config </span><span class="builtin-name">get</span> registry</span><br></pre></td></tr></table></figure><h2 id="安装Vue-js"><a class="header-anchor" href="#安装Vue-js">¶</a>安装Vue.js</h2><p>这里我在我的node.js=15.3.0进行安装vue.js。</p><p>安装vue-cli脚手架构建工具:</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">npm</span> install -g @vue-cli</span><br><span class="line"><span class="built_in">npm</span> install -g @vue/cli-init</span><br></pre></td></tr></table></figure><p>在安装好输入如下命令验证是否成功:</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue --<span class="keyword">version</span> <span class="comment">// 如果有版本号，则证明安装成功了</span></span><br></pre></td></tr></table></figure><p>安装webpack:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> -g webpack</span><br></pre></td></tr></table></figure><h2 id="创建并运行Vue-js项目"><a class="header-anchor" href="#创建并运行Vue-js项目">¶</a>创建并运行Vue.js项目</h2><h3 id="在线初始化"><a class="header-anchor" href="#在线初始化">¶</a>在线初始化</h3><p>使用cd命令进入项目目录，然后使用如下命令来初始化项目(下载template):</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">vue init webpack visProject</span></span><br></pre></td></tr></table></figure><p>然后进入项目目录, 安装项目依赖得到node-modules目录:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span></span><br></pre></td></tr></table></figure><h3 id="离线方式"><a class="header-anchor" href="#离线方式">¶</a>离线方式</h3><p>由于使用上述方式，一直显示在downloading template，这里使用的是webpack作为template，因此我考虑使用离线的方式进行初始化。</p><p>首先先去下载webpack, 可以在gitee下载，下载链接:<a href="https://gitee.com/uyulnet/vuejs-templates-webpack">click here</a><br>下载完成之后，在用户目录下面中的隐藏文件中找一下是否有.vue-templates文件夹，如果没有的话使用如下命令创建一个</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> .vue-templates</span><br></pre></td></tr></table></figure><p>创建完成之后，将下载好的文件解压之后，改名成webpack，然后将文件夹放在该目录下。然后回到你之前的目录输入如下命令来离线初始化:</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue init webpack 项目名 <span class="comment">--offline</span></span><br></pre></td></tr></table></figure><p>初始化配置如下:</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/TR9kMI.png" alt="figure.1"></p><p>初始化之后使用如下命令，将当前执行环境添加到node_modules文件夹下:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span></span><br></pre></td></tr></table></figure><h3 id="运行项目"><a class="header-anchor" href="#运行项目">¶</a>运行项目</h3><p>在完成上述配置之后，使用cd进入项目文件夹，使用如下命令来对项目进行编译:</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">run</span><span class="bash"> dev</span></span><br></pre></td></tr></table></figure><p>编译完成之后, 就可以通过localhost来访问了。出现如下页面表示运行成功了.</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/2qh71D.png" alt="figure.3"></p><h2 id="src文件以及作用"><a class="header-anchor" href="#src文件以及作用">¶</a>src文件以及作用</h2><p><img src="https://gitee.com/zyp521/upload_image/raw/master/4fuyhq.png" alt="figure.4"></p><h3 id="解决打不开的问题"><a class="header-anchor" href="#解决打不开的问题">¶</a>解决打不开的问题</h3><p>这里由于默认的我8080端口被占用了，因此可以通过修改配置文件，来给它分配新的端口来解决。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">配置文件目录: ~/config/index.js</span><br><span class="line"></span><br><span class="line">将里面dev一类下的port对应的端口号修改为<span class="number">8083</span>即可.</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/zyp521/upload_image/raw/master/Ewtcd9.png" alt="figure.2"></p><p>然后使用下面命令重新进行编译即可:</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">run</span><span class="bash"> dev</span></span><br></pre></td></tr></table></figure><h2 id="配置Flask"><a class="header-anchor" href="#配置Flask">¶</a>配置Flask</h2><p>这里使用的IDE工具是：PyCharm，关于Python环境的搭建这里就不过多赘述了，网上有很多教程。</p><h3 id="安装Flask"><a class="header-anchor" href="#安装Flask">¶</a>安装Flask</h3><p>使用如下命令安装flask库: 这里我使用的是Anaconda进行包管理。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda <span class="keyword">install</span> flask</span><br></pre></td></tr></table></figure><p>但是这里，我使用PyCharm创建一个新的项目的话，可以选择直接创建一个flask项目，选择如下:</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/EvhLHQ.png" alt="figure.5"></p><p>这样的话，是会自动在选择的解释器中安装flask的。</p><p>这里我使用的前者，因此我需要手动安装flask，安装完之后，使用PyCharm来创建一个新的Flask项目，如上图所示，创建完成之后，我们会得到如下内容:</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/lyOMJX.png" alt="figure.6"></p><p>运行app.py文件，我们可以通过访问<a href="http://127.0.0.1:5000/">http://127.0.0.1:5000/</a>来得到一下界面。</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/LzX4hb.png" alt="figure.7"></p><p>这表明我们配置完成了。综上我们分别配置好了vue和flask，后面会接着将如何使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;MAC+PyCharm+Flask+Vue.js&lt;/h1&gt;
&lt;h2 id=&quot;配置node-js-nvm-npm&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#配置node-js-nvm-npm&quot;&gt;¶&lt;/a&gt;配置node.js+nvm+npm&lt;/h2&gt;

      
    
    </summary>
    
    
      <category term="MAC" scheme="www.strivezs.com/categories/MAC/"/>
    
      <category term="Python" scheme="www.strivezs.com/categories/MAC/Python/"/>
    
      <category term="JavaScript" scheme="www.strivezs.com/categories/MAC/Python/JavaScript/"/>
    
    
      <category term="Python" scheme="www.strivezs.com/tags/Python/"/>
    
      <category term="MAC" scheme="www.strivezs.com/tags/MAC/"/>
    
      <category term="PyCharm" scheme="www.strivezs.com/tags/PyCharm/"/>
    
      <category term="JavaScript" scheme="www.strivezs.com/tags/JavaScript/"/>
    
      <category term="Vue" scheme="www.strivezs.com/tags/Vue/"/>
    
      <category term="Flask" scheme="www.strivezs.com/tags/Flask/"/>
    
  </entry>
  
</feed>
