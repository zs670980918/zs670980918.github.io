<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>StriveZs的博客</title>
  
  <subtitle>Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="www.strivezs.com/"/>
  <updated>2021-05-28T13:14:32.685Z</updated>
  <id>www.strivezs.com/</id>
  
  <author>
    <name>StriveZs</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode No.121</title>
    <link href="www.strivezs.com/2021/05/28/LeetCode%E7%AC%AC121%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/28/LeetCode%E7%AC%AC121%E9%A2%98/</id>
    <published>2021-05-28T13:14:32.685Z</published>
    <updated>2021-05-28T13:14:32.685Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第121题—买卖股票的最佳时机</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p><p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：[<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：在第 <span class="number">2</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">5</span> 天（股票价格 = <span class="number">6</span>）的时候卖出，最大利润 = <span class="number">6</span><span class="number">-1</span> = <span class="number">5</span> 。</span><br><span class="line">     注意利润不能是 <span class="number">7</span><span class="number">-1</span> = <span class="number">6</span>, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：prices = [<span class="number">7</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：在这种情况下, 没有交易完成, 所以最大利润为 <span class="number">0</span>。</span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= prices.length &lt;= <span class="number">105</span></span><br><span class="line"><span class="number">0</span> &lt;= prices[i] &lt;= <span class="number">104</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        核心思想:</span></span><br><span class="line"><span class="string">            采用动态规划的方法</span></span><br><span class="line"><span class="string">            时间复杂度为O(n)</span></span><br><span class="line"><span class="string">            记录在i之前的最大利润，并和当前利润比较</span></span><br><span class="line"><span class="string">            记录i天之前的最小值</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(prices) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">0</span>] * len(prices)</span><br><span class="line">        min_value = prices[<span class="number">0</span>]</span><br><span class="line">        max_value = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(prices)):</span><br><span class="line">            max_value = max(max_value, prices[i] - min_value) <span class="comment"># 记录最大利润</span></span><br><span class="line">            min_value = min(min_value,prices[i]) <span class="comment"># 记录第i天之前的最小值</span></span><br><span class="line">        <span class="keyword">return</span> max_value</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.maxProfit([<span class="number">7</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>]))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第121题—买卖股票的最佳时机&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.120</title>
    <link href="www.strivezs.com/2021/05/27/LeetCode%E7%AC%AC120%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/27/LeetCode%E7%AC%AC120%E9%A2%98/</id>
    <published>2021-05-27T15:39:01.452Z</published>
    <updated>2021-05-27T15:39:01.452Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第120题—三角形最小路径和</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定一个三角形 triangle ，找出自顶向下的最小路径和。</p><p>每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。</p><p>示例 1：</p><p>输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]<br>输出：11<br>解释：如下面简图所示：<br>2<br>3 4<br>6 5 7<br>4 1 8 3<br>自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。<br>示例 2：</p><p>输入：triangle = [[-10]]<br>输出：-10</p><p>提示：</p><p>1 &lt;= triangle.length &lt;= 200<br>triangle[0].length == 1<br>triangle[i].length == triangle[i - 1].length + 1<br>-104 &lt;= triangle[i][j] &lt;= 104</p><p>进阶：</p><p>你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题吗？</p><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    maxSum = sys.maxsize <span class="comment"># 设置足底啊之</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">limit_dfs</span><span class="params">(self,triangle,j,iList,curSum,curDepth,depth)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :param triangle: List[List[Int]] 所有数值</span></span><br><span class="line"><span class="string">        :param j: Int 上一个节点的纵坐标</span></span><br><span class="line"><span class="string">        :param iList: List[Int] 当前节点所在的层</span></span><br><span class="line"><span class="string">        :param curParam: Int 当前层之前的路径和</span></span><br><span class="line"><span class="string">        :param curDepth: Int 当前深度</span></span><br><span class="line"><span class="string">        :param depth: 最大深度</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        t = iList[j]</span><br><span class="line">        curSum += iList[j]</span><br><span class="line">        <span class="keyword">if</span> depth == curDepth:</span><br><span class="line">            <span class="keyword">if</span> curSum &lt; self.maxSum:</span><br><span class="line">                self.maxSum = curSum</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.limit_dfs(triangle, j, triangle[curDepth+<span class="number">1</span>], curSum, curDepth+<span class="number">1</span>, depth)</span><br><span class="line">        <span class="keyword">if</span> j+<span class="number">1</span> &lt; len(triangle[curDepth+<span class="number">1</span>]):</span><br><span class="line">            self.limit_dfs(triangle, j+<span class="number">1</span>, triangle[curDepth + <span class="number">1</span>], curSum, curDepth+<span class="number">1</span>, depth)</span><br><span class="line">    <span class="comment"># 超时版本</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span><span class="params">(self, triangle)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        核心思想:</span></span><br><span class="line"><span class="string">            每个节点，只能访问它的[i+1][j]/[i+1][j+1] 两个节点</span></span><br><span class="line"><span class="string">            考虑采用递归来判断, 有点类似限制二叉树的访问方法</span></span><br><span class="line"><span class="string">        :type triangle: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int 返回最大值</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.limit_dfs(triangle,<span class="number">0</span>,triangle[<span class="number">0</span>],<span class="number">0</span>,<span class="number">0</span>,len(triangle)<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> self.maxSum</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 参考大佬的版本</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new_version</span><span class="params">(self,triangle)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(triangle) - <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                triangle[i - <span class="number">1</span>][j] += min(triangle[i][j], triangle[i][j + <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> triangle[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.minimumTotal([[<span class="number">-1</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-3</span>]]))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第120题—三角形最小路径和&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)&lt;
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.119</title>
    <link href="www.strivezs.com/2021/05/26/LeetCode%E7%AC%AC119%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/26/LeetCode%E7%AC%AC119%E9%A2%98/</id>
    <published>2021-05-26T14:10:06.243Z</published>
    <updated>2021-05-26T14:10:06.243Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第119题—杨辉三角II</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif" alt="fiogure.1"></p><p>在杨辉三角中，每个数是它左上方和右上方的数的和。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: <span class="number">3</span></span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    res = []  <span class="comment"># 全局结果</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># fixme: 递归分治生成数组</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">genrate_iList</span><span class="params">(self, pre_list, depth, goal_depth)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        采用递归分治的方法来生成每一层的数组</span></span><br><span class="line"><span class="string">        :param pre_list: List 上一层生成的数组</span></span><br><span class="line"><span class="string">        :param depth: Int 当前深度</span></span><br><span class="line"><span class="string">        :param goal_depth: Int 目标深度</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> depth == goal_depth + <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        temp = []</span><br><span class="line">        temp.append(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(pre_list) - <span class="number">1</span>):</span><br><span class="line">            temp.append(pre_list[i] + pre_list[i + <span class="number">1</span>])</span><br><span class="line">        temp.append(<span class="number">1</span>)</span><br><span class="line">        self.res.append(temp)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 递归调用</span></span><br><span class="line">        self.genrate_iList(temp, depth + <span class="number">1</span>, goal_depth)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRow</span><span class="params">(self, numRows)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type numRows: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">            由于每个值都是它上面两个值的加和，因此考虑为分治问题</span></span><br><span class="line"><span class="string">            考虑还是使用递归的方法，因此每次传入的数组就是上一次递归生成的数组.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.res = []</span><br><span class="line">        <span class="keyword">if</span> numRows == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.res</span><br><span class="line">        self.res.append([<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">if</span> numRows == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> self.res</span><br><span class="line">        self.res.append([<span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">if</span> numRows == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> self.res</span><br><span class="line">        self.genrate_iList([<span class="number">1</span>, <span class="number">1</span>], <span class="number">3</span>, numRows+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> self.res[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第119题—杨辉三角II&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)&lt;/p
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.118</title>
    <link href="www.strivezs.com/2021/05/24/LeetCode%E7%AC%AC118%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/24/LeetCode%E7%AC%AC118%E9%A2%98/</id>
    <published>2021-05-24T09:15:39.983Z</published>
    <updated>2021-05-24T09:15:39.983Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第118题—杨辉三角</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif" alt="figure.1"></p><p>在杨辉三角中，每个数是它左上方和右上方的数的和。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: <span class="number">5</span></span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">     [<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">   [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line"> [<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第118题—杨辉三角&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.117</title>
    <link href="www.strivezs.com/2021/05/24/LeetCode%E7%AC%AC117%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/24/LeetCode%E7%AC%AC117%E9%A2%98/</id>
    <published>2021-05-24T09:02:24.802Z</published>
    <updated>2021-05-24T09:02:24.802Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第117题—填充每个节点的下一个右侧节点指针II</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定一个二叉树</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct <span class="keyword">Node</span> <span class="title">&#123;</span></span><br><span class="line"><span class="title">  int</span> val;</span><br><span class="line">  <span class="keyword">Node</span> <span class="title">*left</span>;</span><br><span class="line">  <span class="keyword">Node</span> <span class="title">*right</span>;</span><br><span class="line">  <span class="keyword">Node</span> <span class="title">*next</span>;</span><br><span class="line">&#125;</span><br><span class="line">填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</span><br><span class="line"></span><br><span class="line">初始状态下，所有 next 指针都被设置为 NULL。</span><br><span class="line"></span><br><span class="line">进阶：</span><br><span class="line"></span><br><span class="line">你只能使用常量级额外空间。</span><br><span class="line">使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/15/117_sample.png" alt="figure.1"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="literal">null</span>,<span class="number">7</span>]</span><br><span class="line">输出：[<span class="number">1</span>,#,<span class="number">2</span>,<span class="number">3</span>,#,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,#]</span><br><span class="line">解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化输出按层序遍历顺序（由 next 指针连接），<span class="string">'#'</span> 表示每层的末尾。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">树中的节点数小于 <span class="number">6000</span></span><br><span class="line"><span class="number">-100</span> &lt;= node.val &lt;= <span class="number">100</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, val=<span class="number">0</span>, left=None, right=None, <span class="keyword">next</span>=None)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.val = val</span><br><span class="line">        <span class="keyword">self</span>.left = left</span><br><span class="line">        <span class="keyword">self</span>.right = right</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">next</span> = <span class="keyword">next</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="title">object</span>):</span></span><br><span class="line">    depth_dict = dict() <span class="comment"># 深度字典</span></span><br><span class="line">    <span class="comment"># fixme:采用bfs添加深度，将相同的深度放在同一个列表中</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(<span class="keyword">self</span>, node, depth)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        采用前序遍历</span></span><br><span class="line"><span class="string">        :param node: Node</span></span><br><span class="line"><span class="string">        :param depth: Int 深度</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        <span class="keyword">if</span> node == <span class="symbol">None:</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 创建深度层次</span></span><br><span class="line">        <span class="keyword">if</span> depth <span class="keyword">not</span> <span class="keyword">in</span> <span class="keyword">self</span>.depth_dict.keys()<span class="symbol">:</span></span><br><span class="line">            <span class="keyword">self</span>.depth_dict[depth] = list()</span><br><span class="line">        <span class="comment"># 处理在同一深度的节点</span></span><br><span class="line">        <span class="symbol">else:</span></span><br><span class="line">            <span class="comment"># 带记忆的处理方式，将链尾的值指向下一个同深度的节点</span></span><br><span class="line">            <span class="keyword">self</span>.depth_dict[depth][-<span class="number">1</span>].<span class="keyword">next</span> = node</span><br><span class="line">        <span class="keyword">self</span>.depth_dict[depth].append(node) <span class="comment"># 将结点存进去</span></span><br><span class="line">        <span class="keyword">self</span>.bfs(node.left,depth+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">self</span>.bfs(node.right,depth+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(<span class="keyword">self</span>, root)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        :type root: Node</span></span><br><span class="line"><span class="string">        :rtype: Node</span></span><br><span class="line"><span class="string">        核心思想:</span></span><br><span class="line"><span class="string">            和前面一题的代码一毛一样</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            类似DFS的感觉，将节点分层，一层的都添加到一个队列中。</span></span><br><span class="line"><span class="string">            可以考虑设置深度，将一个深度的放在同一个列表中，构建深度字典</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        depth_dict = dict() <span class="comment"># 深度词典初始化</span></span><br><span class="line">        <span class="keyword">self</span>.bfs(root,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第117题—填充每个节点的下一个右侧节点指针II&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Sta
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.116</title>
    <link href="www.strivezs.com/2021/05/23/LeetCode%E7%AC%AC116%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/23/LeetCode%E7%AC%AC116%E9%A2%98/</id>
    <published>2021-05-23T13:52:45.816Z</published>
    <updated>2021-05-23T13:52:45.816Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第116题—填充每个节点的下一个右侧节点指针</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct <span class="keyword">Node</span> <span class="title">&#123;</span></span><br><span class="line"><span class="title">  int</span> val;</span><br><span class="line">  <span class="keyword">Node</span> <span class="title">*left</span>;</span><br><span class="line">  <span class="keyword">Node</span> <span class="title">*right</span>;</span><br><span class="line">  <span class="keyword">Node</span> <span class="title">*next</span>;</span><br><span class="line">&#125;</span><br><span class="line">填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</span><br><span class="line"></span><br><span class="line">初始状态下，所有 next 指针都被设置为 NULL。</span><br><span class="line"></span><br><span class="line">进阶：</span><br><span class="line"></span><br><span class="line">你只能使用常量级额外空间。</span><br><span class="line">使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2019/02/14/116_sample.png" alt="figure.1"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">输出：[<span class="number">1</span>,#,<span class="number">2</span>,<span class="number">3</span>,#,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,#]</span><br><span class="line">解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，<span class="string">'#'</span> 标志着每一层的结束。</span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">树中节点的数量少于 <span class="number">4096</span></span><br><span class="line"><span class="number">-1000</span> &lt;= node.val &lt;= <span class="number">1000</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><p>采用带记忆的前序遍历即可。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, val=<span class="number">0</span>, left=None, right=None, <span class="keyword">next</span>=None)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.val = val</span><br><span class="line">        <span class="keyword">self</span>.left = left</span><br><span class="line">        <span class="keyword">self</span>.right = right</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">next</span> = <span class="keyword">next</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="title">object</span>):</span></span><br><span class="line">    depth_dict = dict() <span class="comment"># 深度字典</span></span><br><span class="line">    <span class="comment"># fixme:采用bfs添加深度，将相同的深度放在同一个列表中</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(<span class="keyword">self</span>, node, depth)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        采用前序遍历</span></span><br><span class="line"><span class="string">        :param node: Node</span></span><br><span class="line"><span class="string">        :param depth: Int 深度</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        <span class="keyword">if</span> node == <span class="symbol">None:</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 创建深度层次</span></span><br><span class="line">        <span class="keyword">if</span> depth <span class="keyword">not</span> <span class="keyword">in</span> <span class="keyword">self</span>.depth_dict.keys()<span class="symbol">:</span></span><br><span class="line">            <span class="keyword">self</span>.depth_dict[depth] = list()</span><br><span class="line">        <span class="comment"># 处理在同一深度的节点</span></span><br><span class="line">        <span class="symbol">else:</span></span><br><span class="line">            <span class="comment"># 带记忆的处理方式，将链尾的值指向下一个同深度的节点</span></span><br><span class="line">            <span class="keyword">self</span>.depth_dict[depth][-<span class="number">1</span>].<span class="keyword">next</span> = node</span><br><span class="line">        <span class="keyword">self</span>.depth_dict[depth].append(node) <span class="comment"># 将结点存进去</span></span><br><span class="line">        <span class="keyword">self</span>.bfs(node.left,depth+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">self</span>.bfs(node.right,depth+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(<span class="keyword">self</span>, root)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        :type root: Node</span></span><br><span class="line"><span class="string">        :rtype: Node</span></span><br><span class="line"><span class="string">        核心思想:</span></span><br><span class="line"><span class="string">            完美二叉树：它的所有叶子节点都在同一层，每个父结点都有两个叶子结点</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            类似DFS的感觉，将节点分层，一层的都添加到一个队列中。</span></span><br><span class="line"><span class="string">            可以考虑设置深度，将一个深度的放在同一个列表中，构建深度字典</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        depth_dict = dict() <span class="comment"># 深度词典初始化</span></span><br><span class="line">        <span class="keyword">self</span>.bfs(root,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第116题—填充每个节点的下一个右侧节点指针&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.115</title>
    <link href="www.strivezs.com/2021/05/22/LeetCode%E7%AC%AC115%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/22/LeetCode%E7%AC%AC115%E9%A2%98/</id>
    <published>2021-05-22T11:31:58.743Z</published>
    <updated>2021-05-22T11:31:58.743Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第115题—不同的子序列</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。</p><p>字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，“ACE” 是 “ABCDE” 的一个子序列，而 “AEC” 不是）</p><p>题目数据保证答案符合 32 位带符号整数范围。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"rabbbit"</span>, t = <span class="string">"rabbit"</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line">如下图所示, 有 <span class="number">3</span> 种可以从 s 中得到 <span class="string">"rabbit"</span> 的方案。</span><br><span class="line">(上箭头符号 ^ 表示选取的字母)</span><br><span class="line">rabbbit</span><br><span class="line">^^^^ ^^</span><br><span class="line">rabbbit</span><br><span class="line">^^ ^^^^</span><br><span class="line">rabbbit</span><br><span class="line">^^^ ^^^</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"babgbag"</span>, t = <span class="string">"bag"</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：</span><br><span class="line">如下图所示, 有 <span class="number">5</span> 种可以从 s 中得到 <span class="string">"bag"</span> 的方案。 </span><br><span class="line">(上箭头符号 ^ 表示选取的字母)</span><br><span class="line">babgbag</span><br><span class="line">^^ ^</span><br><span class="line">babgbag</span><br><span class="line">^^    ^</span><br><span class="line">babgbag</span><br><span class="line">^    ^^</span><br><span class="line">babgbag</span><br><span class="line">  ^  ^^</span><br><span class="line">babgbag</span><br><span class="line">    ^^^</span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> &lt;= s.length, t.length &lt;= <span class="number">1000</span></span><br><span class="line">s 和 t 由英文字母组成</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def numDistinct(self, s, t):</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        :<span class="built_in">type</span> <span class="variable">s:</span> str</span><br><span class="line">        :<span class="built_in">type</span> <span class="variable">t:</span> str</span><br><span class="line">        :rtype: <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">        核心思想:</span><br><span class="line"></span><br><span class="line">            字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。</span><br><span class="line">            （例如，<span class="string">"ACE"</span> 是 <span class="string">"ABCDE"</span> 的一个子序列，而 <span class="string">"AEC"</span> 不是</span><br><span class="line">            动态规划和递归的区别:</span><br><span class="line">                <span class="keyword">dp</span>是一种不带重复计算的递归，想出<span class="keyword">dp</span>往往也是像想出递归那样，都需要从子问题入手，正确定义子问题，递归想出结束条件，</span><br><span class="line">                <span class="keyword">dp</span>想出base case，递归想出递归公式，<span class="keyword">dp</span>想出递推公式。递归加入记忆化后，</span><br><span class="line">                往往稍作修改，就是<span class="keyword">dp</span>的解法</span><br><span class="line"></span><br><span class="line">            考虑使用二维动态规划</span><br><span class="line">            <span class="keyword">dp</span>[i][<span class="keyword">j</span>]：从开头到s[i-<span class="number">1</span>]的子串中，出现『从开头到t[<span class="keyword">j</span>-<span class="number">1</span>]的子串』的 次数。</span><br><span class="line">            即：前i个字符的s子串中，出现前<span class="keyword">j</span>个字符的t子串的次数。</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        len_s = <span class="built_in">len</span>(s)</span><br><span class="line">        len_t = <span class="built_in">len</span>(t)</span><br><span class="line">        <span class="keyword">dp</span> = [[<span class="number">0</span>] * (len_s + <span class="number">1</span>) <span class="keyword">for</span> i in <span class="built_in">range</span>(len_t+<span class="number">1</span>)] # 生成<span class="keyword">dp</span>数组, +<span class="number">1</span>是为了考虑空串的情况</span><br><span class="line">        # <span class="keyword">print</span>(<span class="keyword">dp</span>)</span><br><span class="line">        # 当t的子字符串为空字符串时</span><br><span class="line">        <span class="keyword">for</span> i in <span class="built_in">range</span>(len_s + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">dp</span>[<span class="number">0</span>][i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="number">1</span>,len_t+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> <span class="keyword">j</span> in <span class="built_in">range</span>(<span class="number">1</span>,len_s+<span class="number">1</span>):</span><br><span class="line">                # 当s的子字符串为空字符串时</span><br><span class="line">                # s为空串，无论怎么删去元素，s还是无法变成t</span><br><span class="line">                # 处理其他情况</span><br><span class="line">                # 数组i不变<span class="keyword">j</span>+<span class="number">1</span>的时候，这时就相当于s增加了一个元素，以s=<span class="string">'ba'</span> t=<span class="string">'b'</span>为例</span><br><span class="line">                # 此时<span class="keyword">dp</span>[<span class="number">1</span>][<span class="number">2</span>]=<span class="number">1</span>，<span class="keyword">j</span>要加<span class="number">1</span>变成<span class="keyword">dp</span>[<span class="number">1</span>][<span class="number">3</span>]了，这时s就变成了<span class="string">'bab'</span></span><br><span class="line">                # 因此需要判断t[i]和新增的s[<span class="keyword">j</span>+<span class="number">1</span>]是否相等，如果不等的话，则<span class="keyword">dp</span>[i][<span class="keyword">j</span>+<span class="number">1</span>]=<span class="keyword">dp</span>[i][<span class="keyword">j</span>]</span><br><span class="line">                # 如果相等的话，同时去掉i和<span class="keyword">j</span>+<span class="number">1</span>分别看剩下的s和t是否有多个匹配，因此<span class="keyword">dp</span>[i][<span class="keyword">j</span>+<span class="number">1</span>] = <span class="keyword">dp</span>[i][<span class="keyword">j</span>]+<span class="keyword">dp</span>[i-<span class="number">1</span>][<span class="keyword">j</span>]</span><br><span class="line">                <span class="keyword">if</span> s[<span class="keyword">j</span>-<span class="number">1</span>] == t[i-<span class="number">1</span>]: # -<span class="number">1</span>是因为上面循环算上了<span class="string">""</span>字符串的情况</span><br><span class="line">                    <span class="keyword">dp</span>[i][<span class="keyword">j</span>] = <span class="keyword">dp</span>[i][<span class="keyword">j</span>-<span class="number">1</span>] + <span class="keyword">dp</span>[i-<span class="number">1</span>][<span class="keyword">j</span>-<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">dp</span>[i][<span class="keyword">j</span>] = <span class="keyword">dp</span>[i][<span class="keyword">j</span>-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">dp</span>[-<span class="number">1</span>][-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    <span class="keyword">print</span>(s.numDistinct(s = <span class="string">"rabbbit"</span>, t = <span class="string">"rabbit"</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第115题—不同的子序列&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)&lt;/p
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.114</title>
    <link href="www.strivezs.com/2021/05/21/LeetCode%E7%AC%AC114%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/21/LeetCode%E7%AC%AC114%E9%A2%98/</id>
    <published>2021-05-21T15:39:58.907Z</published>
    <updated>2021-05-21T15:39:58.907Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第114题—二叉树展开为链表</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给你二叉树的根结点 root ，请你将它展开为一个单链表：</p><p>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。<br>展开后的单链表应该与二叉树 先序遍历 顺序相同。</p><p><img src="https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg" alt="figure.1"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="number">6</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="literal">null</span>,<span class="number">2</span>,<span class="literal">null</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="number">5</span>,<span class="literal">null</span>,<span class="number">6</span>]</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">0</span>]</span><br><span class="line">输出：[<span class="number">0</span>]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">树中结点数在范围 [<span class="number">0</span>, <span class="number">2000</span>] 内</span><br><span class="line"><span class="number">-100</span> &lt;= Node.val &lt;= <span class="number">100</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val=<span class="number">0</span>, left=None, right=None)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flatten</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.flatten(root.left)</span><br><span class="line">        self.flatten(root.right)</span><br><span class="line"></span><br><span class="line">        right = root.right</span><br><span class="line">        <span class="comment"># 将左子树替换掉右子树</span></span><br><span class="line">        root.right = root.left</span><br><span class="line">        root.left = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 找到右子树最右的节点，接上原右子树</span></span><br><span class="line">        p = root</span><br><span class="line">        <span class="keyword">while</span> (p.right != <span class="literal">None</span>):</span><br><span class="line">            p = p.right</span><br><span class="line">        p.right = right</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第114题—二叉树展开为链表&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)&lt;
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.113</title>
    <link href="www.strivezs.com/2021/05/19/LeetCode%E7%AC%AC113%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/19/LeetCode%E7%AC%AC113%E9%A2%98/</id>
    <published>2021-05-19T12:10:21.212Z</published>
    <updated>2021-05-19T12:10:21.212Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第113题—路径总和II</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p><p>叶子节点 是指没有子节点的节点。</p><p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsumii1.jpg" alt="figure.1"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="literal">null</span>,<span class="number">13</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">5</span>,<span class="number">1</span>], targetSum = <span class="number">22</span></span><br><span class="line">输出：[[<span class="number">5</span>,<span class="number">4</span>,<span class="number">11</span>,<span class="number">2</span>],[<span class="number">5</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>]]</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg" alt="figure.2"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], targetSum = <span class="number">5</span></span><br><span class="line">输出：[]</span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>], targetSum = <span class="number">0</span></span><br><span class="line">输出：[]</span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">树中节点总数在范围 [<span class="number">0</span>, <span class="number">5000</span>] 内</span><br><span class="line"><span class="number">-1000</span> &lt;= Node.val &lt;= <span class="number">1000</span></span><br><span class="line"><span class="number">-1000</span> &lt;= targetSum &lt;= <span class="number">1000</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><p>在上一题的基础上，引入了一个记录路径的数组，这里面不知道为什么</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.sum<span class="constructor">Path(<span class="params">node</span>.<span class="params">right</span>, <span class="params">curSum</span> + <span class="params">node</span>.<span class="params">val</span>, <span class="params">targetSum</span>, <span class="params">curPath</span>.<span class="params">append</span>(<span class="params">node</span>.<span class="params">val</span>)</span>)</span><br></pre></td></tr></table></figure><p>会报错，因此这里使用了temp列表来最后和curPaht+temp来得到下一层的路径。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">python</span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val=<span class="number">0</span>, left=None, right=None)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    pathList = [] <span class="comment"># 路径集合</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumPath</span><span class="params">(self, node, curSum, targetSum, curPath)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        temp = []</span><br><span class="line">        temp.append(node.val)</span><br><span class="line">        <span class="comment"># 如果到达叶子节点，则进行总和判断</span></span><br><span class="line">        <span class="keyword">if</span> node.left == <span class="literal">None</span> <span class="keyword">and</span> node.right == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> curSum + node.val == targetSum:</span><br><span class="line">                self.pathList.append(curPath + temp)</span><br><span class="line">        self.sumPath(node.left, curSum + node.val, targetSum,curPath + temp)</span><br><span class="line">        self.sumPath(node.right, curSum + node.val, targetSum, curPath + temp)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span><span class="params">(self, root, targetSum)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type targetSum: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">            采用DFS，每当遇到叶子结点，就去计算当前路径总和，如果等于targetSum, 则将路径添加进去</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.pathList = []</span><br><span class="line">        self.sumPath(root, <span class="number">0</span>, targetSum, [])</span><br><span class="line">        <span class="keyword">return</span> self.pathList</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    root = TreeNode(<span class="number">5</span>)</span><br><span class="line">    node1 = TreeNode(<span class="number">4</span>)</span><br><span class="line">    node2 = TreeNode(<span class="number">11</span>)</span><br><span class="line">    node3 = TreeNode(<span class="number">7</span>)</span><br><span class="line">    node4 = TreeNode(<span class="number">2</span>)</span><br><span class="line">    node5 = TreeNode(<span class="number">8</span>)</span><br><span class="line">    node6 = TreeNode(<span class="number">13</span>)</span><br><span class="line">    node7 = TreeNode(<span class="number">4</span>)</span><br><span class="line">    node8 = TreeNode(<span class="number">5</span>)</span><br><span class="line">    node9 = TreeNode(<span class="number">1</span>)</span><br><span class="line">    root.left = node1</span><br><span class="line">    node1.left = node2</span><br><span class="line">    node2.left = node3</span><br><span class="line">    node2.right = node4</span><br><span class="line">    root.right = node5</span><br><span class="line">    node5.left = node6</span><br><span class="line">    node5.right = node7</span><br><span class="line">    node7.left = node8</span><br><span class="line">    node7.right = node9</span><br><span class="line"></span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.pathSum(root,<span class="number">22</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第113题—路径总和II&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)&lt;/p
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>实现Vue和Flask通信</title>
    <link href="www.strivezs.com/2021/05/18/%E5%AE%9E%E7%8E%B0Vue%E5%92%8CFlask%E9%80%9A%E4%BF%A1/"/>
    <id>www.strivezs.com/2021/05/18/%E5%AE%9E%E7%8E%B0Vue%E5%92%8CFlask%E9%80%9A%E4%BF%A1/</id>
    <published>2021-05-18T09:31:24.853Z</published>
    <updated>2021-05-18T09:31:24.853Z</updated>
    
    <content type="html"><![CDATA[<h1>实现Vue和Flask通信</h1><h2 id="安装axios和实现通信"><a class="header-anchor" href="#安装axios和实现通信">¶</a>安装axios和实现通信</h2><p>这里我们通过axios来连接Vue前端和Flask后端，使用AJAX请求进行通信。使用如下命令安装</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> axios</span><br></pre></td></tr></table></figure><p>axios的使用格式:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        serverResponse: <span class="string">'res_test'</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      getData() &#123;</span><br><span class="line">        <span class="comment">// 设置对应python的接口，这里使用的是localhost:5000</span></span><br><span class="line">        <span class="keyword">const</span> path = <span class="string">'http://127.0.0.1:5000/getMsg'</span>;</span><br><span class="line">        <span class="comment">// 这里要使用 res =&gt;表示返回的数据</span></span><br><span class="line">        axios.get(path).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 这里服务器返回response为一个json对象</span></span><br><span class="line">          <span class="comment">// 通过.data来访返回的数据，然后在通过.变量名进行访问</span></span><br><span class="line">          <span class="comment">// 可以直接通过response.data取得key-value</span></span><br><span class="line">          <span class="keyword">var</span> msg = res.data.msg;</span><br><span class="line">          <span class="keyword">this</span>.serverResponse = msg; <span class="comment">// 因为不能直接使用this作为指针，因此在这之前将this赋给了then指针</span></span><br><span class="line">          alter(<span class="string">'Success'</span> + response.status + <span class="string">','</span> + response.data + <span class="string">','</span> + msg); <span class="comment">// 成功后显示提示</span></span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.error(error);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="代码及演示"><a class="header-anchor" href="#代码及演示">¶</a>代码及演示</h2><h3 id="前端代码"><a class="header-anchor" href="#前端代码">¶</a>前端代码</h3><p>对./components/HelloWorld.vue文件进行改写。代码如下:</p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!-- html部分 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><span class="template-variable">&#123;&#123; serverResponse &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!--这里使用</span></span><span class="template-variable">&#123;&#123;&#125;&#125;</span><span class="xml"><span class="comment">来引用JavaScript中赋给this的值--&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"getData"</span>&gt;</span>get data<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- js部分 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">  import axios from 'axios';</span></span><br><span class="line"><span class="xml">  export default &#123;</span></span><br><span class="line"><span class="xml">    data: function () &#123;</span></span><br><span class="line"><span class="xml">      return &#123;</span></span><br><span class="line"><span class="xml">        serverResponse: 'res_test'</span></span><br><span class="line"><span class="xml">      &#125;;</span></span><br><span class="line"><span class="xml">    &#125;,</span></span><br><span class="line"><span class="xml">    methods: &#123;</span></span><br><span class="line"><span class="xml">      getData() &#123;</span></span><br><span class="line"><span class="xml">        // 设置对应python的接口，这里使用的是localhost:5000</span></span><br><span class="line"><span class="xml">        const path = 'http://127.0.0.1:5000/getMsg';</span></span><br><span class="line"><span class="xml">        axios.get(path).then(res =&gt; &#123;</span></span><br><span class="line"><span class="xml">          // 这里服务器返回response为一个json对象</span></span><br><span class="line"><span class="xml">          // 通过.data来访返回的数据，然后在通过.变量名进行访问</span></span><br><span class="line"><span class="xml">          // 可以直接通过response.data取得key-value</span></span><br><span class="line"><span class="xml">          var msg = res.data.msg;</span></span><br><span class="line"><span class="xml">          this.serverResponse = msg; // 因为不能直接使用this作为指针，因此在这之前将this赋给了then指针</span></span><br><span class="line"><span class="xml">          alter('Success' + response.status + ',' + response.data + ',' + msg); // 成功后显示提示</span></span><br><span class="line"><span class="xml">        &#125;).catch(error =&gt; &#123;</span></span><br><span class="line"><span class="xml">          console.error(error);</span></span><br><span class="line"><span class="xml">        &#125;);</span></span><br><span class="line"><span class="xml">      &#125;</span></span><br><span class="line"><span class="xml">    &#125;,</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- css部分 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- Add "scoped" attribute to limit CSS to this component only --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span></span><br><span class="line"><span class="xml">  h1,</span></span><br><span class="line"><span class="xml">  h2 &#123;</span></span><br><span class="line"><span class="xml">    font-weight: normal;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="xml">  ul &#123;</span></span><br><span class="line"><span class="xml">    list-style-type: none;</span></span><br><span class="line"><span class="xml">    padding: 0;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="xml">  li &#123;</span></span><br><span class="line"><span class="xml">    display: inline-block;</span></span><br><span class="line"><span class="xml">    margin: 0 10px;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="xml">  a &#123;</span></span><br><span class="line"><span class="xml">    color: #42b983;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>这里主要实现了通过单击按钮来和服务器端进行交互获得数据并传回前端，将得到的数据重新来对前端进行渲染。</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/X6O7G9.png" alt="figure.1"></p><p>得到如上页面之后，我们单击get date按钮，就会像后端发送GET请求，后端服务器监听到请求之后就会返回对应的数据。</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/UZuYsL.png" alt="figure.2"></p><h3 id="客户端代码"><a class="header-anchor" href="#客户端代码">¶</a>客户端代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> jsonify</span><br><span class="line"><span class="keyword">from</span> flask_cors <span class="keyword">import</span> CORS</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">cors = CORS(app, resources=&#123;<span class="string">r"/getMsg"</span>: &#123;<span class="string">"origins"</span>: <span class="string">"*"</span>&#125;&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'test!'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 监听127.0.0.1:5000/getMsg请求</span></span><br><span class="line"><span class="meta">@app.route('/getMsg', methods=['GET', 'POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">home</span><span class="params">()</span>:</span></span><br><span class="line">    response = &#123;</span><br><span class="line">        <span class="string">'msg'</span>: <span class="string">'Hello, Python !'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;实现Vue和Flask通信&lt;/h1&gt;
&lt;h2 id=&quot;安装axios和实现通信&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#安装axios和实现通信&quot;&gt;¶&lt;/a&gt;安装axios和实现通信&lt;/h2&gt;
&lt;p&gt;这里我们通过axios来连接Vue前端和Fla
      
    
    </summary>
    
    
      <category term="Python" scheme="www.strivezs.com/categories/Python/"/>
    
      <category term="JavaScript" scheme="www.strivezs.com/categories/Python/JavaScript/"/>
    
    
      <category term="Python" scheme="www.strivezs.com/tags/Python/"/>
    
      <category term="JavaScript" scheme="www.strivezs.com/tags/JavaScript/"/>
    
      <category term="Vue" scheme="www.strivezs.com/tags/Vue/"/>
    
      <category term="Flask" scheme="www.strivezs.com/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.112</title>
    <link href="www.strivezs.com/2021/05/18/LeetCode%E7%AC%AC112%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/18/LeetCode%E7%AC%AC112%E9%A2%98/</id>
    <published>2021-05-18T09:28:53.785Z</published>
    <updated>2021-05-18T09:28:53.785Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第112题—路径总和</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。</p><p>叶子节点 是指没有子节点的节点。</p><p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg" alt="figure.1"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="literal">null</span>,<span class="number">13</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">1</span>], targetSum = <span class="number">22</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg" alt="figure.2"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], targetSum = <span class="number">5</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>], targetSum = <span class="number">0</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">树中节点的数目在范围 [<span class="number">0</span>, <span class="number">5000</span>] 内</span><br><span class="line"><span class="number">-1000</span> &lt;= Node.val &lt;= <span class="number">1000</span></span><br><span class="line"><span class="number">-1000</span> &lt;= targetSum &lt;= <span class="number">1000</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><p>执行用时：44 ms, 在所有 Python3 提交中击败了94.71%的用户内存消耗：16.6 MB, 在所有 Python3 提交中击败了47.96%的用户</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val=<span class="number">0</span>, left=None, right=None)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    flag = <span class="literal">False</span> <span class="comment"># 全局标志：表示是否存在一条路径数值加和等于目标值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumPath</span><span class="params">(self, node, curSum, targetSum)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :param node: 当前节点</span></span><br><span class="line"><span class="string">        :param curSum: 到当前节点之前的节点数值总和</span></span><br><span class="line"><span class="string">        :param targetSum: 目标总和</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 如果到达叶子节点，则进行总和判断</span></span><br><span class="line">        <span class="keyword">if</span> node.left == <span class="literal">None</span> <span class="keyword">and</span> node.right == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> curSum + node.val == targetSum:</span><br><span class="line">                self.flag = <span class="literal">True</span></span><br><span class="line">        self.sumPath(node.left,curSum+node.val,targetSum)</span><br><span class="line">        self.sumPath(node.right, curSum + node.val, targetSum)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span><span class="params">(self, root, targetSum)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type targetSum: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">            采用DFS，每当遇到叶子结点，就去计算当前路径总和，如果等于targetSum就将全局标志flag设置为True</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.sumPath(root,<span class="number">0</span>,targetSum)</span><br><span class="line">        <span class="keyword">return</span> self.flag</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第112题—路径总和&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>MAC+PyCharm+Flask+Vue.js</title>
    <link href="www.strivezs.com/2021/05/17/MAC+PyCharm+Flask+Vue.js/"/>
    <id>www.strivezs.com/2021/05/17/MAC+PyCharm+Flask+Vue.js/</id>
    <published>2021-05-17T12:47:31.582Z</published>
    <updated>2021-05-17T12:47:31.582Z</updated>
    
    <content type="html"><![CDATA[<h1>MAC+PyCharm+Flask+Vue.js</h1><h2 id="配置node-js-nvm-npm"><a class="header-anchor" href="#配置node-js-nvm-npm">¶</a>配置node.js+nvm+npm</h2><p>访问github官方地址，根据官方的文档来安装Mac版本的nvm，<a href="https://github.com/nvm-sh/nvm">click here</a></p><p>这里建议用<a href="https://github.com/nvm-sh/nvm">nvm</a>安装管理Node.js</p><p><strong>cURL:</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -<span class="keyword">o</span>- http<span class="variable">s:</span>//raw.githubusercontent.<span class="keyword">com</span>/nvm-<span class="keyword">sh</span>/nvm/v0.<span class="number">35.2</span>/install.<span class="keyword">sh</span> | bash</span><br></pre></td></tr></table></figure><p><strong>Wget:</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -qO- http<span class="variable">s:</span>//raw.githubusercontent.<span class="keyword">com</span>/nvm-<span class="keyword">sh</span>/nvm/v0.<span class="number">35.2</span>/install.<span class="keyword">sh</span> | bash</span><br></pre></td></tr></table></figure><p>nvm安装好后，重启终端，然后安装Node.js：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">nvm ls-remote</span></span><br></pre></td></tr></table></figure><p>使用上述命令来查看远程node版本，然后根据需要安装最新版本的Nodejs：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm install <span class="number">15.3</span><span class="number">.0</span></span><br></pre></td></tr></table></figure><p>安装完成之后可以使用</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm <span class="built_in">list</span></span><br></pre></td></tr></table></figure><p>来查看已经安装的nodejs版本，并且使用</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm <span class="keyword">use</span> 版本号</span><br></pre></td></tr></table></figure><p>来使用对应版本的nodejs。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm use <span class="number">15.3</span><span class="number">.0</span></span><br></pre></td></tr></table></figure><p>可以使用如下命令查看当前node版本</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">node</span> <span class="title">-v</span></span><br></pre></td></tr></table></figure><h3 id="npm切换淘宝镜像"><a class="header-anchor" href="#npm切换淘宝镜像">¶</a>npm切换淘宝镜像</h3><h4 id="临时的"><a class="header-anchor" href="#临时的">¶</a>临时的</h4><p>临时使用的命令:</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">npm</span> --registry https:<span class="regexp">//</span>registry.<span class="built_in">npm</span>.taobao.org install express</span><br></pre></td></tr></table></figure><h4 id="长久的"><a class="header-anchor" href="#长久的">¶</a>长久的</h4><p>通过如下面命令：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="built_in">config</span> <span class="built_in">set</span> registry https:<span class="comment">//registry.npm.taobao.org</span></span><br></pre></td></tr></table></figure><p>配置完成之后，可以使用如下命令来得到当前的配置。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm<span class="built_in"> config </span><span class="builtin-name">get</span> registry</span><br></pre></td></tr></table></figure><h2 id="安装Vue-js"><a class="header-anchor" href="#安装Vue-js">¶</a>安装Vue.js</h2><p>这里我在我的node.js=15.3.0进行安装vue.js。</p><p>安装vue-cli脚手架构建工具:</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">npm</span> install -g @vue-cli</span><br><span class="line"><span class="built_in">npm</span> install -g @vue/cli-init</span><br></pre></td></tr></table></figure><p>在安装好输入如下命令验证是否成功:</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue --<span class="keyword">version</span> <span class="comment">// 如果有版本号，则证明安装成功了</span></span><br></pre></td></tr></table></figure><p>安装webpack:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> -g webpack</span><br></pre></td></tr></table></figure><h2 id="创建并运行Vue-js项目"><a class="header-anchor" href="#创建并运行Vue-js项目">¶</a>创建并运行Vue.js项目</h2><h3 id="在线初始化"><a class="header-anchor" href="#在线初始化">¶</a>在线初始化</h3><p>使用cd命令进入项目目录，然后使用如下命令来初始化项目(下载template):</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">vue init webpack visProject</span></span><br></pre></td></tr></table></figure><p>然后进入项目目录, 安装项目依赖得到node-modules目录:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span></span><br></pre></td></tr></table></figure><h3 id="离线方式"><a class="header-anchor" href="#离线方式">¶</a>离线方式</h3><p>由于使用上述方式，一直显示在downloading template，这里使用的是webpack作为template，因此我考虑使用离线的方式进行初始化。</p><p>首先先去下载webpack, 可以在gitee下载，下载链接:<a href="https://gitee.com/uyulnet/vuejs-templates-webpack">click here</a><br>下载完成之后，在用户目录下面中的隐藏文件中找一下是否有.vue-templates文件夹，如果没有的话使用如下命令创建一个</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> .vue-templates</span><br></pre></td></tr></table></figure><p>创建完成之后，将下载好的文件解压之后，改名成webpack，然后将文件夹放在该目录下。然后回到你之前的目录输入如下命令来离线初始化:</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue init webpack 项目名 <span class="comment">--offline</span></span><br></pre></td></tr></table></figure><p>初始化配置如下:</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/TR9kMI.png" alt="figure.1"></p><p>初始化之后使用如下命令，将当前执行环境添加到node_modules文件夹下:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span></span><br></pre></td></tr></table></figure><h3 id="运行项目"><a class="header-anchor" href="#运行项目">¶</a>运行项目</h3><p>在完成上述配置之后，使用cd进入项目文件夹，使用如下命令来对项目进行编译:</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">run</span><span class="bash"> dev</span></span><br></pre></td></tr></table></figure><p>编译完成之后, 就可以通过localhost来访问了。出现如下页面表示运行成功了.</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/2qh71D.png" alt="figure.3"></p><h2 id="src文件以及作用"><a class="header-anchor" href="#src文件以及作用">¶</a>src文件以及作用</h2><p><img src="https://gitee.com/zyp521/upload_image/raw/master/4fuyhq.png" alt="figure.4"></p><h3 id="解决打不开的问题"><a class="header-anchor" href="#解决打不开的问题">¶</a>解决打不开的问题</h3><p>这里由于默认的我8080端口被占用了，因此可以通过修改配置文件，来给它分配新的端口来解决。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">配置文件目录: ~/config/index.js</span><br><span class="line"></span><br><span class="line">将里面dev一类下的port对应的端口号修改为<span class="number">8083</span>即可.</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/zyp521/upload_image/raw/master/Ewtcd9.png" alt="figure.2"></p><p>然后使用下面命令重新进行编译即可:</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">run</span><span class="bash"> dev</span></span><br></pre></td></tr></table></figure><h2 id="配置Flask"><a class="header-anchor" href="#配置Flask">¶</a>配置Flask</h2><p>这里使用的IDE工具是：PyCharm，关于Python环境的搭建这里就不过多赘述了，网上有很多教程。</p><h3 id="安装Flask"><a class="header-anchor" href="#安装Flask">¶</a>安装Flask</h3><p>使用如下命令安装flask库: 这里我使用的是Anaconda进行包管理。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda <span class="keyword">install</span> flask</span><br></pre></td></tr></table></figure><p>但是这里，我使用PyCharm创建一个新的项目的话，可以选择直接创建一个flask项目，选择如下:</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/EvhLHQ.png" alt="figure.5"></p><p>这样的话，是会自动在选择的解释器中安装flask的。</p><p>这里我使用的前者，因此我需要手动安装flask，安装完之后，使用PyCharm来创建一个新的Flask项目，如上图所示，创建完成之后，我们会得到如下内容:</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/lyOMJX.png" alt="figure.6"></p><p>运行app.py文件，我们可以通过访问<a href="http://127.0.0.1:5000/">http://127.0.0.1:5000/</a>来得到一下界面。</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/LzX4hb.png" alt="figure.7"></p><p>这表明我们配置完成了。综上我们分别配置好了vue和flask，后面会接着将如何使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;MAC+PyCharm+Flask+Vue.js&lt;/h1&gt;
&lt;h2 id=&quot;配置node-js-nvm-npm&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#配置node-js-nvm-npm&quot;&gt;¶&lt;/a&gt;配置node.js+nvm+npm&lt;/h2&gt;

      
    
    </summary>
    
    
      <category term="MAC" scheme="www.strivezs.com/categories/MAC/"/>
    
      <category term="Python" scheme="www.strivezs.com/categories/MAC/Python/"/>
    
      <category term="JavaScript" scheme="www.strivezs.com/categories/MAC/Python/JavaScript/"/>
    
    
      <category term="Python" scheme="www.strivezs.com/tags/Python/"/>
    
      <category term="MAC" scheme="www.strivezs.com/tags/MAC/"/>
    
      <category term="PyCharm" scheme="www.strivezs.com/tags/PyCharm/"/>
    
      <category term="JavaScript" scheme="www.strivezs.com/tags/JavaScript/"/>
    
      <category term="Vue" scheme="www.strivezs.com/tags/Vue/"/>
    
      <category term="Flask" scheme="www.strivezs.com/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.111</title>
    <link href="www.strivezs.com/2021/05/17/LeetCode%E7%AC%AC111%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/17/LeetCode%E7%AC%AC111%E9%A2%98/</id>
    <published>2021-05-17T09:10:29.457Z</published>
    <updated>2021-05-17T09:10:29.457Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第111题—二叉树的最小深度</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p>说明：叶子节点是指没有子节点的节点。</p><p><img src="https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg" alt="figure.1"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">2</span>,<span class="literal">null</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="number">5</span>,<span class="literal">null</span>,<span class="number">6</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">树中节点数的范围在 [<span class="number">0</span>, <span class="number">105</span>] 内</span><br><span class="line"><span class="number">-1000</span> &lt;= Node.val &lt;= <span class="number">1000</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><p>执行用时：944 ms, 在所有 Python 提交中击败了18.01%的用户内存消耗：92.5 MB, 在所有 Python 提交中击败了61.96%的用户</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val=<span class="number">0</span>, left=None, right=None)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    globalMinDepth = <span class="number">100000</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">depthSearch</span><span class="params">(self, node, depth)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 为叶子节点，进行深度判断</span></span><br><span class="line">        <span class="keyword">if</span> node.left == <span class="literal">None</span> <span class="keyword">and</span> node.right == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> depth &lt; self.globalMinDepth:</span><br><span class="line">                self.globalMinDepth = depth + <span class="number">1</span> <span class="comment"># +1的原因是因为这里的深度算当前的深度</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.depthSearch(node.left, depth+<span class="number">1</span>)</span><br><span class="line">        self.depthSearch(node.right, depth+<span class="number">1</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">            最小深度是从根节点到最近叶子节点的最短路径上的节点数量</span></span><br><span class="line"><span class="string">            使用DFS，设置一个全局最小深度，每当到达一个叶子结点就和当前全局最大深度进行比较</span></span><br><span class="line"><span class="string">            要确保节点是叶子节点</span></span><br><span class="line"><span class="string">            如果小于则更新全剧最小深度。</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        self.depthSearch(root,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.globalMinDepth</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    root = TreeNode(<span class="number">2</span>)</span><br><span class="line">    node1 = TreeNode(<span class="number">3</span>)</span><br><span class="line">    node2 = TreeNode(<span class="number">4</span>)</span><br><span class="line">    node3 = TreeNode(<span class="number">5</span>)</span><br><span class="line">    node4 = TreeNode(<span class="number">6</span>)</span><br><span class="line">    root.right = node1</span><br><span class="line">    node1.right = node2</span><br><span class="line">    node2.right = node3</span><br><span class="line">    node3.right = node4</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.minDepth(root))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第111题—二叉树的最小深度&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)&lt;
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.110</title>
    <link href="www.strivezs.com/2021/05/16/LeetCode%E7%AC%AC110%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/16/LeetCode%E7%AC%AC110%E9%A2%98/</id>
    <published>2021-05-16T03:48:58.100Z</published>
    <updated>2021-05-16T03:48:58.100Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第110题—平衡二叉树</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：</p><p>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg" alt="figure.1"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">2</span>：</span><br><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">4</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg" alt="figure.2"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：root = []</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">树中的节点数在范围 [<span class="number">0</span>, <span class="number">5000</span>] 内</span><br><span class="line"><span class="number">-104</span> &lt;= Node.val &lt;= <span class="number">104</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val=<span class="number">0</span>, left=None, right=None)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">depth</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        leftDepth = self.depth(node.left)</span><br><span class="line">        rightDepth = self.depth(node.right)</span><br><span class="line">        <span class="keyword">return</span> max(leftDepth,rightDepth)+<span class="number">1</span> <span class="comment"># 自底下上深度依次增加</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">            平衡二叉树是一棵每个节点的左右子树的高度差绝对值不超过1的树</span></span><br><span class="line"><span class="string">            判断方法的话，采用递归+深度的方法</span></span><br><span class="line"><span class="string">            这里还是考虑自底向上的方法</span></span><br><span class="line"><span class="string">            每往上一层的深度就增加1</span></span><br><span class="line"><span class="string">            采用先序遍历方法来遍历的话，这样就先确定左子树的深度，再确定右子树的深度</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            同样考虑使用分治的方法</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> abs(self.depth(root.left) - self.depth(root.right)) &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 分治处理每个子树</span></span><br><span class="line">        <span class="comment">## 处理左子树</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.isBalanced(root.left):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment">## 处理右子树</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.isBalanced(root.right):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    root = TreeNode(<span class="number">1</span>)</span><br><span class="line">    node1 = TreeNode(<span class="number">2</span>)</span><br><span class="line">    node2 = TreeNode(<span class="number">2</span>)</span><br><span class="line">    node3 = TreeNode(<span class="number">3</span>)</span><br><span class="line">    node4 = TreeNode(<span class="number">3</span>)</span><br><span class="line">    node5 = TreeNode(<span class="number">4</span>)</span><br><span class="line">    node6 = TreeNode(<span class="number">4</span>)</span><br><span class="line">    root.left = node1</span><br><span class="line">    root.right = node2</span><br><span class="line">    node1.left = node3</span><br><span class="line">    node1.right = node4</span><br><span class="line">    node3.left = node5</span><br><span class="line">    node3.right = node6</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.isBalanced(root))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第110题—平衡二叉树&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.109</title>
    <link href="www.strivezs.com/2021/05/16/LeetCode%E7%AC%AC109%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/16/LeetCode%E7%AC%AC109%E9%A2%98/</id>
    <published>2021-05-16T02:52:27.785Z</published>
    <updated>2021-05-16T02:52:27.785Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第109题—将有序链表转换为二叉搜索树</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">给定的有序链表： [<span class="number">-10</span>, <span class="number">-3</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">9</span>],</span><br><span class="line"></span><br><span class="line">一个可能的答案是：[<span class="number">0</span>, <span class="number">-3</span>, <span class="number">9</span>, <span class="number">-10</span>, <span class="literal">null</span>, <span class="number">5</span>], 它可以表示下面这个高度平衡二叉搜索树：</span><br><span class="line"></span><br><span class="line">      <span class="number">0</span></span><br><span class="line">     / \</span><br><span class="line">   <span class="number">-3</span>   <span class="number">9</span></span><br><span class="line">   /   /</span><br><span class="line"> <span class="number">-10</span>  <span class="number">5</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><p>两种办法，一种是非常蠢直接转换，但是十分不推荐，另一种是使用快慢指针寻找链表的中间节点的方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val=<span class="number">0</span>, next=None)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.next = next</span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val=<span class="number">0</span>, left=None, right=None)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">balancedBST</span><span class="params">(self,partNode)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">            我们需要将中间的节点作为根节点，这样就划分成一个分而治之的问题了</span></span><br><span class="line"><span class="string">            分治思想：每个划分的部分都是以中间节点作为当前子树的根节点</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(partNode) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(partNode[<span class="number">0</span>])</span><br><span class="line">        middle = int(len(partNode)/<span class="number">2</span>)</span><br><span class="line">        node = TreeNode(partNode[middle])</span><br><span class="line">        node.left = self.balancedBST(partNode[<span class="number">0</span>:middle])</span><br><span class="line">        <span class="keyword">if</span> middle == len(partNode)<span class="number">-1</span>:</span><br><span class="line">            node.right = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node.right = self.balancedBST(partNode[middle+<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nodeList2SortedList</span><span class="params">(self,node)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">            递归得到有序列表</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> node != <span class="literal">None</span>:</span><br><span class="line">            self.res.append(node.val)</span><br><span class="line">            self.nodeList2SortedList(node.next)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fastSlowPointer</span><span class="params">(self,head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">            快慢指针寻找链表中点，快指针走两步，慢指针走一步，这样当快指针走到结束时，就可以很容易的找到链表的中点</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> head.next == <span class="literal">None</span>: <span class="comment"># 下一个节点为null</span></span><br><span class="line">            <span class="keyword">return</span> TreeNode(head.val)</span><br><span class="line">        <span class="comment"># 快慢指针寻找中间节点</span></span><br><span class="line">        fastPointer = head</span><br><span class="line">        slowPointer = head</span><br><span class="line">        pre = <span class="literal">None</span> <span class="comment"># 用于划分左右子树</span></span><br><span class="line">        <span class="keyword">while</span> fastPointer != <span class="literal">None</span> <span class="keyword">and</span> fastPointer.next != <span class="literal">None</span>:</span><br><span class="line">            fastPointer = fastPointer.next.next</span><br><span class="line">            pre = slowPointer <span class="comment"># 最终得到中间节点的前一个节点，用于划分左右子树</span></span><br><span class="line">            slowPointer = slowPointer.next</span><br><span class="line">        pre.next = <span class="literal">None</span> <span class="comment"># 分割链表</span></span><br><span class="line">        <span class="comment"># 构造树以及左右子树</span></span><br><span class="line">        middleNode = TreeNode(slowPointer.val)</span><br><span class="line">        middleNode.left = self.fastSlowPointer(head) <span class="comment"># 左子树</span></span><br><span class="line">        middleNode.right = self.fastSlowPointer(slowPointer.next)</span><br><span class="line">        <span class="keyword">return</span> middleNode</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedListToBST</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">            高度平衡的二叉树：每个节点的左右子树的高度差绝对值不超过1</span></span><br><span class="line"><span class="string">            而且有要求是二叉搜索树，因此中序遍历要是升序</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            类似上一道题，这里我想一个比较蠢的办法就是将有序链表先转换为有序数组</span></span><br><span class="line"><span class="string">            然后在使用108题的方法，将有序数组转换为二叉搜索树</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            还有一个办法就是按照上一题的操作，只不过从计算列表中点，变成了找列表的中点</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        self.res = []</span><br><span class="line">        self.nodeList2SortedList(head)</span><br><span class="line">        <span class="keyword">return</span> self.balancedBST(self.res)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedListToBSTNewVersion</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">            高度平衡的二叉树：每个节点的左右子树的高度差绝对值不超过1</span></span><br><span class="line"><span class="string">            而且有要求是二叉搜索树，因此中序遍历要是升序</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            类似上一道题，这里我想一个比较蠢的办法就是将有序链表先转换为有序数组</span></span><br><span class="line"><span class="string">            然后在使用108题的方法，将有序数组转换为二叉搜索树</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            还有一个办法就是按照上一题的操作，只不过从计算列表中点，变成了找列表的中点</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.fastSlowPointer(head)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第109题—将有序链表转换为二叉搜索树&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和For
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.108</title>
    <link href="www.strivezs.com/2021/05/14/LeetCode%E7%AC%AC108%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/14/LeetCode%E7%AC%AC108%E9%A2%98/</id>
    <published>2021-05-14T05:11:38.179Z</published>
    <updated>2021-05-14T05:11:38.179Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第108题—将有序数组转换为二叉搜索树</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。</p><p>高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/r67QOX.jpg" alt="figure.1.1"></p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/lME5lp.jpg" alt="figure.1.2"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">-10</span>,<span class="number">-3</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">9</span>]</span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">-3</span>,<span class="number">9</span>,<span class="number">-10</span>,<span class="literal">null</span>,<span class="number">5</span>]</span><br><span class="line">解释：[<span class="number">0</span>,<span class="number">-10</span>,<span class="number">5</span>,<span class="literal">null</span>,<span class="number">-3</span>,<span class="literal">null</span>,<span class="number">9</span>] 也将被视为正确答案：</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/zyp521/upload_image/raw/master/kqM2k2.jpg" alt="figure.2"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">解释：[<span class="number">1</span>,<span class="number">3</span>] 和 [<span class="number">3</span>,<span class="number">1</span>] 都是高度平衡二叉搜索树。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= nums.length &lt;= <span class="number">104</span></span><br><span class="line"><span class="number">-104</span> &lt;= nums[i] &lt;= <span class="number">104</span></span><br><span class="line">nums 按 严格递增 顺序排列</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><p>执行用时：32 ms, 在所有 Python 提交中击败了59.87%的用户内存消耗：15.7 MB, 在所有 Python 提交中击败了52.76%的用户<br>经典分治思想</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val=<span class="number">0</span>, left=None, right=None)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">balancedBST</span><span class="params">(self,partNode)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(partNode) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(partNode[<span class="number">0</span>])</span><br><span class="line">        middle = int(len(partNode)/<span class="number">2</span>)</span><br><span class="line">        node = TreeNode(partNode[middle])</span><br><span class="line">        node.left = self.balancedBST(partNode[<span class="number">0</span>:middle])</span><br><span class="line">        <span class="keyword">if</span> middle == len(partNode)<span class="number">-1</span>:</span><br><span class="line">            node.right = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node.right = self.balancedBST(partNode[middle+<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedArrayToBST</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">            高度平衡的二叉树：每个节点的左右子树的高度差绝对值不超过1</span></span><br><span class="line"><span class="string">            而且有要求是二叉搜索树，因此中序遍历要是升序</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            综合上述条件，我们需要将中间的节点作为根节点，这样就划分成一个分而治之的问题了</span></span><br><span class="line"><span class="string">            分治思想：每个划分的部分都是以中间节点作为当前子树的根节点</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.balancedBST(nums)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第108题—将有序数组转换为二叉搜索树&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和For
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.107</title>
    <link href="www.strivezs.com/2021/05/13/LeetCode%E7%AC%AC107%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/13/LeetCode%E7%AC%AC107%E9%A2%98/</id>
    <published>2021-05-13T11:05:48.299Z</published>
    <updated>2021-05-13T11:05:48.299Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第107题—二叉树的层序遍历II</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定一个二叉树，返回其节点值自底向上的层序遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">给定二叉树 [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">15</span>,<span class="number">7</span>],</span><br><span class="line"></span><br><span class="line">    <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">9</span>  <span class="number">20</span></span><br><span class="line">    /  \</span><br><span class="line">   <span class="number">15</span>   <span class="number">7</span></span><br><span class="line">返回其自底向上的层序遍历为：</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [<span class="number">15</span>,<span class="number">7</span>],</span><br><span class="line">  [<span class="number">9</span>,<span class="number">20</span>],</span><br><span class="line">  [<span class="number">3</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><p>魔改102题就好了。直接reverse.<br>执行用时：40 ms, 在所有 Python3 提交中击败了76.52%的用户内存消耗：15.7 MB, 在所有 Python3 提交中击败了6.45%的用户</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, val=<span class="number">0</span>, left=None, right=None)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.val = val</span><br><span class="line">        <span class="keyword">self</span>.left = left</span><br><span class="line">        <span class="keyword">self</span>.right = right</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="title">object</span>):</span></span><br><span class="line">    res = dict()  <span class="comment"># 用字典存储对应深度的结果</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forwardSearch</span><span class="params">(<span class="keyword">self</span>, root, depth)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">if</span> root != <span class="symbol">None:</span></span><br><span class="line">            <span class="keyword">if</span> depth <span class="keyword">not</span> <span class="keyword">in</span> <span class="keyword">self</span>.res.keys()<span class="symbol">:</span></span><br><span class="line">                <span class="keyword">self</span>.res[depth] = []</span><br><span class="line">            <span class="keyword">self</span>.res[depth].append(root.val)</span><br><span class="line">            <span class="keyword">self</span>.forwardSearch(root.left, depth + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">self</span>.forwardSearch(root.right, depth + <span class="number">1</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrderBottom</span><span class="params">(<span class="keyword">self</span>, root)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">            延续二叉树的层序遍历第一期的思想</span></span><br><span class="line"><span class="string">            只不过是将最终得到的结果reverse就可以了。</span></span><br><span class="line"><span class="string">            同样是采用前序遍历，按照深度进行划分，只不过是从最大深度开始存储就可以了</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        <span class="keyword">self</span>.forwardSearch(root, <span class="number">1</span>)</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">self</span>.dic = dict()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">self</span>.res.keys()<span class="symbol">:</span></span><br><span class="line">            result.append(<span class="keyword">self</span>.res[i])</span><br><span class="line">        <span class="keyword">return</span> result[<span class="symbol">:</span><span class="symbol">:-</span><span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name_<span class="number">_</span> == <span class="string">'__main__'</span><span class="symbol">:</span></span><br><span class="line">    root = TreeNode(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.levelOrderBottom(root))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第107题—二叉树的层序遍历II&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.106</title>
    <link href="www.strivezs.com/2021/05/12/LeetCode%E7%AC%AC106%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/12/LeetCode%E7%AC%AC106%E9%A2%98/</id>
    <published>2021-05-12T15:25:25.531Z</published>
    <updated>2021-05-12T15:25:25.531Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第106题—从中序与后序遍历序列构造二叉树</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p><p>注意:<br>你可以假设树中没有重复的元素。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">例如，给出</span><br><span class="line"></span><br><span class="line">中序遍历 inorder = [<span class="number">9</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>]</span><br><span class="line">后序遍历 postorder = [<span class="number">9</span>,<span class="number">15</span>,<span class="number">7</span>,<span class="number">20</span>,<span class="number">3</span>]</span><br><span class="line">返回如下的二叉树：</span><br><span class="line"></span><br><span class="line">    <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">9</span>  <span class="number">20</span></span><br><span class="line">    /  \</span><br><span class="line">   <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><p>我只改了我105题一行代码。其实就是把后序遍历的节点从队尾读取，而对于前序遍历的话则是从队首读取就可以了</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, val=<span class="number">0</span>, left=None, right=None)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.val = val</span><br><span class="line">        <span class="keyword">self</span>.left = left</span><br><span class="line">        <span class="keyword">self</span>.right = right</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">irritationBuildTree</span><span class="params">(<span class="keyword">self</span>,postorder,inorder)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">if</span> len(postorder) == <span class="number">0</span>: <span class="comment"># 则证明没有根节点了</span></span><br><span class="line">            <span class="keyword">return</span> None</span><br><span class="line">        curRoot = postorder.pop() <span class="comment"># 获得当前子树根节点</span></span><br><span class="line">        node = TreeNode(curRoot) <span class="comment"># 生成节点</span></span><br><span class="line">        index = inorder.index(curRoot) <span class="comment"># 获得当前根节点在中序遍历中的位置，左边划分为左子树，右边为右子树</span></span><br><span class="line">        node.left = <span class="keyword">self</span>.irritationBuildTree(postorder[<span class="symbol">:index</span>],inorder[<span class="symbol">:index</span>]) <span class="comment"># 递归构建左子树</span></span><br><span class="line">        node.right = <span class="keyword">self</span>.irritationBuildTree(postorder[<span class="symbol">index:</span>],inorder[index+<span class="number">1</span><span class="symbol">:</span>]) <span class="comment"># 递归构建右子树</span></span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(<span class="keyword">self</span>, inorder, postorder)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        :type inorder: List[int]</span></span><br><span class="line"><span class="string">        :type postorder: List[int]</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">            类似上一道题，只不过从前序遍历变成了后序遍历</span></span><br><span class="line"><span class="string">            后序遍历的话，最后的元素为当前子树的根节点，其他的同理</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.irritationBuildTree(postorder, inorder)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第106题—从中序与后序遍历序列构造二叉树&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和F
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.105</title>
    <link href="www.strivezs.com/2021/05/11/LeetCode%E7%AC%AC105%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/11/LeetCode%E7%AC%AC105%E9%A2%98/</id>
    <published>2021-05-11T04:17:56.002Z</published>
    <updated>2021-05-11T04:17:56.002Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第105题—从前序与中序遍历序列构造二叉树</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>根据一棵树的前序遍历与中序遍历构造二叉树。</p><p>注意:<br>你可以假设树中没有重复的元素。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">例如，给出</span><br><span class="line"></span><br><span class="line">前序遍历 preorder = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">中序遍历 inorder = [<span class="number">9</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>]</span><br><span class="line">返回如下的二叉树：</span><br><span class="line"></span><br><span class="line">    <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">9</span>  <span class="number">20</span></span><br><span class="line">    /  \</span><br><span class="line">   <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, val=<span class="number">0</span>, left=None, right=None)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.val = val</span><br><span class="line">        <span class="keyword">self</span>.left = left</span><br><span class="line">        <span class="keyword">self</span>.right = right</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">irritationBuildTree</span><span class="params">(<span class="keyword">self</span>,preorder,inorder)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">if</span> len(preorder) == <span class="number">0</span>: <span class="comment"># 则证明没有根节点了</span></span><br><span class="line">            <span class="keyword">return</span> None</span><br><span class="line">        curRoot = preorder.pop(<span class="number">0</span>) <span class="comment"># 获得当前子树根节点</span></span><br><span class="line">        node = TreeNode(curRoot) <span class="comment"># 生成节点</span></span><br><span class="line">        index = inorder.index(curRoot) <span class="comment"># 获得当前根节点在中序遍历中的位置，左边划分为左子树，右边为右子树</span></span><br><span class="line">        node.left = <span class="keyword">self</span>.irritationBuildTree(preorder[<span class="symbol">:index</span>],inorder[<span class="symbol">:index</span>]) <span class="comment"># 递归构建左子树</span></span><br><span class="line">        node.right = <span class="keyword">self</span>.irritationBuildTree(preorder[<span class="symbol">index:</span>],inorder[index+<span class="number">1</span><span class="symbol">:</span>]) <span class="comment"># 递归构建右子树</span></span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(<span class="keyword">self</span>, preorder, inorder)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        :type preorder: List[int]</span></span><br><span class="line"><span class="string">        :type inorder: List[int]</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">            根据前序遍历和中序遍历来确定一颗二叉树</span></span><br><span class="line"><span class="string">            1.确定树的根节点,树根是当前树中所有元素在前序遍历中最先出现的元素。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            2.求解树的子树,找出根节点在中序遍历中的位置，根左边的所有元素就是左子树，</span></span><br><span class="line"><span class="string">            根右边的所有元素就是右子树。若根节点左边或右边为空，则该方向子树为空；</span></span><br><span class="line"><span class="string">            若根节点左边和右边都为空，则根节点已经为叶子节点。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            3.递归求解树,将左子树和右子树分别看成一棵二叉树，重复1、2、3步，直到所有的节点完成定位。</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.irritationBuildTree(preorder,inorder)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name_<span class="number">_</span> == <span class="string">'__main__'</span><span class="symbol">:</span></span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.irritationBuildTree([<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="number">15</span>,<span class="number">7</span>],[<span class="number">9</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>]))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第105题—从前序与中序遍历序列构造二叉树&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和F
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.104</title>
    <link href="www.strivezs.com/2021/05/10/LeetCode%E7%AC%AC104%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/10/LeetCode%E7%AC%AC104%E9%A2%98/</id>
    <published>2021-05-10T10:36:04.737Z</published>
    <updated>2021-05-10T10:36:04.737Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第104题—二叉树的最大深度</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">给定二叉树 [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">15</span>,<span class="number">7</span>]，</span><br><span class="line"></span><br><span class="line">    <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">9</span>  <span class="number">20</span></span><br><span class="line">    /  \</span><br><span class="line">   <span class="number">15</span>   <span class="number">7</span></span><br><span class="line">返回它的最大深度 <span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><p>执行用时：24 ms, 在所有 Python 提交中击败了92.24%的用户内存消耗：15.5 MB, 在所有 Python 提交中击败了85.16%的用户 深度遍历DFS，求深度</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, val=<span class="number">0</span>, left=None, right=None)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.val = val</span><br><span class="line">        <span class="keyword">self</span>.left = left</span><br><span class="line">        <span class="keyword">self</span>.right = right</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="title">object</span>):</span></span><br><span class="line">    maxdepth = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs_depth</span><span class="params">(<span class="keyword">self</span>,node,depth)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">if</span> node != <span class="symbol">None:</span></span><br><span class="line">            <span class="keyword">self</span>.dfs_depth(node.left,depth+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> depth &gt; <span class="keyword">self</span>.<span class="symbol">maxdepth:</span></span><br><span class="line">                <span class="keyword">self</span>.maxdepth = depth</span><br><span class="line">            <span class="keyword">self</span>.dfs_depth(node.right,depth+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(<span class="keyword">self</span>, root)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">            dfs遍历最大深度，效果最差</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        <span class="keyword">self</span>.dfs_depth(root,<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.maxdepth</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第104题—二叉树的最大深度&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)&lt;
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
</feed>
