<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>StriveZs的博客</title>
  
  
  <link href="/blogs/atom.xml" rel="self"/>
  
  <link href="https://zs670980918.github.io/blogs/"/>
  <updated>2019-12-27T05:16:59.137Z</updated>
  <id>https://zs670980918.github.io/blogs/</id>
  
  <author>
    <name>StriveZs</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>博客迁移</title>
    <link href="https://zs670980918.github.io/blogs/2019/12/27/%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB/"/>
    <id>https://zs670980918.github.io/blogs/2019/12/27/%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB/</id>
    <published>2019-12-27T05:16:59.136Z</published>
    <updated>2019-12-27T05:16:59.137Z</updated>
    
    <content type="html"><![CDATA[<h1 id="博客迁移-for-MAC"><a href="#博客迁移-for-MAC" class="headerlink" title="博客迁移 for MAC"></a>博客迁移 for MAC</h1><h2 id="第一步：导出wordpress内容"><a href="#第一步：导出wordpress内容" class="headerlink" title="第一步：导出wordpress内容"></a>第一步：导出wordpress内容</h2><p>进入WordPress后台的工具栏界面，将所有内容导出为一个XML文件。<br><img src="https://gitee.com/zyp521/upload_image/raw/master/8U0iSE.png" alt="1"></p><h2 id="第二步：安装Hexo"><a href="#第二步：安装Hexo" class="headerlink" title="第二步：安装Hexo"></a>第二步：安装Hexo</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><h4 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h4><p>这里建议用<a href="https://note.youdao.com/" target="_blank" rel="noopener">nvm</a>安装管理Node.js</p><p><strong>cURL:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o- https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;nvm-sh&#x2F;nvm&#x2F;v0.35.2&#x2F;install.sh | bash</span><br></pre></td></tr></table></figure><p><strong>Wget:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -qO- https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;nvm-sh&#x2F;nvm&#x2F;v0.35.2&#x2F;install.sh | bash</span><br></pre></td></tr></table></figure><p>nvm安装好后，重启终端，然后安装Node.js：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm ls-remote</span><br></pre></td></tr></table></figure><p>使用上述命令来查看远程node版本，然后根据需要安装具体的版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm install 13.5.0</span><br></pre></td></tr></table></figure><p>13.5.0是我安装的版本</p><h4 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h4><p>按照Github提示，创建SSH秘钥：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir ~&#x2F;.ssh #创建ssh命令</span><br><span class="line">$ cd ~&#x2F;.ssh</span><br><span class="line">$ ssh-keygen -t rsa -C &quot;your_email@example.com&quot; #注意更改Email地址</span><br><span class="line">$ pbcopy &lt; ~&#x2F;.ssh&#x2F;id_rsa.pub</span><br></pre></td></tr></table></figure><p>此时，pdcopy命令已经将id_rsa.pub内容复制到剪切板.<br><img src="https://gitee.com/zyp521/upload_image/raw/master/XhajaO.png" alt="2"><br>登录 github：<a href="https://github.com/settings/ssh" target="_blank" rel="noopener">https://github.com/settings/ssh</a> 点击Add an SSH Key，Title 部分填写一个所用电脑的名称，然后在Key部分填写之前通过pdcopy命令复制的内容。生成 key<br><img src="https://gitee.com/zyp521/upload_image/raw/master/b0shL0.png" alt="3"><br>上述内容操作完成之后，在终端输入如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;yourusername</span><br><span class="line">$ git config --global user.email &quot;youremail&quot;</span><br></pre></td></tr></table></figure><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p><a href="https://hexo.io/" target="_blank" rel="noopener">官网文档</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>如果报错的话，则加上sudo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h2 id="第三步：配置Hexo"><a href="#第三步：配置Hexo" class="headerlink" title="第三步：配置Hexo"></a>第三步：配置Hexo</h2><p>在本地创建你的博客文件夹，然后用命令行进入:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd 个人文件&#x2F;MyBlog</span><br></pre></td></tr></table></figure><p><strong>初始化文件夹设置：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p><strong>安装npm:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>初始化成功后，文件夹中会有如下东西：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml     #配置文件</span><br><span class="line">├── package.json    #应用程序数据</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source          #网站内容</span><br><span class="line">|   ├── _drafts     #草稿</span><br><span class="line">|   └── _posts      #文章</span><br><span class="line">└── themes          #主题</span><br></pre></td></tr></table></figure><h2 id="第四部：从WordPress迁移"><a href="#第四部：从WordPress迁移" class="headerlink" title="第四部：从WordPress迁移"></a>第四部：从WordPress迁移</h2><p>首先安装++hexo-migrator-wordpress++插件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-migrator-wordpress --save</span><br></pre></td></tr></table></figure><p>然后将wordpress导出的.xml文件放到当前目录下然后导出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo migrate wordpress wp-content.xml #名字自行替换</span><br></pre></td></tr></table></figure><p>这样内容就导入进去了。</p><h2 id="第五步：访问本地博客"><a href="#第五步：访问本地博客" class="headerlink" title="第五步：访问本地博客"></a>第五步：访问本地博客</h2><p>生成静态文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate || hexo g</span><br></pre></td></tr></table></figure><p>启动本地服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server || hexo s</span><br></pre></td></tr></table></figure><p>带调试的启动本地服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server --debug</span><br></pre></td></tr></table></figure><p>启动本地服务后提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hexo is running at http:&#x2F;&#x2F;0.0.0.0:4000&#x2F;. Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure><p>然后在浏览器打开 <a href="http://0.0.0.0:4000/，就可以看到迁移好的博客啦！" target="_blank" rel="noopener">http://0.0.0.0:4000/，就可以看到迁移好的博客啦！</a></p><h2 id="第六步：设置主题"><a href="#第六步：设置主题" class="headerlink" title="第六步：设置主题"></a>第六步：设置主题</h2><p>可参考 <a href="https://www.zhihu.com/question/24422335" target="_blank" rel="noopener">有那些好看的 Hexo 主题？</a></p><p>参考说明文档设置即可</p><h2 id="第七步：托管到GitHub"><a href="#第七步：托管到GitHub" class="headerlink" title="第七步：托管到GitHub"></a>第七步：托管到GitHub</h2><p>==这里用到了之前配置好的ssh，一定要配置好，否则git会失败==</p><h3 id="创建一个新的repository"><a href="#创建一个新的repository" class="headerlink" title="创建一个新的repository"></a>创建一个新的repository</h3><p><strong>要注意</strong>：新建跟用户名同名的 repository，以“.github.io” 为后缀。</p><p><strong>配置Hexo的配置文件_config.yml文件中，找到==Deploymeny==，修改配置：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:yourname&#x2F;yourname.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><h3 id="Git上传"><a href="#Git上传" class="headerlink" title="Git上传"></a>Git上传</h3><p> 在终端中输入如下命令安装git部署插件：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git</span><br></pre></td></tr></table></figure><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><br> 安装完成之后，先进行静态文件生成<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure><br> 然后将项目部署到github上即可<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy || hexo d</span><br></pre></td></tr></table></figure><br> ==部署完成之后就可以通过yourname.github.io来访问了！==</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;博客迁移-for-MAC&quot;&gt;&lt;a href=&quot;#博客迁移-for-MAC&quot; class=&quot;headerlink&quot; title=&quot;博客迁移 for MAC&quot;&gt;&lt;/a&gt;博客迁移 for MAC&lt;/h1&gt;&lt;h2 id=&quot;第一步：导出wordpress内容&quot;&gt;&lt;a hre
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>装饰模式编程实现</title>
    <link href="https://zs670980918.github.io/blogs/2019/05/13/zhuang-shi-mo-shi-bian-cheng-shi-xian/"/>
    <id>https://zs670980918.github.io/blogs/2019/05/13/zhuang-shi-mo-shi-bian-cheng-shi-xian/</id>
    <published>2019-05-13T07:04:12.000Z</published>
    <updated>2019-12-27T02:15:57.214Z</updated>
    
    <content type="html"><![CDATA[<p><strong>装饰模式</strong></p><p><strong>实验原理：</strong></p><ul><li>动态地给一个对象添加一些额外的职责。</li><li>就增加功能来说，装饰模式比生成子类更为灵活。</li></ul><p><strong>装饰模式的适用性：</strong></p><ul><li>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</li><li>处理那些可以撤销的职责。</li><li>当不能采用生成子类的方法进行扩充时。</li><li>可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。</li><li>类定义被隐藏，或类定义不能用于生成子类。</li></ul><p><strong>装饰模式的结构：</strong> <img src="http://47.100.4.8/wp-content/uploads/2019/05/11.png" alt=""> <strong>例题：</strong> 给定两种初始的汽车类，例如丰田和沃尔沃，利用装饰模式分别给它们添加新的功能，其中丰田可以导航和自动驾驶，沃尔沃可以导航和语音控制。 <strong>代码：</strong></p><p>#include<iostream><br>using namespace std;<br>class Car{<br>public:<br>    virtual void Operation()=0;<br>};<br>//Decorator<br>class Decorator:public Car{<br>protected:<br>    Car* car;<br>public:<br>    void SetCar(Car* car){<br>        this-&gt;car = car;<br>    }<br>    void Operation(){<br>        if(car != NULL){<br>            car-&gt;Operation();<br>        }<br>    }<br>};<br>//导航<br>class ConcreteFunction1:public Decorator{<br>public:<br>    void Operation(){<br>        Decorator::Operation();<br>        cout&lt;&lt;”Navigation”&lt;&lt;endl;<br>    }<br>};<br>//自动驾驶<br>class ConcreteFunction2:public Decorator{<br>public:<br>    void Operation(){<br>        Decorator::Operation();<br>        cout&lt;&lt;”Autopilot”&lt;&lt;endl;<br>    }<br>};<br>//语音控制<br>class ConcreteFunction3:public Decorator{<br>public:<br>    void Operation(){<br>        Decorator::Operation();<br>        cout&lt;&lt;”Voice control”&lt;&lt;endl;<br>    }<br>};<br>//丰田<br>class Toyota:public Car{<br>public:<br>    void Operation(){<br>        cout&lt;&lt;”Toyota:”&lt;&lt;endl;<br>    }<br>};<br>//沃尔沃<br>class Volvo:public Car{<br>public:<br>    void Operation(){<br>        cout&lt;&lt;”Volvo:”&lt;&lt;endl;<br>    }<br>};<br>int main(){<br>    Toyota* toyota = new Toyota();<br>    ConcreteFunction1* concreteFunction1 = new ConcreteFunction1();<br>    ConcreteFunction2* concreteFunction2 = new ConcreteFunction2();<br>    concreteFunction1-&gt;SetCar(toyota);<br>    concreteFunction2-&gt;SetCar(concreteFunction1);<br>    concreteFunction2-&gt;Operation();<br>    Volvo* volvo = new Volvo();<br>    ConcreteFunction1* concreteFunction3 = new ConcreteFunction1();<br>    ConcreteFunction3* concreteFunction4 = new ConcreteFunction3();<br>    concreteFunction3-&gt;SetCar(volvo);<br>    concreteFunction4-&gt;SetCar(concreteFunction3);<br>    concreteFunction4-&gt;Operation();<br>    return 0;<br>}</p><p><strong>UML类图：</strong> <img src="http://47.100.4.8/wp-content/uploads/2019/05/2-2.png" alt=""> <strong>结果：</strong> <img src="http://47.100.4.8/wp-content/uploads/2019/05/3-1.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;装饰模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实验原理：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;动态地给一个对象添加一些额外的职责。&lt;/li&gt;
&lt;li&gt;就增加功能来说，装饰模式比生成子类更为灵活。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong
      
    
    </summary>
    
    
      <category term="C&amp;amp;C++" scheme="https://zs670980918.github.io/blogs/categories/C-amp-C/"/>
    
      <category term="文章页" scheme="https://zs670980918.github.io/blogs/categories/C-amp-C/%E6%96%87%E7%AB%A0%E9%A1%B5/"/>
    
      <category term="设计模式" scheme="https://zs670980918.github.io/blogs/categories/C-amp-C/%E6%96%87%E7%AB%A0%E9%A1%B5/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>适配器模式编程实现</title>
    <link href="https://zs670980918.github.io/blogs/2019/05/08/shi-pei-qi-mo-shi-bian-cheng-shi-xian/"/>
    <id>https://zs670980918.github.io/blogs/2019/05/08/shi-pei-qi-mo-shi-bian-cheng-shi-xian/</id>
    <published>2019-05-08T11:02:27.000Z</published>
    <updated>2019-12-27T02:15:57.214Z</updated>
    
    <content type="html"><![CDATA[<p>适配器模式</p><p><strong>适配器模式的结构：</strong></p><ul><li>客户端使用的Target类需要使用一个已经存在的接口Adaptee类，可以用两种方法实现：</li><li>构造Adapter类继承Target类，并实现Adaptee接口（适配器模式的类版本）</li><li>将一个Adaptee实例作为Adapter的组成部分（适配器模式的对象版本）</li></ul><p><strong>类版本结构：</strong> <img src="http://47.100.4.8/wp-content/uploads/2019/05/1-1.png" alt=""> <strong>对象版本:</strong> <img src="http://47.100.4.8/wp-content/uploads/2019/05/2-1.png" alt=""> <strong>适配器模式的参与者：</strong></p><ul><li>Target</li></ul><p>定义Client使用的与特定领域相关的接口</p><ul><li>Client</li></ul><p>与符合Target接口的对象协同</p><ul><li>Adaptee</li></ul><p>定义一个已经存在的接口，这个接口需要适配</p><ul><li>Adapter</li></ul><p>对Adaptee的接口与Target接口进行适配 <strong>使用例题：</strong> 分别利用类版本和对象版本的适配器模式模拟实现ps2接口和usb接口的转换。 我们手中有个ps2插头的设备，但是主机上只有usb插头的接口，实现一个适配器将ps2接口转换为usb接口。其中，ps2接口表示为： class Ps2{ virtual void isPs2(); } Usb接口表示为： class Usb{ Virtual void isusb(); }。 <strong>对象版本的代码：</strong></p><p>#include<iostream></p><p>using namespace std;<br>//类版本<br>//Adaptee<br>//定义一个已经存在的接口，这个接口需要适配<br>class Ps2{<br>public:<br>    void isPs2(){<br>        cout&lt;&lt;”Ps2”&lt;&lt;endl;<br>    };<br>};<br>//Target<br>class Usb{<br>public:<br>    virtual void isUsb()=0;<br>};<br>//对Adaptee的接口与Target接口进行适配<br>class Adapter:public Usb{<br>public:<br>    void isUsb(){<br>        ps2-&gt;isPs2();<br>    }<br>private:<br>    Ps2* ps2 = new Ps2();<br>};</p><p>int main(){<br>    Usb* usb = new Adapter();<br>    usb-&gt;isUsb();<br>    return 0;<br>}</p><p><strong>对应的UML类图：</strong> <img src="http://47.100.4.8/wp-content/uploads/2019/05/3.png" alt=""> <strong>类版本的代码：</strong></p><p>#include<iostream></p><p>using namespace std;<br>//类版本<br>//Adaptee<br>//定义一个已经存在的接口，这个接口需要适配<br>class Ps2{<br>public:<br>    void isPs2(){<br>        cout&lt;&lt;”Ps2”&lt;&lt;endl;<br>    };<br>};<br>//Target<br>class Usb{<br>public:<br>    virtual void isUsb()=0;<br>};<br>//对Adaptee的接口与Target接口进行适配<br>class Adapter:public Usb,private Ps2{<br>    void isUsb(){<br>        isPs2();<br>    }<br>};</p><p>int main(){<br>    Usb* usb = new Adapter();<br>    usb-&gt;isUsb();<br>    return 0;<br>}</p><p><strong>对应的UML类图：</strong> <img src="http://47.100.4.8/wp-content/uploads/2019/05/4-1.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;适配器模式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;适配器模式的结构：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端使用的Target类需要使用一个已经存在的接口Adaptee类，可以用两种方法实现：&lt;/li&gt;
&lt;li&gt;构造Adapter类继承Target类，并实现Adapte
      
    
    </summary>
    
    
      <category term="C&amp;amp;C++" scheme="https://zs670980918.github.io/blogs/categories/C-amp-C/"/>
    
      <category term="文章页" scheme="https://zs670980918.github.io/blogs/categories/C-amp-C/%E6%96%87%E7%AB%A0%E9%A1%B5/"/>
    
      <category term="设计模式" scheme="https://zs670980918.github.io/blogs/categories/C-amp-C/%E6%96%87%E7%AB%A0%E9%A1%B5/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>生成器模式和原型模式编程实现</title>
    <link href="https://zs670980918.github.io/blogs/2019/05/06/sheng-cheng-qi-mo-shi-he-yuan-xing-mo-shi-bian-cheng-shi-xian/"/>
    <id>https://zs670980918.github.io/blogs/2019/05/06/sheng-cheng-qi-mo-shi-he-yuan-xing-mo-shi-bian-cheng-shi-xian/</id>
    <published>2019-05-06T04:36:54.000Z</published>
    <updated>2019-12-27T02:15:57.214Z</updated>
    
    <content type="html"><![CDATA[<p>1、生成器模式的原理：</p><ul><li>Builder</li></ul><p>为创建一个Product对象的各个部件指定抽象接口</p><ul><li>ConcreteBuilder</li></ul><p>实现Builder的接口以构造和装配该产品的各个部件 定义并明确它所创建的表示 提供一个检索产品的接口</p><ul><li>Director</li></ul><p>构造一个使用Builder接口的对象</p><ul><li>Product</li></ul><p>表示被构造的复杂对象。ConcreteBuilder创建该产品的内部表示并定义它的装配过程。 包含定义组成部件的类，包括将这些部件装配成最终产品的接口 <strong>结构图：</strong> <img src="http://47.100.4.8/wp-content/uploads/2019/05/1.png" alt=""> <strong>2、原型模式原理：</strong></p><ul><li>Prototype</li></ul><p>声明一个克隆自身的接口</p><ul><li>ConcretePrototype</li></ul><p>实现一个克隆自身的操作</p><ul><li>Client</li></ul><p>让一个原型克隆自身从而创建一个新的对象 <strong>结构图：</strong> <img src="http://47.100.4.8/wp-content/uploads/2019/05/2.png" alt=""> <strong>题目要求：</strong> 使用生成器模式模拟实现IBM电脑的生产，其中IBM电脑的主要结构用如下表示： class IBM{   string monitor=”IBM的显示器”;   string keyboard=”IBM的键盘”;   string mouse=”IBM的鼠标”;   Motherboard* MB;   void display(); } 其中MB是一个主板类，其主要结构如下： class Motherboard{ string CPU; string RAM; } 即主板包含CPU和RAM。display是一个打印各个组件的函数，主要用于检查是否生产正确。 建造顺序为先生产主板，再依次生产显示器、键盘和鼠标。 使用生成器模式生产出第一台IBM电脑后，利用原型模式，将该电脑再复制两台。 <strong>UML类图：</strong> <img src="http://47.100.4.8/wp-content/uploads/2019/05/3.jpg" alt=""> <strong>代码：</strong></p><p>#include<iostream><br>#include&lt;string.h&gt;</p><p>using namespace std;</p><p>//Product<br>//主板<br>class Motherboard{<br>public:<br>    Motherboard(){}<br>    string CPU;<br>    string RAM;<br>    void set_CPU(string CPU){<br>      this-&gt;CPU = CPU;<br>    }<br>    void set_RAM(string RAM){<br>      this-&gt;RAM = RAM;<br>    }<br>    void display(){<br>        cout&lt;&lt;”Elements of motherboards!”&lt;&lt;endl;<br>        cout&lt;&lt;”CPU:”&lt;&lt;CPU&lt;&lt;endl;<br>        cout&lt;&lt;”RAM:”&lt;&lt;RAM&lt;&lt;endl;<br>    }<br>    Motherboard* Clone(){<br>        return new Motherboard(<em>this);<br>    }<br>private:<br>    Motherboard(Motherboard</em> tt){<br>        tt-&gt;CPU = CPU;<br>        tt-&gt;RAM = RAM;<br>    }<br>};<br>//IBM<br>class IBM{<br>public:<br>  IBM(){<br>      MB = new Motherboard();<br>  }<br>  Motherboard* MB;<br>  string monitor;<br>  string keyboard;<br>  string mouse;<br>  void set_monitor(string monitor){<br>      this-&gt;monitor = monitor;<br>  }<br>  void set_keyboard(string keyboard){<br>      this-&gt;keyboard = keyboard;<br>  }<br>  void set_mouse(string mouse){<br>      this-&gt;mouse = mouse;<br>  }<br>  void display(){<br>      MB-&gt;display();<br>      cout&lt;&lt;”IBM’s monitor:”&lt;&lt;monitor&lt;&lt;endl;<br>      cout&lt;&lt;”IBM’s keyboard:”&lt;&lt;keyboard&lt;&lt;endl;<br>      cout&lt;&lt;”IBM’s mouse:”&lt;&lt;mouse&lt;&lt;endl;<br>      cout&lt;&lt;”IBM has produced!”&lt;&lt;endl;<br>  };<br>  IBM* Clone(){<br>      IBM* obj = new IBM();<br>      obj-&gt;MB = MB-&gt;Clone();<br>      obj-&gt;monitor = monitor;<br>      obj-&gt;keyboard = keyboard;<br>      obj-&gt;mouse = mouse;<br>      return obj;<br>  }<br>};</p><p>//Builder<br>class IBM_Builder{<br>public:<br>    virtual void BuildPart_Motherboard()=0;<br>    virtual void BuildPart_monitor()=0;<br>    virtual void BuildPart_keyboard()=0;<br>    virtual void BuildPart_mouse()=0;<br>    virtual IBM* GetComputer()=0;<br>};</p><p>//ConcreteBuilder<br>class IBM_ConcreteBuilder:public IBM_Builder{<br>public:<br>    void BuildPart_Motherboard(){<br>        computer-&gt;MB-&gt;set_CPU(“i9-9900K”);<br>        computer-&gt;MB-&gt;set_RAM(“Kingston 3800MHZ”);<br>    }<br>    void BuildPart_monitor(){<br>        computer-&gt;set_monitor(“SamSung”);<br>    }<br>    void BuildPart_keyboard(){<br>        computer-&gt;set_keyboard(“cherry”);<br>    }<br>    void BuildPart_mouse(){<br>        computer-&gt;set_mouse(“G903”);<br>    }<br>    IBM* GetComputer(){<br>        return computer;<br>    }<br>private:<br>    IBM* computer = new IBM();<br>};</p><p>//Director<br>class IBM_Director{<br>public:<br>    void Construct(IBM_Builder *builder){<br>        builder-&gt;BuildPart_Motherboard();<br>        builder-&gt;BuildPart_monitor();<br>        builder-&gt;BuildPart_keyboard();<br>        builder-&gt;BuildPart_mouse();<br>    }<br>};</p><p>int main(){<br>    IBM_ConcreteBuilder* t1 = new IBM_ConcreteBuilder();<br>    IBM_Director* t2 = new IBM_Director();<br>    t2-&gt;Construct(t1);<br>    IBM *p1 = t1-&gt;GetComputer();<br>    p1-&gt;display();<br>    IBM *p2 = p1-&gt;Clone();<br>    p2-&gt;display();<br>    IBM *p3 = p1-&gt;Clone();<br>    p3-&gt;display();<br>    p3-&gt;set_monitor(“1111”);<br>    p3-&gt;display();<br>    p1-&gt;display();<br>    return 0;<br>}</p><p><strong>结果：</strong> <img src="http://47.100.4.8/wp-content/uploads/2019/05/4.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、生成器模式的原理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Builder&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为创建一个Product对象的各个部件指定抽象接口&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ConcreteBuilder&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实现Builder的接口以构造和装配该产品
      
    
    </summary>
    
    
      <category term="C&amp;amp;C++" scheme="https://zs670980918.github.io/blogs/categories/C-amp-C/"/>
    
      <category term="文章页" scheme="https://zs670980918.github.io/blogs/categories/C-amp-C/%E6%96%87%E7%AB%A0%E9%A1%B5/"/>
    
      <category term="设计模式" scheme="https://zs670980918.github.io/blogs/categories/C-amp-C/%E6%96%87%E7%AB%A0%E9%A1%B5/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Windows下配置VSCode</title>
    <link href="https://zs670980918.github.io/blogs/2019/04/17/windows-xia-pei-zhi-vscode/"/>
    <id>https://zs670980918.github.io/blogs/2019/04/17/windows-xia-pei-zhi-vscode/</id>
    <published>2019-04-17T11:46:00.000Z</published>
    <updated>2019-12-27T02:15:57.213Z</updated>
    
    <content type="html"><![CDATA[<p><strong>弄了很久总算搞好了，这里分享一下，QWQ</strong> 一、软件安装 先去VSCode官网下载安装包 地址为：<a href="https://code.visualstudio.com/Download" target="_blank" rel="noopener">https://code.visualstudio.com/Download</a> 二、安装配置插件 先打开VSCode，打开扩展程序安装并安装如下插件： <img src="http://47.100.4.8/wp-content/uploads/2019/04/1-1.png" alt=""> 其中C/C++、C/C++ Clang和Code Runner是必备的，如果你需要中文版则可以安装Chinese language这个插件安装好后要重启以下VSCode 三、安装MinGW 首先如果没有codeblock或者DevC++的则可以考虑去官网下载MinGW的安装程序 网址为：<a href="https://osdn.net/projects/mingw/releases/p15522" target="_blank" rel="noopener">https://osdn.net/projects/mingw/releases/p15522</a> 具体安装过程详见：<a href="https://blog.csdn.net/bat67/article/details/76095813" target="_blank" rel="noopener">https://blog.csdn.net/bat67/article/details/76095813</a> 这里由于我已经安装过CodeBlock则不需要再次安装了，也就不过多的说了。 四、配置系统环境变量 如图操作即可，记得配置完环境变量要重启VSCode <img src="http://47.100.4.8/wp-content/uploads/2019/04/2-1.png" alt=""> 五、配置c_cpp_properties.json文件 首先要创建一个工作环境的文件夹，然后在这里面通过设置调出该文件，按照如下配置即可 <img src="http://47.100.4.8/wp-content/uploads/2019/04/QQ%E5%9B%BE%E7%89%8720190417194139.png" alt=""> 这里需要注意的是添加如下一行代码即可：</p><p>“E:/codeblock/CodeBlocks/MinGW/include/**”</p><p>添加完成之后在工作区创建一个Cpp文件使用运行即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;弄了很久总算搞好了，这里分享一下，QWQ&lt;/strong&gt; 一、软件安装 先去VSCode官网下载安装包 地址为：&lt;a href=&quot;https://code.visualstudio.com/Download&quot; target=&quot;_blank&quot; rel=&quot;no
      
    
    </summary>
    
    
      <category term="VSCode" scheme="https://zs670980918.github.io/blogs/categories/VSCode/"/>
    
      <category term="文章页" scheme="https://zs670980918.github.io/blogs/categories/VSCode/%E6%96%87%E7%AB%A0%E9%A1%B5/"/>
    
      <category term="软件分享" scheme="https://zs670980918.github.io/blogs/categories/VSCode/%E6%96%87%E7%AB%A0%E9%A1%B5/%E8%BD%AF%E4%BB%B6%E5%88%86%E4%BA%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>抽象工厂模式与单件模式编程实现</title>
    <link href="https://zs670980918.github.io/blogs/2019/04/14/chou-xiang-gong-chang-mo-shi-yu-dan-jian-mo-shi-bian-cheng-shi-xian/"/>
    <id>https://zs670980918.github.io/blogs/2019/04/14/chou-xiang-gong-chang-mo-shi-yu-dan-jian-mo-shi-bian-cheng-shi-xian/</id>
    <published>2019-04-14T05:20:58.000Z</published>
    <updated>2019-12-27T02:15:57.214Z</updated>
    
    <content type="html"><![CDATA[<p>一、抽象工厂原理            AbstractFactory            声明一个创建抽象产品对象的操作接口。            ConcreteFactory            实现创建具体产品对象的操作。            AbstractProduct            为一类产品对象声明一个接口。            ConcreteProduct            定义一个将被相应的具体工厂创建的产品对象。            实现AbstractProduct接口。            Client            仅使用由AbstractFactory和AbstractProduct类声明的接口 抽象工厂中的协作：            通常在运行时刻创建一个ConcreteFactory类的实例。这一具体的工厂创建具有特定实现的产品对象。为创建不同的产品对象，客户应使用不同的具体工厂。            AbstractFactory将产品对象的创建延迟到它的ConcreteFactory子类。 抽象工厂中的类图： <img src="http://47.100.4.8/wp-content/uploads/2019/04/1.png" alt=""> 二、单件模式原理            Prototype            声明一个克隆自身的接口            ConcretePrototype            实现一个克隆自身的操作            Client            让一个原型克隆自身从而创建一个新的对象 单件模式的结构：            将构造方法定义为私有的，阻止了外部程序实例化该类，但可以在该类内部写一个静态的public方法GetInstance()，这个方法的目的就是返回一个类实例，并在此方法中，去做是否有实例化的判断。 单件模式的类图： <img src="http://47.100.4.8/wp-content/uploads/2019/04/2.png" alt="">   问题：            该公司数据库拥有三张表，分别是用户表、部门表和项目表。每张表的操作都支持查询和添加功能。数据库支持mysql和sqlserver两种。结合抽象工厂模式和单件模式给出该系统的模拟代码。            在抽象工厂模式中，一个应用里一般每个产品只需要一个具体工厂的实例，因此，工厂通常最好用单件模式实现。            要求结合抽象工厂模式和单件模式，模拟公司数据库创建过程。 类图： <img src="http://47.100.4.8/wp-content/uploads/2019/04/3-e1555219097900.jpg" alt=""> 实现代码：</p><p>#include<iostream></p><p>using namespace std;</p><p>//用户表<br>class userTable{<br>public:<br>    virtual void searchElem()=0;<br>    virtual void addElem()=0;<br>};</p><p>class mysqlUserTable:public userTable{<br>public:<br>    void searchElem(){cout&lt;&lt;”UserTable mysql Search”&lt;&lt;endl;}<br>    void addElem(){cout&lt;&lt;”UserTable mysql Add”&lt;&lt;endl;}<br>};</p><p>class sqlserverUserTable:public userTable{<br>public:<br>    void searchElem(){cout&lt;&lt;”UserTable sqlserver Search”&lt;&lt;endl;}<br>    void addElem(){cout&lt;&lt;”UserTable sqlserver Add”&lt;&lt;endl;}<br>};</p><p>//部门表<br>class departmentTable{<br>public:<br>    virtual void searchElem()=0;<br>    virtual void addElem()=0;<br>};</p><p>class mysqlDepartmentTable:public departmentTable{<br>public:<br>    void searchElem(){cout&lt;&lt;”DepartmentTable mysql Search”&lt;&lt;endl;}<br>    void addElem(){cout&lt;&lt;”DepartmentTable mysql Add”&lt;&lt;endl;}<br>};</p><p>class sqlserverDepartmentTable:public departmentTable{<br>public:<br>    void searchElem(){cout&lt;&lt;”DepartmentTable sqlserver Search”&lt;&lt;endl;}<br>    void addElem(){cout&lt;&lt;”DepartmentTable sqlserver Add”&lt;&lt;endl;}<br>};</p><p>//项目表<br>class programTable{<br>public:<br>    virtual void searchElem()=0;<br>    virtual void addElem()=0;<br>};</p><p>class mysqlProgramTable:public programTable{<br>public:<br>    void searchElem(){cout&lt;&lt;”ProgramTable mysql Search”&lt;&lt;endl;}<br>    void addElem(){cout&lt;&lt;”ProgramTable mysql Add”&lt;&lt;endl;}<br>};</p><p>class sqlserverProgramTable:public programTable{<br>public:<br>    void searchElem(){cout&lt;&lt;”ProgramTable sqlserver Search”&lt;&lt;endl;}<br>    void addElem(){cout&lt;&lt;”ProgramTable sqlserver Add”&lt;&lt;endl;}<br>};</p><p>//工厂<br>class IFactory{<br>public:<br>    virtual userTable* createUserTable()=0;<br>    virtual departmentTable* createDepartmentTable()=0;<br>    virtual programTable* createProgramTable()=0;<br>};</p><p>class mysqlFactory:public IFactory{<br>public:<br>    static mysqlFactory* GetLinstance(){<br>        if(_mysqlfactory == NULL){<br>            _mysqlfactory = new mysqlFactory();<br>            cout&lt;&lt;”mysqlFactory Create Success!”&lt;&lt;endl;<br>        }<br>        else{<br>            cout&lt;&lt;”mysqlFactory has existed!”&lt;&lt;endl;<br>        }<br>        return _mysqlfactory;<br>    }<br>    userTable* createUserTable(){return new mysqlUserTable();}<br>    departmentTable* createDepartmentTable() {return new mysqlDepartmentTable();}<br>    programTable* createProgramTable() {return new mysqlProgramTable();}<br>private:<br>    mysqlFactory(){<br>    }<br>    static mysqlFactory* _mysqlfactory;<br>};<br>mysqlFactory* mysqlFactory::_mysqlfactory = NULL;</p><p>class sqlserverFactory:public IFactory{<br>public:<br>    static sqlserverFactory* GetLinstance(){<br>        if(_sqlserverFactory == NULL){<br>            _sqlserverFactory = new sqlserverFactory();<br>            cout&lt;&lt;”sqlserverFactory Create Success!”&lt;&lt;endl;<br>        }<br>        else{<br>            cout&lt;&lt;”sqlserverFactory has existed!”&lt;&lt;endl;<br>        }<br>        return _sqlserverFactory;<br>    }<br>    userTable* createUserTable(){return new sqlserverUserTable();}<br>    departmentTable* createDepartmentTable() {return new sqlserverDepartmentTable();}<br>    programTable* createProgramTable() {return new sqlserverProgramTable();}<br>private:<br>    sqlserverFactory(){<br>    }<br>    static sqlserverFactory* _sqlserverFactory;<br>};<br>sqlserverFactory* sqlserverFactory::_sqlserverFactory = NULL;</p><p>int main(){<br>    //创建用户表mysql工厂<br>    IFactory* factory1 = mysqlFactory::GetLinstance();<br>    userTable* utmysql = factory1-&gt;createUserTable();<br>    utmysql-&gt;searchElem();<br>    utmysql-&gt;addElem();<br>    cout&lt;&lt;endl;<br>    //创建用户表sqlserver工厂<br>    IFactory* factory2 = sqlserverFactory::GetLinstance();<br>    userTable* utserver = factory2-&gt;createUserTable();<br>    utserver-&gt;searchElem();<br>    utserver-&gt;addElem();<br>    cout&lt;&lt;endl;<br>    //创建部门表mysql工厂<br>    IFactory* factory3 = mysqlFactory::GetLinstance();<br>    departmentTable* dtmysql = factory3-&gt;createDepartmentTable();<br>    dtmysql-&gt;searchElem();<br>    dtmysql-&gt;addElem();<br>    cout&lt;&lt;endl;<br>    //创建部门表sqlserver工厂<br>    IFactory* factory4 = sqlserverFactory::GetLinstance();<br>    departmentTable* dtsqlserver = factory4-&gt;createDepartmentTable();<br>    dtsqlserver-&gt;searchElem();<br>    dtsqlserver-&gt;addElem();<br>    cout&lt;&lt;endl;<br>    //创建项目表mysql工厂<br>    IFactory* factory5 = mysqlFactory::GetLinstance();<br>    programTable* ptmysql = factory5-&gt;createProgramTable();<br>    ptmysql-&gt;searchElem();<br>    ptmysql-&gt;addElem();<br>    cout&lt;&lt;endl;<br>    //创建项目表sqlserver工厂<br>    IFactory* factory6 = sqlserverFactory::GetLinstance();<br>    programTable* ptserver = factory6-&gt;createProgramTable();<br>    ptserver-&gt;searchElem();<br>    ptserver-&gt;addElem();<br>    return 0;<br>}</p><p>结果： <img src="http://47.100.4.8/wp-content/uploads/2019/04/4.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、抽象工厂原理            AbstractFactory            声明一个创建抽象产品对象的操作接口。            ConcreteFactory            实现创建具体产品对象的操作。            Abstrac
      
    
    </summary>
    
    
      <category term="C&amp;amp;C++" scheme="https://zs670980918.github.io/blogs/categories/C-amp-C/"/>
    
      <category term="文章页" scheme="https://zs670980918.github.io/blogs/categories/C-amp-C/%E6%96%87%E7%AB%A0%E9%A1%B5/"/>
    
      <category term="设计模式" scheme="https://zs670980918.github.io/blogs/categories/C-amp-C/%E6%96%87%E7%AB%A0%E9%A1%B5/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Pat_1002（甲级）</title>
    <link href="https://zs670980918.github.io/blogs/2019/03/25/pat-1002-jia-ji/"/>
    <id>https://zs670980918.github.io/blogs/2019/03/25/pat-1002-jia-ji/</id>
    <published>2019-03-25T15:22:13.000Z</published>
    <updated>2019-12-27T02:15:57.213Z</updated>
    
    <content type="html"><![CDATA[<p>1002 A+B for Polynomials （25 分) <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805526272000000" target="_blank" rel="noopener">原文地址</a></p><p>This time, you are supposed to find A+B where A and B are two polynomials.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial: K N​1​​ a​N​1​​​​ N​2​​ a​N​2​​​​ … N​K​​ a​N​K​​​​ where K is the number of nonzero terms in the polynomial, N​i​​ and a​N​i​​​​ (i=1,2,⋯,K) are the exponents and coefficients, respectively. It is given that 1≤K≤10，0≤N​K​​&lt;⋯&lt;N​2​​&lt;N​1​​≤1000.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case you should output the sum of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><pre><code>2 1 2.4 0 3.22 2 1.5 1 0.5</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><pre><code>3 2 1.5 1 2.9 0 3.2</code></pre><p>代码：</p><p>#include<iostream><br>#include<map><br>#include<cstdio><br>#include<vector><br>#include<algorithm></p><p>//这里面不需要输出系数为0的<br>using namespace std;</p><p>struct Plot{<br>    int exponents; //指数<br>    float coefficients; //系数<br>};</p><p>bool cmp(Plot a,Plot b){<br>    return a.exponents &gt; b.exponents;<br>}</p><p>int main(){<br>    vector<Plot> list1;<br>    vector<Plot>::iterator poss;<br>    map&lt;int,float&gt; Ploy;<br>    map&lt;int,float&gt;::iterator pos;<br>    int K1,K2,sum=0;<br>    cin&gt;&gt;K1;<br>    for(int i=0;i&lt;K1;i++){<br>        int t1;<br>        float t2;<br>        cin&gt;&gt;t1&gt;&gt;t2;<br>        if(Ploy.count(t1) == 0){<br>            Ploy[t1] = t2;<br>        }<br>        else{<br>            Ploy[t1] += t2;<br>        }<br>    }<br>    cin&gt;&gt;K2;<br>    for(int i=0;i&lt;K2;i++){<br>        int t1;<br>        float t2;<br>        cin&gt;&gt;t1&gt;&gt;t2;<br>        if(Ploy.count(t1) == 0){<br>            Ploy[t1] = t2;<br>        }<br>        else{<br>            Ploy[t1] += t2;<br>        }<br>    }<br>    for(pos=Ploy.begin();pos!=Ploy.end();pos++){<br>        if((<em>pos).second != 0){<br>            Plot tt;<br>            tt.exponents = (<em>pos).first;<br>            tt.coefficients = (</em>pos).second;<br>            sum++;<br>            list1.push_back(tt);<br>        }<br>    }<br>    sort(list1.begin(),list1.end(),cmp);<br>    cout&lt;&lt;sum;<br>    for(poss=list1.begin();poss!=list1.end();poss++){<br>        printf(“ %d %.1f”,(*poss).exponents,(*poss).coefficients);<br>    }<br>    /</em><br>    if(sum != 1 &amp;&amp; sum != 0){<br>        pos = –Ploy.end();<br>        for(;pos!=Ploy.begin();pos–){<br>            printf(“ %d %.1f”,(*pos).first,(*pos).second);<br>        }<br>        pos = Ploy.begin();<br>        printf(“ %d %.1f”,(*pos).first,(*pos).second);<br>        cout&lt;&lt;endl;<br>    }<br>    else if(sum == 1){<br>        pos = Ploy.begin();<br>        printf(“ %d %.1f”,(*pos).first,(*pos).second);<br>        cout&lt;&lt;endl;<br>    }*/<br>    return 0;<br>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1002 A+B for Polynomials （25 分) &lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805526272000000&quot; target=&quot;_blank&quot; r
      
    
    </summary>
    
    
      <category term="PAT" scheme="https://zs670980918.github.io/blogs/categories/PAT/"/>
    
      <category term="乙级" scheme="https://zs670980918.github.io/blogs/categories/PAT/%E4%B9%99%E7%BA%A7/"/>
    
      <category term="文章页" scheme="https://zs670980918.github.io/blogs/categories/PAT/%E4%B9%99%E7%BA%A7/%E6%96%87%E7%AB%A0%E9%A1%B5/"/>
    
    
  </entry>
  
  <entry>
    <title>Pat_1001（甲级）</title>
    <link href="https://zs670980918.github.io/blogs/2019/03/25/pat-1001-jia-ji/"/>
    <id>https://zs670980918.github.io/blogs/2019/03/25/pat-1001-jia-ji/</id>
    <published>2019-03-25T15:17:04.000Z</published>
    <updated>2019-12-27T02:15:57.213Z</updated>
    
    <content type="html"><![CDATA[<p>1001 A+B Format （20 分) <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805528788582400" target="_blank" rel="noopener">原文地址</a></p><p>Calculate a+b and output the sum in standard format – that is, the digits must be separated into groups of three by commas (unless there are less than four digits).</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case contains a pair of integers a and b where −10​6​​≤a,b≤10​6​​. The numbers are separated by a space.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, you should output the sum of a and b in one line. The sum must be written in the standard format.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><pre><code>-1000000 9</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><pre><code>-999,991</code></pre><p>代码：（这里自己写过一个可以使所有数据进行相加减的大数运算 但是会发生time out 因此这个参考了网上大佬写的，基本上能看懂所以在这里就贴大佬的了）</p><p>#include<iostream><br>#include<cstdio><br>#include<cmath><br>#include<cstring><br>using namespace std;<br>int main(){<br>    int a,b;<br>    cin&gt;&gt;a&gt;&gt;b;<br>    int c=a+b;<br>    if(c&lt;0) cout&lt;&lt;’-‘;<br>    c=abs(c);<br>    char s[20];<br>    sprintf(s,”%d”,c);<br>    int len=strlen(s);<br>    //if(len&lt;=3) {cout&lt;&lt;s;return 0;}<br>    int m=len/3,n=len%3,start=0;<br>    //cout&lt;&lt;”m=”&lt;&lt;m&lt;&lt;’ ‘&lt;&lt;”n=”&lt;&lt;n&lt;&lt;endl;<br>    if(n==0) {cout&lt;&lt;s[0]&lt;&lt;s[1]&lt;&lt;s[2];start=3;m–;}<br>    else if(n==1) {cout&lt;&lt;s[0];start=1;}<br>    else if(n==2) {cout&lt;&lt;s[0]&lt;&lt;s[1];start=2;}<br>    while(m!=0){<br>        cout&lt;&lt;’,’;<br>        cout&lt;&lt;s[start]&lt;&lt;s[start+1]&lt;&lt;s[start+2];<br>        start+=3;<br>        m–;<br>    }<br>    return 0;<br>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1001 A+B Format （20 分) &lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805528788582400&quot; target=&quot;_blank&quot; rel=&quot;noope
      
    
    </summary>
    
    
      <category term="PAT" scheme="https://zs670980918.github.io/blogs/categories/PAT/"/>
    
      <category term="乙级" scheme="https://zs670980918.github.io/blogs/categories/PAT/%E4%B9%99%E7%BA%A7/"/>
    
      <category term="文章页" scheme="https://zs670980918.github.io/blogs/categories/PAT/%E4%B9%99%E7%BA%A7/%E6%96%87%E7%AB%A0%E9%A1%B5/"/>
    
    
  </entry>
  
  <entry>
    <title>Pat_1095（乙级）</title>
    <link href="https://zs670980918.github.io/blogs/2019/03/18/pat-1095-yi-ji/"/>
    <id>https://zs670980918.github.io/blogs/2019/03/18/pat-1095-yi-ji/</id>
    <published>2019-03-18T03:36:54.000Z</published>
    <updated>2019-12-27T02:15:57.213Z</updated>
    
    <content type="html"><![CDATA[<p>1095 解码PAT准考证 （25 分) <a href="https://pintia.cn/problem-sets/994805260223102976/problems/1071786104348536832" target="_blank" rel="noopener">原文地址</a></p><p>PAT 准考证号由 4 部分组成：</p><ul><li>第 1 位是级别，即 <code>T</code> 代表顶级；<code>A</code> 代表甲级；<code>B</code> 代表乙级；</li><li>第 2~4 位是考场编号，范围从 101 到 999；</li><li>第 5~10 位是考试日期，格式为年、月、日顺次各占 2 位；</li><li>最后 11~13 位是考生编号，范围从 000 到 999。</li></ul><p>现给定一系列考生的准考证号和他们的成绩，请你按照要求输出各种统计信息。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入首先在一行中给出两个正整数 N（≤10​4​​）和 M（≤100），分别为考生人数和统计要求的个数。 接下来 N 行，每行给出一个考生的准考证号和其分数（在区间 [0,100] 内的整数），其间以空格分隔。 考生信息之后，再给出 M 行，每行给出一个统计要求，格式为：<code>类型 指令</code>，其中</p><ul><li><code>类型</code> 为 1 表示要求按分数非升序输出某个指定级别的考生的成绩，对应的 <code>指令</code> 则给出代表指定级别的字母；</li><li><code>类型</code> 为 2 表示要求将某指定考场的考生人数和总分统计输出，对应的 <code>指令</code> 则给出指定考场的编号；</li><li><code>类型</code> 为 3 表示要求将某指定日期的考生人数分考场统计输出，对应的 <code>指令</code> 则给出指定日期，格式与准考证上日期相同。</li></ul><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每项统计要求，首先在一行中输出 <code>Case #: 要求</code>，其中 <code>#</code> 是该项要求的编号，从 1 开始；<code>要求</code> 即复制输入给出的要求。随后输出相应的统计结果：</p><ul><li><code>类型</code> 为 1 的指令，输出格式与输入的考生信息格式相同，即 <code>准考证号 成绩</code>。对于分数并列的考生，按其准考证号的字典序递增输出（题目保证无重复准考证号）；</li><li><code>类型</code> 为 2 的指令，按 <code>人数 总分</code> 的格式输出；</li><li><code>类型</code> 为 3 的指令，输出按人数非递增顺序，格式为 <code>考场编号 总人数</code>。若人数并列则按考场编号递增顺序输出。</li></ul><p>如果查询结果为空，则输出 <code>NA</code>。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code>8 4B123180908127 99B102180908003 86A112180318002 98T107150310127 62A107180908108 100T123180908010 78B112160918035 88A107180908021 981 A2 1073 1809082 999</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code>Case 1: 1 AA107180908108 100A107180908021 98A112180318002 98Case 2: 2 1073 260Case 3: 3 180908107 2123 2102 1Case 4: 2 999NA</code></pre><p>代码：</p><p>#include <iostream><br>#include <cstring><br>#include <algorithm><br>#include <map><br>#include <vector><br>using namespace std;<br>struct student{<br>    string id;<br>    int score;<br>};<br>struct examcase2{<br>    int allscore=0;<br>    int people=0;<br>};<br>struct examroom{<br>    string room;<br>    int people=0;<br>};<br>bool cmp(student a,student b)<br>{<br>    if(a.score!=b.score) return a.score&gt;b.score;<br>    else return a.id&lt;b.id;<br>}<br>bool cmp1(examroom a,examroom b)<br>{<br>    if(a.people!=b.people) return a.people&gt;b.people;<br>    else return a.room&lt;b.room;<br>}<br>int main()<br>{<br>    int N,M;<br>    scanf(“%d %d”,&amp;N,&amp;M);            //用cin.cout会超时<br>    map&lt;string,vector<student>&gt;  case1;     //按等级分；<br>    map&lt;string,examcase2&gt; case2;             //按教室分；<br>    map&lt;string,map&lt;string,examroom&gt;&gt;  case3;     //按日期分；<br>    for(int i=0;i&lt;N;i++)<br>    {<br>        student s;<br>        char id[14];<br>        scanf(“%s %d”,id,&amp;s.score);<br>        s.id=id;<br>        string ranks=s.id.substr(0,1);<br>        string exroom=s.id.substr(1,3);<br>        string date=s.id.substr(4,6);<br>        case1[ranks].push_back(s);        //将s放入同一个等级的动态数组中<br>        case2[exroom].allscore+=s.score;    //该考场的总成绩增加<br>        case2[exroom].people++;            //该考场的总人数增加<br>        case3[date][exroom].room=exroom;    //这个日期考试的这个考场的考场号<br>        case3[date][exroom].people++;        //这个日期考试的这个考场的人数<br>    }<br>    for(int i=1;i&lt;=M;i++)<br>    {<br>        int classi;<br>        char request[7];<br>        memset(request,0,sizeof(request));<br>        scanf(“%d %s”,&amp;classi,request);<br>        printf(“Case %d: %d %s\n”,i,classi,request);<br>        int flag=1;<br>        switch(classi)<br>        {<br>            case 1:<br>                {<br>                    vector<student>  ttt=case1[request];    //取出指定级别的集合<br>                    sort(ttt.begin(),ttt.end(),cmp);        //排序<br>                    for(auto it=ttt.begin();it!=ttt.end();it++)<br>                    {<br>                        printf(“%s %d\n”,(*it).id.c_str(),(*it).score);//输出<br>                        flag=0;                    //产生了输出，该要求有结果<br>                    }<br>                    break;<br>                }<br>            case 2:<br>                {<br>                    examcase2 ttt=case2[request];        //取出指定考场的信息<br>                    if(ttt.people!=0)                //该考场有人考试<br>                    {<br>                        printf(“%d %d\n”,ttt.people,ttt.allscore);    //输出结果<br>                        flag=0;<br>                    }<br>                    break;<br>                }<br>            case 3:<br>                {<br>                    map&lt;string,examroom&gt; ttt=case3[request]; //取出该天考试的所有考场的信息<br>                    int i=0,len=ttt.size();        //len–该天有len个考场进行考试<br>                    examroom e[len];<br>                    for(auto it=ttt.begin();it!=ttt.end();it++)<br>                    {<br>                        e[i++]=it-&gt;second;        //将考场信息存入数组<br>                    }<br>                    sort(e,e+len,cmp1);    //进行排序<br>                    for(i=0;i&lt;len;i++)<br>                    {<br>                        printf(“%s %d\n”,e[i].room.c_str(),e[i].people);//输出结果<br>                        flag=0;<br>                    }<br>                    break;<br>                }<br>        }<br>        if(flag)  printf(“NA\n”);    //没有符合条件的结果，则输出NA<br>    }<br>    return 0;<br>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1095 解码PAT准考证 （25 分) &lt;a href=&quot;https://pintia.cn/problem-sets/994805260223102976/problems/1071786104348536832&quot; target=&quot;_blank&quot; rel=&quot;noopen
      
    
    </summary>
    
    
      <category term="PAT" scheme="https://zs670980918.github.io/blogs/categories/PAT/"/>
    
      <category term="乙级" scheme="https://zs670980918.github.io/blogs/categories/PAT/%E4%B9%99%E7%BA%A7/"/>
    
      <category term="文章页" scheme="https://zs670980918.github.io/blogs/categories/PAT/%E4%B9%99%E7%BA%A7/%E6%96%87%E7%AB%A0%E9%A1%B5/"/>
    
    
  </entry>
  
  <entry>
    <title>Pat_1094（乙级）</title>
    <link href="https://zs670980918.github.io/blogs/2019/03/18/pat-1094-yi-ji/"/>
    <id>https://zs670980918.github.io/blogs/2019/03/18/pat-1094-yi-ji/</id>
    <published>2019-03-18T03:36:06.000Z</published>
    <updated>2019-12-27T02:15:57.213Z</updated>
    
    <content type="html"><![CDATA[<p>1094 谷歌的招聘 （20 分) <a href="https://pintia.cn/problem-sets/994805260223102976/problems/1071785997033074688" target="_blank" rel="noopener">原文地址</a></p><p>2004 年 7 月，谷歌在硅谷的 101 号公路边竖立了一块巨大的广告牌（如下图）用于招聘。内容超级简单，就是一个以 .com 结尾的网址，而前面的网址是一个 10 位素数，这个素数是自然常数 e 中最早出现的 10 位连续数字。能找出这个素数的人，就可以通过访问谷歌的这个网站进入招聘流程的下一步。 <img src="https://images.ptausercontent.com/57148679-d574-4f49-b048-775c6c07791c.jpg" alt="prime.jpg"> 自然常数 e 是一个著名的超越数，前面若干位写出来是这样的：e = 2.71828182845904523536028747135266249775724709369995957496696762772407663035354759457138217852516642<strong>7427466391</strong>932003059921… 其中粗体标出的 10 位数就是答案。 本题要求你编程解决一个更通用的问题：从任一给定的长度为 L 的数字中，找出最早出现的 K 位连续数字所组成的素数。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出 2 个正整数，分别是 L（不超过 1000 的正整数，为数字长度）和 K（小于 10 的正整数）。接下来一行给出一个长度为 L 的正整数 N。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出 N 中最早出现的 K 位连续数字所组成的素数。如果这样的素数不存在，则输出 <code>404</code>。注意，原始数字中的前导零也计算在位数之内。例如在 200236 中找 4 位素数，0023 算是解；但第一位 2 不能被当成 0002 输出，因为在原始数字中不存在这个 2 的前导零。</p><h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例 1："></a>输入样例 1：</h3><pre><code>20 523654987725541023819</code></pre><h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例 1："></a>输出样例 1：</h3><pre><code>49877</code></pre><h3 id="输入样例-2："><a href="#输入样例-2：" class="headerlink" title="输入样例 2："></a>输入样例 2：</h3><pre><code>10 32468024680</code></pre><h3 id="输出样例-2："><a href="#输出样例-2：" class="headerlink" title="输出样例 2："></a>输出样例 2：</h3><pre><code>404</code></pre><p>代码：</p><p>#include <iostream><br>#include <string><br>using namespace std;</p><p>// 判断是否为素数<br>bool isprime(long long x){<br>    if(x==0 || x==1){<br>        return false;<br>    }<br>    for(int i=2;i*i&lt;=x;++i){<br>        if(x%i==0){<br>            return false;<br>        }<br>    }<br>    return true;<br>} </p><p>// 1094 谷歌的招聘 （20 point(s)）<br>int main(void){<br>    long long n,k,out=-1;<br>    string s;<br>    cin&gt;&gt;n&gt;&gt;k&gt;&gt;s; </p><pre><code>for(int i=k;i&lt;=n;++i){    long long t = stoi(s.substr(i-k,k)); // 字符串截取    if(isprime(t)){ // 判断素数        out=i-k;        break;    }} if(out != -1){ // 如 0002 ，不应该输出 2    cout&lt;&lt;s.substr(out,k)&lt;&lt;endl;}else{    cout&lt;&lt;&quot;404&quot;&lt;&lt;endl;}return 0;</code></pre><p>} // guangjinzheng 2019.1.14 15:02</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1094 谷歌的招聘 （20 分) &lt;a href=&quot;https://pintia.cn/problem-sets/994805260223102976/problems/1071785997033074688&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;
      
    
    </summary>
    
    
      <category term="PAT" scheme="https://zs670980918.github.io/blogs/categories/PAT/"/>
    
      <category term="乙级" scheme="https://zs670980918.github.io/blogs/categories/PAT/%E4%B9%99%E7%BA%A7/"/>
    
      <category term="文章页" scheme="https://zs670980918.github.io/blogs/categories/PAT/%E4%B9%99%E7%BA%A7/%E6%96%87%E7%AB%A0%E9%A1%B5/"/>
    
    
  </entry>
  
  <entry>
    <title>Pat_1093（乙级）</title>
    <link href="https://zs670980918.github.io/blogs/2019/03/18/pat-1093-yi-ji/"/>
    <id>https://zs670980918.github.io/blogs/2019/03/18/pat-1093-yi-ji/</id>
    <published>2019-03-18T03:35:13.000Z</published>
    <updated>2019-12-27T02:15:57.213Z</updated>
    
    <content type="html"><![CDATA[<p>1093 字符串A+B （20 分) <a href="https://pintia.cn/problem-sets/994805260223102976/problems/1071785884776722432" target="_blank" rel="noopener">原文地址</a></p><p>给定两个字符串 A 和 B，本题要求你输出 A+B，即两个字符串的并集。要求先输出 A，再输出 B，但<strong>重复的字符必须被剔除</strong>。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在两行中分别给出 A 和 B，均为长度不超过 10​6​​的、由可见 ASCII 字符 (即码值为32~126)和空格组成的、由回车标识结束的非空字符串。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出题面要求的 A 和 B 的和。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code>This is a sample testto show you_How it works</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code>This ampletowyu_Hrk</code></pre><p>代码：</p><p>#include<iostream><br>#include&lt;string.h&gt;<br>#include<vector><br>#include<algorithm></p><p>using namespace std;</p><p>int main(){<br>    string s1,s2;<br>    getline(cin,s1);<br>    getline(cin,s2);<br>    vector<char> dir;<br>    for(int i=0;i&lt;s1.length();i++){<br>        if(find(dir.begin(),dir.end(),s1[i]) == dir.end()){<br>            cout&lt;&lt;s1[i];<br>            dir.push_back(s1[i]);<br>        }<br>    }<br>    for(int i=0;i&lt;s2.length();i++){<br>        if(find(dir.begin(),dir.end(),s2[i]) == dir.end()){<br>            cout&lt;&lt;s2[i];<br>            dir.push_back(s2[i]);<br>        }<br>    }<br>    cout&lt;&lt;endl;<br>    return 0;<br>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1093 字符串A+B （20 分) &lt;a href=&quot;https://pintia.cn/problem-sets/994805260223102976/problems/1071785884776722432&quot; target=&quot;_blank&quot; rel=&quot;noopener
      
    
    </summary>
    
    
      <category term="PAT" scheme="https://zs670980918.github.io/blogs/categories/PAT/"/>
    
      <category term="乙级" scheme="https://zs670980918.github.io/blogs/categories/PAT/%E4%B9%99%E7%BA%A7/"/>
    
      <category term="文章页" scheme="https://zs670980918.github.io/blogs/categories/PAT/%E4%B9%99%E7%BA%A7/%E6%96%87%E7%AB%A0%E9%A1%B5/"/>
    
    
  </entry>
  
  <entry>
    <title>Pat_1092（乙级）</title>
    <link href="https://zs670980918.github.io/blogs/2019/03/18/pat-1092-yi-ji/"/>
    <id>https://zs670980918.github.io/blogs/2019/03/18/pat-1092-yi-ji/</id>
    <published>2019-03-18T03:34:22.000Z</published>
    <updated>2019-12-27T02:15:57.213Z</updated>
    
    <content type="html"><![CDATA[<p>1092 最好吃的月饼 （20 分) <a href="https://pintia.cn/problem-sets/994805260223102976/problems/1071785779399028736" target="_blank" rel="noopener">原文地址</a></p><p>月饼是久负盛名的中国传统糕点之一，自唐朝以来，已经发展出几百品种。 <img src="https://images.ptausercontent.com/fcb325a0-7090-4bf4-acb0-d4d7ea832f27.jpg" alt="mk.jpg"> 若想评比出一种“最好吃”的月饼，那势必在吃货界引发一场腥风血雨…… 在这里我们用数字说话，给出全国各地各种月饼的销量，要求你从中找出销量冠军，认定为最好吃的月饼。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入首先给出两个正整数 N（≤1000）和 M（≤100），分别为月饼的种类数（于是默认月饼种类从 1 到 N 编号）和参与统计的城市数量。 接下来 M 行，每行给出 N 个非负整数（均不超过 1 百万），其中第 i 个整数为第 i 种月饼的销量（块）。数字间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在第一行中输出最大销量，第二行输出销量最大的月饼的种类编号。如果冠军不唯一，则按编号递增顺序输出并列冠军。数字间以 1 个空格分隔，行首尾不得有多余空格。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code>5 31001 992 0 233 68 0 2018 0 200836 18 0 1024 4</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code>20183 5</code></pre><p>代码：</p><p>#include&lt;stdio.h&gt;</p><p>int main()<br>{<br>    int N, M, flag = 0, max = 0;<br>    scanf(“%d %d”, &amp;N, &amp;M);<br>    int sale[N];<br>    for(int i = 0; i &lt; N; i++)    sale[i] = 0;<br>    for(int i = 0; i &lt; M; i++){<br>        for(int j = 0; j &lt; N; j++){<br>            int s;<br>            scanf(“%d”, &amp;s);<br>            sale[j] += s;<br>            if(max &lt; sale[j])     max = sale[j];    //当月饼销量统计完成后，也得到了最大销量<br>        }<br>    }<br>    printf(“%d\n”, max);<br>    for(int i = 0; i &lt; N; i++){<br>        if(sale[i] == max){<br>            if(flag == 0)  flag = 1;<br>            else           printf(“ “);        //用flag来控制空格的输出<br>            printf(“%d”, i+1);                 //注意i是从0开始的，而月饼种类是从1开始的<br>        }<br>    }<br>    return 0;<br>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1092 最好吃的月饼 （20 分) &lt;a href=&quot;https://pintia.cn/problem-sets/994805260223102976/problems/1071785779399028736&quot; target=&quot;_blank&quot; rel=&quot;noopener
      
    
    </summary>
    
    
      <category term="PAT" scheme="https://zs670980918.github.io/blogs/categories/PAT/"/>
    
      <category term="乙级" scheme="https://zs670980918.github.io/blogs/categories/PAT/%E4%B9%99%E7%BA%A7/"/>
    
      <category term="文章页" scheme="https://zs670980918.github.io/blogs/categories/PAT/%E4%B9%99%E7%BA%A7/%E6%96%87%E7%AB%A0%E9%A1%B5/"/>
    
    
  </entry>
  
  <entry>
    <title>Pat_1091（乙级）</title>
    <link href="https://zs670980918.github.io/blogs/2019/03/18/pat-1091-yi-ji/"/>
    <id>https://zs670980918.github.io/blogs/2019/03/18/pat-1091-yi-ji/</id>
    <published>2019-03-18T03:33:20.000Z</published>
    <updated>2019-12-27T02:15:57.213Z</updated>
    
    <content type="html"><![CDATA[<p>1091 N-自守数 （15 分) <a href="https://pintia.cn/problem-sets/994805260223102976/problems/1071785664454127616" target="_blank" rel="noopener">原文地址</a></p><p>如果某个数 K 的平方乘以 N 以后，结果的末尾几位数等于 K，那么就称这个数为“N-自守数”。例如 3×92​2​​=25392，而 25392 的末尾两位正好是 92，所以 92 是一个 3-自守数。 本题就请你编写程序判断一个给定的数字是否关于某个 N 是 N-自守数。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行中给出正整数 M（≤20），随后一行给出 M 个待检测的、不超过 1000 的正整数。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每个需要检测的数字，如果它是 N-自守数就在一行中输出最小的 N 和 NK​2​​ 的值，以一个空格隔开；否则输出 <code>No</code>。注意题目保证 N&lt;10。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code>392 5 233</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code>3 253921 25No</code></pre><p>代码：</p><p>#include<iostream><br>#include&lt;string.h&gt;<br>#include<algorithm></p><p>using namespace std;<br>//思想：这里采用了大数乘法 按照题目要求计算result 然后使用reverse进行结果逆转 然后使用find进行匹配如果为0则证明以temp结尾<br>string BigNumberMult(string s1,string s2){<br>    string s(10000,’0’);<br>    reverse(s1.begin(),s1.end());<br>    reverse(s2.begin(),s2.end());<br>    for(int i=0;i&lt;s1.length();i++){<br>        for(int j=0;j&lt;s2.length();j++){<br>            int temp = (s1[i] - ‘0’) * (s2[j] - ‘0’);<br>            s[i+j+1] = s[i+j+1] - ‘0’ + (s[i+j] - ‘0’ + temp) / 10 + ‘0’;<br>            s[i+j] = (s[i+j] - ‘0’ + temp) % 10 + ‘0’;<br>        }<br>    }<br>    reverse(s.begin(),s.end());<br>    if(s.find_first_not_of(‘0’) == string::npos){<br>        return “0”;<br>    }<br>    else{<br>        return s.substr(s.find_first_not_of(‘0’));<br>    }<br>}<br>//匹配函数<br>bool judge(string s1,string s2){<br>    reverse(s1.begin(),s1.end());<br>    reverse(s2.begin(),s2.end());<br>    if(s1.find(s2) == 0){<br>        return true;<br>    }<br>    return false;<br>}</p><p>int main(){<br>    int num;<br>    cin&gt;&gt;num;<br>    string tt[num];<br>    for(int i=0;i&lt;num;i++){<br>        cin&gt;&gt;tt[i];<br>    }<br>    for(int i=0;i&lt;num;i++){<br>        string temp,result;<br>        temp = BigNumberMult(tt[i],tt[i]);<br>        result = temp;<br>        int counts = 0;<br>        bool flag = true;<br>        while(counts &lt; 10){<br>            string t = “”;<br>            t += (counts + 1 + ‘0’);<br>            result = BigNumberMult(temp,t);<br>            if(judge(result,tt[i])){<br>                flag = false;<br>                break;<br>            }<br>            counts++;<br>        }<br>        if(flag){<br>            cout&lt;&lt;”No”&lt;&lt;endl;<br>        }<br>        else{<br>            cout&lt;&lt;counts+1&lt;&lt;” “&lt;&lt;result&lt;&lt;endl;<br>        }<br>    }<br>    return 0;<br>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1091 N-自守数 （15 分) &lt;a href=&quot;https://pintia.cn/problem-sets/994805260223102976/problems/1071785664454127616&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;
      
    
    </summary>
    
    
      <category term="PAT" scheme="https://zs670980918.github.io/blogs/categories/PAT/"/>
    
      <category term="乙级" scheme="https://zs670980918.github.io/blogs/categories/PAT/%E4%B9%99%E7%BA%A7/"/>
    
      <category term="文章页" scheme="https://zs670980918.github.io/blogs/categories/PAT/%E4%B9%99%E7%BA%A7/%E6%96%87%E7%AB%A0%E9%A1%B5/"/>
    
    
  </entry>
  
  <entry>
    <title>Pat_1090（乙级）</title>
    <link href="https://zs670980918.github.io/blogs/2019/03/18/pat-1090-yi-ji/"/>
    <id>https://zs670980918.github.io/blogs/2019/03/18/pat-1090-yi-ji/</id>
    <published>2019-03-18T03:32:10.000Z</published>
    <updated>2019-12-27T02:15:57.213Z</updated>
    
    <content type="html"><![CDATA[<p>1090 危险品装箱 （25 分) <a href="https://pintia.cn/problem-sets/994805260223102976/problems/1038429484026175488" target="_blank" rel="noopener">原文地址</a></p><p>集装箱运输货物时，我们必须特别小心，不能把不相容的货物装在一只箱子里。比如氧化剂绝对不能跟易燃液体同箱，否则很容易造成爆炸。 本题给定一张不相容物品的清单，需要你检查每一张集装箱货品清单，判断它们是否能装在同一只箱子里。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出两个正整数：N (≤10​4​​) 是成对的不相容物品的对数；M (≤100) 是集装箱货品清单的单数。 随后数据分两大块给出。第一块有 N 行，每行给出一对不相容的物品。第二块有 M 行，每行给出一箱货物的清单，格式如下：</p><pre><code>K G[1] G[2] ... G[K]</code></pre><p>其中 <code>K</code> (≤1000) 是物品件数，<code>G[i]</code> 是物品的编号。简单起见，每件物品用一个 5 位数的编号代表。两个数字之间用空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每箱货物清单，判断是否可以安全运输。如果没有不相容物品，则在一行中输出 <code>Yes</code>，否则输出 <code>No</code>。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code>6 320001 2000220003 2000420005 2000620003 2000120005 2000420004 200064 00001 20004 00002 200035 98823 20002 20003 20006 100103 12345 67890 23333</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code>NoYesYes</code></pre><p>代码：</p><p>#include<iostream><br>#include<map><br>#include<vector><br>#include<algorithm><br>#include<cstdio><br>//注意本题不要使用 string 作为map的key和value 这样会在测试点四种使用C++读取时会花费大量的时间导致超时<br>//而是用int scanf则会大大缩短时间<br>using namespace std;</p><p>int main(){<br>    map&lt;int,vector<int> &gt; dir;<br>    //map&lt;string,vector<string> &gt;::iterator pos;<br>    int N,M;<br>    scanf(“%d %d”,&amp;N,&amp;M);<br>    //创建每个元素对应的不能够相容的名称列表<br>    for(int i=0;i&lt;N;i++){<br>        int t1,t2;<br>        scanf(“%d %d”,&amp;t1,&amp;t2);<br>        dir[t1].push_back(t2);<br>        dir[t2].push_back(t1);<br>    }<br>    /<em>for(pos=dir.begin();pos!=dir.end();pos++){<br>        cout&lt;&lt;(<em>pos).first&lt;&lt;” : “;<br>        for(int i=0;i&lt;((</em>pos).second).size();i++){<br>            cout&lt;&lt;((*pos).second)[i]&lt;&lt;” “;<br>        }<br>        cout&lt;&lt;endl;<br>    }</em>/<br>    for(int i=0;i&lt;M;i++){<br>        bool flag = false;<br>        int num;<br>        scanf(“%d”,&amp;num);<br>        vector<int> list1;<br>        for(int j=0;j&lt;num;j++){<br>            int temp;<br>            scanf(“%d”,&amp;temp);<br>            //遍历key值对应的value容器中是否存在于list1中如果存在则为No<br>            if(!flag){<br>                for(int k=0;k&lt;dir[temp].size();k++){<br>                   if(count(list1.begin(),list1.end(),dir[temp][k]) != 0){<br>                        flag = true;<br>                    }<br>                }<br>            }<br>            list1.push_back(temp);<br>        }<br>        if(flag){<br>            cout&lt;&lt;”No”&lt;&lt;endl;<br>        }<br>        else{<br>            cout&lt;&lt;”Yes”&lt;&lt;endl;<br>        }<br>    }<br>    return 0;<br>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1090 危险品装箱 （25 分) &lt;a href=&quot;https://pintia.cn/problem-sets/994805260223102976/problems/1038429484026175488&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;
      
    
    </summary>
    
    
      <category term="PAT" scheme="https://zs670980918.github.io/blogs/categories/PAT/"/>
    
      <category term="乙级" scheme="https://zs670980918.github.io/blogs/categories/PAT/%E4%B9%99%E7%BA%A7/"/>
    
      <category term="文章页" scheme="https://zs670980918.github.io/blogs/categories/PAT/%E4%B9%99%E7%BA%A7/%E6%96%87%E7%AB%A0%E9%A1%B5/"/>
    
    
  </entry>
  
  <entry>
    <title>Pat_1089（乙级）</title>
    <link href="https://zs670980918.github.io/blogs/2019/03/18/pat-1089-yi-ji/"/>
    <id>https://zs670980918.github.io/blogs/2019/03/18/pat-1089-yi-ji/</id>
    <published>2019-03-18T03:31:06.000Z</published>
    <updated>2019-12-27T02:15:57.213Z</updated>
    
    <content type="html"><![CDATA[<p>1089 狼人杀-简单版 （20 分) <a href="https://pintia.cn/problem-sets/994805260223102976/problems/1038429385296453632" target="_blank" rel="noopener">原文地址</a></p><p>以下文字摘自《灵机一动·好玩的数学》：“狼人杀”游戏分为狼人、好人两大阵营。在一局“狼人杀”游戏中，1 号玩家说：“2 号是狼人”，2 号玩家说：“3 号是好人”，3 号玩家说：“4 号是狼人”，4 号玩家说：“5 号是好人”，5 号玩家说：“4 号是好人”。已知这 5 名玩家中有 2 人扮演狼人角色，有 2 人说的不是实话，有狼人撒谎但并不是所有狼人都在撒谎。扮演狼人角色的是哪两号玩家？ 本题是这个问题的升级版：已知 N 名玩家中有 2 人扮演狼人角色，有 2 人说的不是实话，有狼人撒谎但并不是所有狼人都在撒谎。要求你找出扮演狼人角色的是哪几号玩家？</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行中给出一个正整数 N（5≤N≤100）。随后 N 行，第 i 行给出第 i 号玩家说的话（1≤i≤N），即一个玩家编号，用正号表示好人，负号表示狼人。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>如果有解，在一行中按递增顺序输出 2 个狼人的编号，其间以空格分隔，行首尾不得有多余空格。如果解不唯一，则输出最小序列解 —— 即对于两个序列 A=a[1],…,a[M] 和 B=b[1],…,b[M]，若存在 0≤k&lt;M 使得 a[i]=b[i] （i≤k），且 a[k+1]&lt;b[k+1]，则称序列 A 小于序列 B。若无解则输出 <code>No Solution</code>。</p><h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例 1："></a>输入样例 1：</h3><pre><code>5-2+3-4+5+4</code></pre><h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例 1："></a>输出样例 1：</h3><pre><code>1 4</code></pre><h3 id="输入样例-2："><a href="#输入样例-2：" class="headerlink" title="输入样例 2："></a>输入样例 2：</h3><pre><code>6+6+3+1-5-2+4</code></pre><h3 id="输出样例-2（解不唯一）："><a href="#输出样例-2（解不唯一）：" class="headerlink" title="输出样例 2（解不唯一）："></a>输出样例 2（解不唯一）：</h3><pre><code>1 5</code></pre><h3 id="输入样例-3："><a href="#输入样例-3：" class="headerlink" title="输入样例 3："></a>输入样例 3：</h3><pre><code>5-2-3-4-5-1</code></pre><h3 id="输出样例-3："><a href="#输出样例-3：" class="headerlink" title="输出样例 3："></a>输出样例 3：</h3><pre><code>No Solution</code></pre><p>代码：</p><p>#include <iostream><br>#include <vector><br>#include <cmath><br>/<em>每个人说的数字保存在v数组中，i从1～n、j从i+1～n遍历，分别假设i和j是狼人，a数组表示该人是狼人还是好人，等于1表示是好人，<br>等于-1表示是狼人。k从1～n分别判断k所说的话是真是假，k说的话和真实情况不同（即v[k] * a[abs(v[k])] &lt; 0）则表示k在说谎，<br>则将k放在lie数组中；遍历完成后判断lie数组，如果说谎人数等于2并且这两个说谎的人一个是好人一个是狼人（即a[lie[0]] + a[lie[1]] == 0）<br>表示满足题意，此时输出i和j并return，否则最后的时候输出No Solution～</em>/</p><p>using namespace std;<br>int main() {<br>    int n;<br>    cin &gt;&gt; n;<br>    vector<int> v(n+1);<br>    for (int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i];<br>    for (int i = 1; i &lt;= n; i++) {<br>        for (int j = i + 1; j &lt;= n; j++) {<br>            vector<int> lie, a(n + 1, 1);<br>            a[i] = a[j] = -1;<br>            for (int k = 1; k &lt;= n; k++)<br>                if (v[k] * a[abs(v[k])] &lt; 0) lie.push_back(k);<br>            if (lie.size() == 2 &amp;&amp; a[lie[0]] + a[lie[1]] == 0) {<br>                cout &lt;&lt; i &lt;&lt; “ “ &lt;&lt; j;<br>                return 0;<br>            }<br>        }<br>    }<br>    cout &lt;&lt; “No Solution”;<br>    return 0;<br>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1089 狼人杀-简单版 （20 分) &lt;a href=&quot;https://pintia.cn/problem-sets/994805260223102976/problems/1038429385296453632&quot; target=&quot;_blank&quot; rel=&quot;noopene
      
    
    </summary>
    
    
      <category term="PAT" scheme="https://zs670980918.github.io/blogs/categories/PAT/"/>
    
      <category term="乙级" scheme="https://zs670980918.github.io/blogs/categories/PAT/%E4%B9%99%E7%BA%A7/"/>
    
      <category term="文章页" scheme="https://zs670980918.github.io/blogs/categories/PAT/%E4%B9%99%E7%BA%A7/%E6%96%87%E7%AB%A0%E9%A1%B5/"/>
    
    
  </entry>
  
  <entry>
    <title>Pat_1088（乙级）</title>
    <link href="https://zs670980918.github.io/blogs/2019/03/18/pat-1088-yi-ji/"/>
    <id>https://zs670980918.github.io/blogs/2019/03/18/pat-1088-yi-ji/</id>
    <published>2019-03-18T03:30:11.000Z</published>
    <updated>2019-12-27T02:15:57.213Z</updated>
    
    <content type="html"><![CDATA[<p>1088 三人行 （20 分) <a href="https://pintia.cn/problem-sets/994805260223102976/problems/1038429286185074688" target="_blank" rel="noopener">原文地址</a></p><p>子曰：“三人行，必有我师焉。择其善者而从之，其不善者而改之。” 本题给定甲、乙、丙三个人的能力值关系为：甲的能力值确定是 2 位正整数；把甲的能力值的 2 个数字调换位置就是乙的能力值；甲乙两人能力差是丙的能力值的 X 倍；乙的能力值是丙的 Y 倍。请你指出谁比你强应“从之”，谁比你弱应“改之”。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中给出三个数，依次为：M（你自己的能力值）、X 和 Y。三个数字均为不超过 1000 的正整数。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中首先输出甲的能力值，随后依次输出甲、乙、丙三人与你的关系：如果其比你强，输出 <code>Cong</code>；平等则输出 <code>Ping</code>；比你弱则输出 <code>Gai</code>。其间以 1 个空格分隔，行首尾不得有多余空格。 注意：如果解不唯一，则以甲的最大解为准进行判断；如果解不存在，则输出 <code>No Solution</code>。</p><h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例 1："></a>输入样例 1：</h3><pre><code>48 3 7</code></pre><h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例 1："></a>输出样例 1：</h3><pre><code>48 Ping Cong Gai</code></pre><h3 id="输入样例-2："><a href="#输入样例-2：" class="headerlink" title="输入样例 2："></a>输入样例 2：</h3><pre><code>48 11 6</code></pre><h3 id="输出样例-2："><a href="#输出样例-2：" class="headerlink" title="输出样例 2："></a>输出样例 2：</h3><pre><code>No Solution</code></pre><p>代码：</p><p>#include<iostream><br>#include<cmath></p><p>using namespace std;</p><p>void judge(double a,int b){<br>    if(a &gt; b){<br>        cout&lt;&lt;”Cong”;<br>    }<br>    else if(a == b){<br>        cout&lt;&lt;”Ping”;<br>    }<br>    else{<br>        cout&lt;&lt;”Gai”;<br>    }<br>}</p><p>int main(){<br>    bool flag = true;<br>    int me,X,Y;<br>    cin&gt;&gt;me&gt;&gt;X&gt;&gt;Y;<br>    for(int i=99;i&gt;=10;i–){ // 则以甲的最大解为准进行判断<br>        int yi = i/10 + (i%10)<em>10;<br>        if(abs(i-yi)\</em>Y == yi*X){<br>            double temp = (abs(i-yi)<em>1.0)/X;<br>            cout&lt;&lt;i&lt;&lt;” “;<br>            //cout&lt;&lt;i&lt;&lt;” “&lt;&lt;yi&lt;&lt;” “&lt;&lt;yi</em>X&lt;&lt;endl;<br>            judge(i,me);<br>            cout&lt;&lt;” “;<br>            judge(yi,me);<br>            cout&lt;&lt;” “;<br>            judge(temp,me);<br>            cout&lt;&lt;endl;<br>            flag = false;<br>            break;<br>        }<br>    }<br>    if(flag){<br>        cout&lt;&lt;”No Solution”&lt;&lt;endl;<br>    }<br>    return 0;<br>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1088 三人行 （20 分) &lt;a href=&quot;https://pintia.cn/problem-sets/994805260223102976/problems/1038429286185074688&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原
      
    
    </summary>
    
    
      <category term="PAT" scheme="https://zs670980918.github.io/blogs/categories/PAT/"/>
    
      <category term="乙级" scheme="https://zs670980918.github.io/blogs/categories/PAT/%E4%B9%99%E7%BA%A7/"/>
    
      <category term="文章页" scheme="https://zs670980918.github.io/blogs/categories/PAT/%E4%B9%99%E7%BA%A7/%E6%96%87%E7%AB%A0%E9%A1%B5/"/>
    
    
  </entry>
  
  <entry>
    <title>Pat_1087（乙级）</title>
    <link href="https://zs670980918.github.io/blogs/2019/03/18/pat-1087-yi-ji/"/>
    <id>https://zs670980918.github.io/blogs/2019/03/18/pat-1087-yi-ji/</id>
    <published>2019-03-18T03:28:58.000Z</published>
    <updated>2019-12-27T02:15:57.213Z</updated>
    
    <content type="html"><![CDATA[<p>1087 有多少不同的值 （20 分) <a href="https://pintia.cn/problem-sets/994805260223102976/problems/1038429191091781632" target="_blank" rel="noopener">原文地址</a></p><p>当自然数 n 依次取 1、2、3、……、N 时，算式 ⌊n/2⌋+⌊n/3⌋+⌊n/5⌋ 有多少个不同的值？（注：⌊x⌋ 为取整函数，表示不超过 x 的最大自然数，即 x 的整数部分。）</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入给出一个正整数 N（2≤N≤10​4​​）。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出题面中算式取到的不同值的个数。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code>2017</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code>1480</code></pre><p>代码：</p><p>#include<iostream><br>#include<vector><br>#include<algorithm><br>#include&lt;math.h&gt;</p><p>using namespace std;</p><p>int main(){<br>    vector<int> dir;<br>    int n;<br>    int num = 0;<br>    cin&gt;&gt;n;<br>    for(int i=1;i&lt;=n;i++){<br>        int sum = floor(float(i/2)) + floor(float(i/3)) + floor(float(i/5));<br>        if(count(dir.begin(),dir.end(),sum) == 0){<br>            dir.push_back(sum);<br>            num++;<br>        }<br>    }<br>    cout&lt;&lt;num&lt;&lt;endl;<br>    return 0;<br>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1087 有多少不同的值 （20 分) &lt;a href=&quot;https://pintia.cn/problem-sets/994805260223102976/problems/1038429191091781632&quot; target=&quot;_blank&quot; rel=&quot;noopene
      
    
    </summary>
    
    
      <category term="PAT" scheme="https://zs670980918.github.io/blogs/categories/PAT/"/>
    
      <category term="乙级" scheme="https://zs670980918.github.io/blogs/categories/PAT/%E4%B9%99%E7%BA%A7/"/>
    
      <category term="文章页" scheme="https://zs670980918.github.io/blogs/categories/PAT/%E4%B9%99%E7%BA%A7/%E6%96%87%E7%AB%A0%E9%A1%B5/"/>
    
    
  </entry>
  
  <entry>
    <title>Pat_1086（乙级）</title>
    <link href="https://zs670980918.github.io/blogs/2019/03/18/pat-1086-yi-ji/"/>
    <id>https://zs670980918.github.io/blogs/2019/03/18/pat-1086-yi-ji/</id>
    <published>2019-03-18T03:28:08.000Z</published>
    <updated>2019-12-27T02:15:57.213Z</updated>
    
    <content type="html"><![CDATA[<p>1086 就不告诉你 （15 分) <a href="https://pintia.cn/problem-sets/994805260223102976/problems/1038429065476579328" target="_blank" rel="noopener">原文地址</a></p><p>做作业的时候，邻座的小盆友问你：“五乘以七等于多少？”你应该不失礼貌地围笑着告诉他：“五十三。”本题就要求你，对任何一对给定的正整数，倒着输出它们的乘积。 <img src="https://images.ptausercontent.com/0c3a4497-27c3-45ea-9c8e-5a1ab2df48af.jpg" alt="53.jpg"></p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出两个不超过 1000 的正整数 A 和 B，其间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中倒着输出 A 和 B 的乘积。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code>5 7</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code>53</code></pre><p>代码：</p><p>#include<iostream><br>#include&lt;string.h&gt;<br>#include<algorithm></p><p>using namespace std;</p><p>string BigNumberMult(){<br>    string s1,s2,s(10000,’0’);<br>    cin&gt;&gt;s1&gt;&gt;s2;<br>    reverse(s1.begin(),s1.end());<br>    reverse(s2.begin(),s2.end());<br>    for(int i=0;i&lt;s1.length();i++){<br>        for(int j=0;j&lt;s2.length();j++){<br>            int temp = (s1[i] - ‘0’) * (s2[j] - ‘0’);<br>            s[i+j+1] = s[i+j+1] - ‘0’ + (s[i+j] - ‘0’ + temp) / 10 + ‘0’;<br>            s[i+j] = (s[i+j] - ‘0’ + temp) % 10 + ‘0’;<br>        }<br>    }<br>    reverse(s.begin(),s.end());<br>    if(s.find_first_not_of(‘0’) == string::npos){<br>        return “0”;<br>    }<br>    else{<br>        return s.substr(s.find_first_not_of(‘0’));<br>    }<br>}</p><p>int main(){<br>    string result;<br>    result = BigNumberMult();<br>    reverse(result.begin(),result.end());<br>    cout&lt;&lt;result.substr(result.find_first_not_of(‘0’))&lt;&lt;endl; //对于 10 * 10 得到的100 要将001处理为1<br>    return 0;<br>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1086 就不告诉你 （15 分) &lt;a href=&quot;https://pintia.cn/problem-sets/994805260223102976/problems/1038429065476579328&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;
      
    
    </summary>
    
    
      <category term="PAT" scheme="https://zs670980918.github.io/blogs/categories/PAT/"/>
    
      <category term="乙级" scheme="https://zs670980918.github.io/blogs/categories/PAT/%E4%B9%99%E7%BA%A7/"/>
    
      <category term="文章页" scheme="https://zs670980918.github.io/blogs/categories/PAT/%E4%B9%99%E7%BA%A7/%E6%96%87%E7%AB%A0%E9%A1%B5/"/>
    
    
  </entry>
  
  <entry>
    <title>Pat_1085（乙级）</title>
    <link href="https://zs670980918.github.io/blogs/2019/03/18/pat-1085-yi-ji/"/>
    <id>https://zs670980918.github.io/blogs/2019/03/18/pat-1085-yi-ji/</id>
    <published>2019-03-18T03:25:36.000Z</published>
    <updated>2019-12-27T02:15:57.213Z</updated>
    
    <content type="html"><![CDATA[<p>1085 PAT单位排行 （25 分) <a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805260353126400" target="_blank" rel="noopener">原文地址</a></p><p>每次 PAT 考试结束后，考试中心都会发布一个考生单位排行榜。本题就请你实现这个功能。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出一个正整数 N（≤10​5​​），即考生人数。随后 N 行，每行按下列格式给出一个考生的信息：</p><pre><code>准考证号 得分 学校</code></pre><p>其中<code>准考证号</code>是由 6 个字符组成的字符串，其首字母表示考试的级别：<code>B</code>代表乙级，<code>A</code>代表甲级，<code>T</code>代表顶级；<code>得分</code>是 [0, 100] 区间内的整数；<code>学校</code>是由不超过 6 个英文字母组成的单位码（大小写无关）。注意：题目保证每个考生的准考证号是不同的。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>首先在一行中输出单位个数。随后按以下格式非降序输出单位的排行榜：</p><pre><code>排名 学校 加权总分 考生人数</code></pre><p>其中<code>排名</code>是该单位的排名（从 1 开始）；<code>学校</code>是全部按小写字母输出的单位码；<code>加权总分</code>定义为<code>乙级总分/1.5 + 甲级总分 + 顶级总分*1.5</code>的<strong>整数部分</strong>；<code>考生人数</code>是该属于单位的考生的总人数。 学校首先按加权总分排行。如有并列，则应对应相同的排名，并按考生人数升序输出。如果仍然并列，则按单位码的字典序输出。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code>10A57908 85 AuB57908 54 LanXA37487 60 auT28374 67 CMUT32486 24 hypuA66734 92 cmuB76378 71 AUA47780 45 lanxA72809 100 pkuA03274 45 hypu</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code>51 cmu 192 21 au 192 33 pku 100 14 hypu 81 24 lanx 81 2</code></pre><p>代码：</p><p>#include<iostream><br>#include<string><br>#include<algorithm><br>#include<map><br>#include<set><br>using namespace std;<br>struct school {<br>    string id;   //再次存入id方便后来从map转入set<br>    map&lt;char, int&gt; mark;    //这里用map记录各级比赛的成绩<br>    int num = 0, sum = 0;   //num记录该校人数，sum为总分<br>};<br>struct cmp {         //自定义set的比较方式<br>    bool operator()(const school&amp;a, const school &amp;b) {<br>        if (a.sum == b.sum) {<br>            if (a.num == b.num)<br>                return a.id &lt; b.id;<br>            return a.num &lt; b.num;<br>        }<br>        return a.sum &gt; b.sum;<br>    }<br>};<br>int main() {<br>    map&lt;string, school&gt; k;<br>    int n, t, count = 1;<br>    cin &gt;&gt; n;<br>    string id, name;<br>    while (n–) {             //录入数据<br>        cin &gt;&gt; id &gt;&gt; t &gt;&gt; name;<br>        transform(name.begin(), name.end(), name.begin(), ::tolower);    //将学校的字符化为小写<br>        k[name].mark[id[0]] += t;         //记住这里的+=，因为可能存在同一学校的不同学生参加了同级比赛。<br>        k[name].id = name;<br>        k[name].num++;        //该校人数计数器<br>    }<br>    set&lt;school, cmp&gt; rk;<br>    for (auto it = k.begin(); it != k.end(); it++) {    //在计算总分后将结构体插到set里面<br>        it-&gt;second.sum = (double)it-&gt;second.mark[‘B’] / 1.5 + it-&gt;second.mark[‘A’] + (double)it-&gt;second.mark[‘T’] * 1.5;<br>        rk.insert(it-&gt;second);<br>    }<br>    cout &lt;&lt; rk.size() &lt;&lt; endl;<br>    school pre;    //这里用前驱进行比较<br>    auto it = rk.begin();<br>    cout &lt;&lt; count &lt;&lt; “ “ &lt;&lt; it-&gt;id &lt;&lt; “ “ &lt;&lt; it-&gt;sum &lt;&lt; “ “ &lt;&lt; it-&gt;num &lt;&lt; endl;<br>    pre = *it;<br>    it++;<br>    int m = 2;<br>    for (; it != rk.end(); m++, it++) {<br>        if (it-&gt;sum != pre.sum)   //当前后的得分不同时，更新count<br>            count = m;<br>        printf(“%d %s %d %d\n”, count, it-&gt;id.c_str(), it-&gt;sum, it-&gt;num);<br>        pre = *it;<br>    }<br>    return 0;<br>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1085 PAT单位排行 （25 分) &lt;a href=&quot;https://pintia.cn/problem-sets/994805260223102976/problems/994805260353126400&quot; target=&quot;_blank&quot; rel=&quot;noopener
      
    
    </summary>
    
    
      <category term="PAT" scheme="https://zs670980918.github.io/blogs/categories/PAT/"/>
    
      <category term="乙级" scheme="https://zs670980918.github.io/blogs/categories/PAT/%E4%B9%99%E7%BA%A7/"/>
    
      <category term="文章页" scheme="https://zs670980918.github.io/blogs/categories/PAT/%E4%B9%99%E7%BA%A7/%E6%96%87%E7%AB%A0%E9%A1%B5/"/>
    
    
  </entry>
  
  <entry>
    <title>Pat_1084（乙级）</title>
    <link href="https://zs670980918.github.io/blogs/2019/03/18/pat-1084-yi-ji/"/>
    <id>https://zs670980918.github.io/blogs/2019/03/18/pat-1084-yi-ji/</id>
    <published>2019-03-18T03:23:59.000Z</published>
    <updated>2019-12-27T02:15:57.213Z</updated>
    
    <content type="html"><![CDATA[<p>1084 外观数列 （20 分) <a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805260583813120" target="_blank" rel="noopener">原文地址</a></p><p>外观数列是指具有以下特点的整数序列：</p><pre><code>d, d1, d111, d113, d11231, d112213111, ...</code></pre><p>它从不等于 1 的数字 <code>d</code> 开始，序列的第 n+1 项是对第 n 项的描述。比如第 2 项表示第 1 项有 1 个 <code>d</code>，所以就是 <code>d1</code>；第 2 项是 1 个 <code>d</code>（对应 <code>d1</code>）和 1 个 1（对应 11），所以第 3 项就是 <code>d111</code>。又比如第 4 项是 <code>d113</code>，其描述就是 1 个 <code>d</code>，2 个 1，1 个 3，所以下一项就是 <code>d11231</code>。当然这个定义对 <code>d</code> = 1 也成立。本题要求你推算任意给定数字 <code>d</code> 的外观数列的第 N 项。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出 [0,9] 范围内的一个整数 <code>d</code>、以及一个正整数 N（≤ 40），用空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中给出数字 <code>d</code> 的外观数列的第 N 项。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code>1 8</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code>1123123111</code></pre><p>代码：</p><p>#include<iostream><br>#include&lt;string.h&gt;<br>#include<algorithm></p><p>using namespace std;<br>//题目理解 是对于 d为第一项 则第二项就为d1（其中1）表示有一个d 第三项（针对第二项）就为d1（有一个d）11（有一个1）以此类推<br>//同样要注意 这里每次统计的是连续的相同的字符个数<br>//算法思想：从头到尾遍历字符串然后统计个数并添加到对应的数值后面之后下一次从上次统计结束的地方开始统计<br>int main(){<br>    string d;<br>    int num;<br>    cin&gt;&gt;d&gt;&gt;num;<br>    num–;<br>    //因为算法中先减了1所以对于 N等于1的情况要特殊处理<br>    if(num == 0){<br>        cout&lt;&lt;d&lt;&lt;endl;<br>        return 0;<br>    }<br>    string result = d + “1”;<br>    while(num &gt; 1){<br>        string s1=””;<br>        int index = 0;<br>        while(index &lt; result.length()){<br>            bool flag = true;<br>            int num1 = 1;<br>            int j;<br>            char temp = result[index];<br>            s1 += result[index++];<br>            for(j=index;j&lt;result.length();j++){<br>                if(temp != result[j]){<br>                    index = j;<br>                    flag  = false;<br>                    break;<br>                }<br>                else{<br>                    num1++;<br>                }<br>            }<br>            if(flag){ //如果全相等（如1111）则不会break 只会正常结束 因此要再次进行index赋值 否则不会按照统计后的位置进行<br>                index = j;<br>            }<br>            s1 += (num1 + ‘0’);<br>        }<br>        result = s1;<br>        num–;<br>    }<br>    cout&lt;&lt;result&lt;&lt;endl;<br>    return 0;<br>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1084 外观数列 （20 分) &lt;a href=&quot;https://pintia.cn/problem-sets/994805260223102976/problems/994805260583813120&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原
      
    
    </summary>
    
    
      <category term="PAT" scheme="https://zs670980918.github.io/blogs/categories/PAT/"/>
    
      <category term="乙级" scheme="https://zs670980918.github.io/blogs/categories/PAT/%E4%B9%99%E7%BA%A7/"/>
    
      <category term="文章页" scheme="https://zs670980918.github.io/blogs/categories/PAT/%E4%B9%99%E7%BA%A7/%E6%96%87%E7%AB%A0%E9%A1%B5/"/>
    
    
  </entry>
  
</feed>
