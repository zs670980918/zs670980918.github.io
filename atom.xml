<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>StriveZs的博客</title>
  
  <subtitle>Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="www.strivezs.com/"/>
  <updated>2021-04-25T11:28:47.264Z</updated>
  <id>www.strivezs.com/</id>
  
  <author>
    <name>StriveZs</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode No.93</title>
    <link href="www.strivezs.com/2021/04/25/LeetCode%E7%AC%AC%E4%B9%9D%E5%8D%81%E4%B8%89%E9%A2%98/"/>
    <id>www.strivezs.com/2021/04/25/LeetCode%E7%AC%AC%E4%B9%9D%E5%8D%81%E4%B8%89%E9%A2%98/</id>
    <published>2021-04-25T11:28:47.264Z</published>
    <updated>2021-04-25T11:28:47.264Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第九十三题—复原IP地址</h1><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定一个只包含数字的字符串，用以表示一个 IP 地址，返回所有可能从 s 获得的 有效 IP 地址 。你可以按任何顺序返回答案。</p><p>有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。</p><p>例如：“0.1.2.201” 和 “192.168.1.1” 是 有效 IP 地址，但是 “0.011.255.245”、“192.168.1.312” 和 “192.168@1.1” 是 无效 IP 地址。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"25525511135"</span></span><br><span class="line">输出：[<span class="string">"255.255.11.135"</span>,<span class="string">"255.255.111.35"</span>]</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"0000"</span></span><br><span class="line">输出：[<span class="string">"0.0.0.0"</span>]</span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"1111"</span></span><br><span class="line">输出：[<span class="string">"1.1.1.1"</span>]</span><br><span class="line">示例 <span class="number">4</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"010010"</span></span><br><span class="line">输出：[<span class="string">"0.10.0.10"</span>,<span class="string">"0.100.1.0"</span>]</span><br><span class="line">示例 <span class="number">5</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"101023"</span></span><br><span class="line">输出：[<span class="string">"1.0.10.23"</span>,<span class="string">"1.0.102.3"</span>,<span class="string">"10.1.0.23"</span>,<span class="string">"10.10.2.3"</span>,<span class="string">"101.0.2.3"</span>]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> &lt;= s.length &lt;= <span class="number">3000</span></span><br><span class="line">s 仅由数字组成</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><p>执行用时：36 ms, 在所有 Python3 提交中击败了94.35%的用户内存消耗：14.9 MB, 在所有 Python3 提交中击败了86.32%的用户</p><p>好像可以缩减一下代码QWQ</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def restoreIpAddresses(self, s):</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        :<span class="built_in">type</span> <span class="variable">s:</span> str</span><br><span class="line">        :rtype: List[str]</span><br><span class="line"></span><br><span class="line">        核心思想:</span><br><span class="line">                回溯算法</span><br><span class="line">                def backtrack(path, selected):</span><br><span class="line">                    <span class="keyword">if</span> 满足停止条件：</span><br><span class="line">                        <span class="keyword">res</span>.<span class="keyword">append</span>(path)</span><br><span class="line">                    <span class="keyword">for</span> 选择 in 选择列表：</span><br><span class="line">                        做出选择</span><br><span class="line">                        递归执行backtrack</span><br><span class="line">                            满足则<span class="keyword">return</span> True</span><br><span class="line">                        如果不满足要求就撤销选择</span><br><span class="line">                满足条件判断：</span><br><span class="line">                    <span class="number">1</span>. 位于<span class="number">0</span>-<span class="number">255</span>之间</span><br><span class="line">                    <span class="number">2</span>. 以<span class="number">0</span>开头的不满足，比如：<span class="number">01</span> <span class="number">02</span> <span class="number">010</span>等</span><br><span class="line">                    <span class="number">3</span>. 含有非法字符不满足</span><br><span class="line">                    <span class="number">4</span>. 划分部分必须等于<span class="number">4</span>部分</span><br><span class="line">                存储结构使用[]存储，将满足的[]在存到result中</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        self.<span class="keyword">res</span> = []</span><br><span class="line">        # 去除长度大于<span class="number">12</span>的情况，因此长度大于<span class="number">12</span>，属于非法的</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) &gt; <span class="number">12</span>:</span><br><span class="line">            <span class="keyword">return</span> self.<span class="keyword">res</span></span><br><span class="line">        # 回溯</span><br><span class="line">        def backtrack(s, path):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="number">4</span>:</span><br><span class="line">                <span class="keyword">if</span> path not in self.re<span class="variable">s:</span></span><br><span class="line">                    self.<span class="keyword">res</span>.<span class="keyword">append</span>(<span class="string">'.'</span>.<span class="keyword">join</span>(path))</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">            # 已经选择了<span class="number">3</span>个</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="number">3</span> <span class="built_in">and</span> s != <span class="string">''</span>:</span><br><span class="line">                temp = s</span><br><span class="line">                # 选择合法的情况</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">int</span>(temp) &gt;= <span class="number">0</span> <span class="built_in">and</span> <span class="keyword">int</span>(temp) &lt;= <span class="number">255</span>:</span><br><span class="line">                    # 去除前导为<span class="number">0</span>的情况，如果前导存在<span class="number">0</span>，则不再进行递归</span><br><span class="line">                    <span class="keyword">if</span> str(<span class="keyword">int</span>(temp)) == temp:</span><br><span class="line">                        backtrack(<span class="string">''</span>,path+[temp])</span><br><span class="line">            # 选择一个<span class="number">1</span>或者两个或者<span class="number">0</span>个的情况都是一样的</span><br><span class="line">            elif <span class="built_in">len</span>(path) &lt; <span class="number">3</span> <span class="built_in">and</span> s != <span class="string">''</span>:</span><br><span class="line">                # 最大可选择的长度为<span class="number">3</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(s) &lt;= <span class="number">3</span>:</span><br><span class="line">                    <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">                        temp = s[:i+<span class="number">1</span>]</span><br><span class="line">                        <span class="keyword">next</span> = s[i+<span class="number">1</span>:]</span><br><span class="line">                        <span class="keyword">if</span> <span class="keyword">int</span>(temp) &gt;= <span class="number">0</span> <span class="built_in">and</span> <span class="keyword">int</span>(temp) &lt;= <span class="number">255</span>:</span><br><span class="line">                            # 去除前导为<span class="number">0</span>的情况，如果前导存在<span class="number">0</span>，则不再进行递归</span><br><span class="line">                            <span class="keyword">if</span> str(<span class="keyword">int</span>(temp)) == temp:</span><br><span class="line">                                backtrack(<span class="keyword">next</span>, path+[temp])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">                        temp = s[:i + <span class="number">1</span>]</span><br><span class="line">                        <span class="keyword">next</span> = s[i + <span class="number">1</span>:]</span><br><span class="line">                        <span class="keyword">if</span> <span class="keyword">int</span>(temp) &gt;= <span class="number">0</span> <span class="built_in">and</span> <span class="keyword">int</span>(temp) &lt;= <span class="number">255</span>:</span><br><span class="line">                            # 去除前导为<span class="number">0</span>的情况，如果前导存在<span class="number">0</span>，则不再进行递归</span><br><span class="line">                            <span class="keyword">if</span> str(<span class="keyword">int</span>(temp)) == temp:</span><br><span class="line">                                backtrack(<span class="keyword">next</span>, path+[temp])</span><br><span class="line">        backtrack(s, [])</span><br><span class="line">        <span class="keyword">return</span> self.<span class="keyword">res</span></span><br><span class="line">                        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    <span class="keyword">print</span>(s.restoreIpAddresses(<span class="string">"1111"</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第九十三题—复原IP地址&lt;/h1&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#题目描述&quot;&gt;¶&lt;/a&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给定一个只包含数字的字符串，用以表示一个 IP 地址，返回所有可能从 s 获得的
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>MAC安装Cesium环境</title>
    <link href="www.strivezs.com/2021/04/25/MAC%E5%AE%89%E8%A3%85Cesium%E7%8E%AF%E5%A2%83/"/>
    <id>www.strivezs.com/2021/04/25/MAC%E5%AE%89%E8%A3%85Cesium%E7%8E%AF%E5%A2%83/</id>
    <published>2021-04-25T10:43:19.293Z</published>
    <updated>2021-04-25T10:43:19.293Z</updated>
    
    <content type="html"><![CDATA[<h1>MAC安装Cesium环境</h1><h2 id="配置NodeJs-nvm-npm"><a class="header-anchor" href="#配置NodeJs-nvm-npm">¶</a>配置NodeJs+nvm+npm</h2><p>访问github官方地址，根据官方的文档来安装Mac版本的nvm，<a href="https://github.com/nvm-sh/nvm">click here</a></p><p>这里建议用<a href="https://github.com/nvm-sh/nvm">nvm</a>安装管理Node.js</p><p><strong>cURL:</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -<span class="keyword">o</span>- http<span class="variable">s:</span>//raw.githubusercontent.<span class="keyword">com</span>/nvm-<span class="keyword">sh</span>/nvm/v0.<span class="number">35.2</span>/install.<span class="keyword">sh</span> | bash</span><br></pre></td></tr></table></figure><p><strong>Wget:</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -qO- http<span class="variable">s:</span>//raw.githubusercontent.<span class="keyword">com</span>/nvm-<span class="keyword">sh</span>/nvm/v0.<span class="number">35.2</span>/install.<span class="keyword">sh</span> | bash</span><br></pre></td></tr></table></figure><p>nvm安装好后，重启终端，然后安装Node.js：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">nvm ls-remote</span></span><br></pre></td></tr></table></figure><p>使用上述命令来查看远程node版本，然后根据需要安装最新版本的Nodejs：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm install <span class="number">10.15</span><span class="number">.1</span></span><br></pre></td></tr></table></figure><p>安装完成之后可以使用</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm <span class="built_in">list</span></span><br></pre></td></tr></table></figure><p>来查看已经安装的nodejs版本，并且使用</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm <span class="keyword">use</span> 版本号</span><br></pre></td></tr></table></figure><p>来使用对应版本的nodejs。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm use <span class="number">10.15</span><span class="number">.1</span></span><br></pre></td></tr></table></figure><p>可以使用如下命令查看当前node版本</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">node</span> <span class="title">-v</span></span><br></pre></td></tr></table></figure><p>我最新版本的NodeJs报错，这里就是使用10.15.1版本的NodeJs</p><h3 id="NodeJs卸载"><a class="header-anchor" href="#NodeJs卸载">¶</a>NodeJs卸载</h3><p>首先使用nvm的命令停止活跃的NodeJs</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">nvm deactivate</span></span><br></pre></td></tr></table></figure><p>然后使用下面命令下载对应版本的NodeJs</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">nvm</span> uninstall xxx版本号</span><br></pre></td></tr></table></figure><h2 id="安装cesium"><a class="header-anchor" href="#安装cesium">¶</a>安装cesium</h2><p>访问Cesium官方网站，<a href="https://cesium.com/downloads/">click here</a>，使用如下命令安装最新版本的Cesium</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> cesium</span><br></pre></td></tr></table></figure><p>另外一种办法是去官方下载CesiumJs，这里我采用的是去官方下载。<br>下载完成之后进入到对应的目录中执行下面安装命令:</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~<span class="string">/Cesium-1.80</span></span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><h2 id="运行Cesium"><a class="header-anchor" href="#运行Cesium">¶</a>运行Cesium</h2><p>安装完成之后，会在Cesium文件夹中生成一个node_moudles文件夹。如下所示是:</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/Gdg5sO.png" alt="figure.1"></p><p>然后运行执行下面命令运行cesium服务。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">①：npm <span class="literal">start</span></span><br><span class="line">②：<span class="keyword">node</span> <span class="title">servcer</span>.cjs</span><br></pre></td></tr></table></figure><p>然后访问<a href="http://localhost:8080/">Connect to http://localhost:8080/</a><br>出现下述界面则表示成功了：</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/OGMzZZ.png" alt="figure.2"></p><p>也可以访问Demo界面(HelloWorld):<a href="http://localhost:8383/Apps/HelloWorld.html">http://localhost:8383/Apps/HelloWorld.html</a></p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/BGTark.png" alt="figure.4"></p><p>两个关键的网址:</p><ul><li><a href="http://localhost:8383/Build/Documentation/index.html">http://localhost:8383/Build/Documentation/index.html</a>  这是所有API说明文档<ul><li>某一个模块的所有函数，属性</li><li>部分效果截图</li><li>部分函数，属性调用代码示例</li></ul></li><li><a href="http://localhost:8383/Apps/Sandcastle/index.html">http://localhost:8383/Apps/Sandcastle/index.html</a>  这是沙盒<ul><li>可以浏览当前版本的一些功能特性</li><li>一个可运行的代码库</li><li>新建一个页面用于代码测试</li><li>导出测试代码</li></ul></li></ul><h2 id="比较好的学习方式"><a class="header-anchor" href="#比较好的学习方式">¶</a>比较好的学习方式</h2><ul><li>(1)先浏览一遍沙盒的所有示例，Cesium能做什么，能做成什么样</li><li>(2)做自己需要的功能时，查找到相关示例的代码，最好是看看深层次代码</li><li>(3)如果时进行深层次的研究，则需要对WebGLass有更新层次的了解</li><li>(4)用它做自己感兴趣的项目</li></ul><h2 id="问题整理"><a class="header-anchor" href="#问题整理">¶</a>问题整理</h2><p>这里注意一下，如果你使用默认的8080端口，出现访问失败的情况，可能是你的端口号被占用了，可以使用mac命令来杀死端口号，但是这里我建议修改成其他的端口号来进行访问即可。</p><p>修改目录中的server.cjs文件</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/O2yuiN.png" alt="figure.3"></p><p>这里我用的是8383</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;MAC安装Cesium环境&lt;/h1&gt;
&lt;h2 id=&quot;配置NodeJs-nvm-npm&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#配置NodeJs-nvm-npm&quot;&gt;¶&lt;/a&gt;配置NodeJs+nvm+npm&lt;/h2&gt;
&lt;p&gt;访问github官方地
      
    
    </summary>
    
    
      <category term="MAC" scheme="www.strivezs.com/categories/MAC/"/>
    
      <category term="Cesium" scheme="www.strivezs.com/categories/MAC/Cesium/"/>
    
    
      <category term="MAC" scheme="www.strivezs.com/tags/MAC/"/>
    
      <category term="Cesium" scheme="www.strivezs.com/tags/Cesium/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.92</title>
    <link href="www.strivezs.com/2021/04/24/LeetCode%E7%AC%AC%E4%B9%9D%E5%8D%81%E4%BA%8C%E9%A2%98/"/>
    <id>www.strivezs.com/2021/04/24/LeetCode%E7%AC%AC%E4%B9%9D%E5%8D%81%E4%BA%8C%E9%A2%98/</id>
    <published>2021-04-24T05:07:34.129Z</published>
    <updated>2021-04-24T05:07:34.129Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第九十二题—反转链表II</h1><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。</p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg" alt="figure.1"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], left = <span class="number">2</span>, right = <span class="number">4</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：head = [<span class="number">5</span>], left = <span class="number">1</span>, right = <span class="number">1</span></span><br><span class="line">输出：[<span class="number">5</span>]</span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">链表中节点数目为 n</span><br><span class="line"><span class="number">1</span> &lt;= n &lt;= <span class="number">500</span></span><br><span class="line"><span class="number">-500</span> &lt;= Node.val &lt;= <span class="number">500</span></span><br><span class="line"><span class="number">1</span> &lt;= left &lt;= right &lt;= n</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, val=<span class="number">0</span>, <span class="keyword">next</span>=None)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.val = val</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">next</span> = <span class="keyword">next</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span><span class="params">(<span class="keyword">self</span>, head, left, right)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type left: int</span></span><br><span class="line"><span class="string">        :type right: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            核心思想：</span></span><br><span class="line"><span class="string">                    使用一个额外的链表来存储翻转后的结果</span></span><br><span class="line"><span class="string">                    对于原链表沿分别记录需要反转部分前后的node</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        <span class="comment"># 处理特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> left == <span class="symbol">right:</span></span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="comment"># 反转部分前后的Node</span></span><br><span class="line">        leftPart = ListNode()</span><br><span class="line">        rightPart = ListNode()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 新出链表存储反转后的结果</span></span><br><span class="line">        newHead = ListNode()</span><br><span class="line">        last = ListNode()</span><br><span class="line"></span><br><span class="line">        num = <span class="number">0</span> <span class="comment"># 计数菌</span></span><br><span class="line">        temp = head <span class="comment"># 访问Node</span></span><br><span class="line">        flag = True</span><br><span class="line">        <span class="keyword">while</span> temp != None <span class="keyword">and</span> <span class="symbol">flag:</span></span><br><span class="line">            num += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 记录左右边界</span></span><br><span class="line">            <span class="keyword">if</span> num == left-<span class="number">1</span><span class="symbol">:</span></span><br><span class="line">                leftPart = temp</span><br><span class="line">            <span class="keyword">if</span> num == right+<span class="number">1</span><span class="symbol">:</span></span><br><span class="line">                rightPart = temp</span><br><span class="line">                flag = False <span class="comment"># 结束标志</span></span><br><span class="line">            <span class="comment"># 反转</span></span><br><span class="line">            <span class="keyword">if</span> num &gt;= left <span class="keyword">and</span> num &lt;= <span class="symbol">right:</span></span><br><span class="line">                tt = ListNode(val=temp.val)</span><br><span class="line">                tt.<span class="keyword">next</span> = newHead.<span class="keyword">next</span></span><br><span class="line">                newHead.<span class="keyword">next</span> = tt</span><br><span class="line">                <span class="keyword">if</span> num == <span class="symbol">left:</span></span><br><span class="line">                    last = tt <span class="comment"># 记录尾结点</span></span><br><span class="line">                    <span class="comment"># print('---' + str(last.val))</span></span><br><span class="line">            temp = temp.<span class="keyword">next</span></span><br><span class="line">        <span class="comment"># 单独处理头尾反转特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> left == <span class="number">1</span> <span class="keyword">and</span> num==<span class="symbol">right:</span></span><br><span class="line">            <span class="keyword">return</span> newHead.<span class="keyword">next</span></span><br><span class="line">        elif left == <span class="number">1</span><span class="symbol">:</span></span><br><span class="line">            last.<span class="keyword">next</span> = rightPart  <span class="comment"># 右边连接</span></span><br><span class="line">            <span class="keyword">return</span> newHead.<span class="keyword">next</span></span><br><span class="line">        elif num == <span class="symbol">right:</span></span><br><span class="line">            leftPart.<span class="keyword">next</span> = newHead.<span class="keyword">next</span>  <span class="comment"># 左边连接</span></span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 链表链接</span></span><br><span class="line">        leftPart.<span class="keyword">next</span> = newHead.<span class="keyword">next</span> <span class="comment"># 左边连接</span></span><br><span class="line">        last.<span class="keyword">next</span> = rightPart  <span class="comment"># 右边连接</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name_<span class="number">_</span> == <span class="string">'__main__'</span><span class="symbol">:</span></span><br><span class="line">    a1 = ListNode(<span class="number">3</span>)</span><br><span class="line">    a2 = ListNode(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    a1.<span class="keyword">next</span> = a2</span><br><span class="line"></span><br><span class="line">    s = Solution()</span><br><span class="line">    head = s.reverseBetween(a1,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">while</span> head != <span class="symbol">None:</span></span><br><span class="line">        print(str(head.val)+<span class="string">' '</span>)</span><br><span class="line">        head = head.<span class="keyword">next</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第九十二题—反转链表II&lt;/h1&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#题目描述&quot;&gt;¶&lt;/a&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给你单链表的头指针 head 和两个整数 left 和 right ，其中 le
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.91</title>
    <link href="www.strivezs.com/2021/04/23/LeetCode%E7%AC%AC%E4%B9%9D%E5%8D%81%E4%B8%80%E9%A2%98/"/>
    <id>www.strivezs.com/2021/04/23/LeetCode%E7%AC%AC%E4%B9%9D%E5%8D%81%E4%B8%80%E9%A2%98/</id>
    <published>2021-04-23T15:52:11.072Z</published>
    <updated>2021-04-23T15:52:11.072Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第九十一题—解码方法</h1><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：</p><p>‘A’ -&gt; 1<br>‘B’ -&gt; 2<br>…<br>‘Z’ -&gt; 26<br>要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，“11106” 可以映射为：</p><p>“AAJF” ，将消息分组为 (1 1 10 6)<br>“KJF” ，将消息分组为 (11 10 6)<br>注意，消息不能分组为  (1 11 06) ，因为 “06” 不能映射为 “F” ，这是由于 “6” 和 “06” 在映射中并不等价。</p><p>给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。</p><p>题目数据保证答案肯定是一个 32 位 的整数。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"12"</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：它可以解码为 <span class="string">"AB"</span>（<span class="number">1</span> <span class="number">2</span>）或者 <span class="string">"L"</span>（<span class="number">12</span>）。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"226"</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：它可以解码为 <span class="string">"BZ"</span> (<span class="number">2</span> <span class="number">26</span>), <span class="string">"VF"</span> (<span class="number">22</span> <span class="number">6</span>), 或者 <span class="string">"BBF"</span> (<span class="number">2</span> <span class="number">2</span> <span class="number">6</span>) 。</span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"0"</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：没有字符映射到以 <span class="number">0</span> 开头的数字。</span><br><span class="line">含有 <span class="number">0</span> 的有效映射是 'J' -&gt; <span class="string">"10"</span> 和 'T'-&gt; <span class="string">"20"</span> 。</span><br><span class="line">由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。</span><br><span class="line">示例 <span class="number">4</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"06"</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：<span class="string">"06"</span> 不能映射到 <span class="string">"F"</span> ，因为字符串含有前导 <span class="number">0</span>（<span class="string">"6"</span> 和 <span class="string">"06"</span> 在映射中并不等价）。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= s.length &lt;= <span class="number">100</span></span><br><span class="line">s 只包含数字，并且可能包含前导零。</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def numDecodings(self, s):</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        :<span class="built_in">type</span> <span class="variable">s:</span> str</span><br><span class="line">        :rtype: <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">        核心思想：动态规划</span><br><span class="line">                s[i]只包含数字，其可能为<span class="number">0</span></span><br><span class="line"></span><br><span class="line">                第一步：定义<span class="keyword">dp</span>数组</span><br><span class="line">                    <span class="keyword">dp</span>[i]表示前i个数字解码的个数，结果直接返回<span class="keyword">dp</span>[-<span class="number">1</span>]</span><br><span class="line">                第二步：确定状态转移方程</span><br><span class="line">                    状态转移方程表示了大规模的问题如何由小规模问题转换而来</span><br><span class="line">                    即如何用<span class="keyword">dp</span>[i-<span class="number">1</span>]...<span class="keyword">dp</span>[<span class="number">0</span>]来得到<span class="keyword">dp</span>[i]</span><br><span class="line"></span><br><span class="line">                    本题分析：对于两个字符来说，只存在被解码成<span class="number">0</span>种、<span class="number">1</span>种、<span class="number">2</span>种的情况，所以需要分别讨论上述情况是如何得到的</span><br><span class="line">                    具体讨论如下:</span><br><span class="line">                        ① s[i]不在合法集合中即s[i]为<span class="number">0</span>，这是来考察si[i-<span class="number">1</span>]+s[i]=[i-<span class="number">1</span>:i+<span class="number">1</span>]的</span><br><span class="line">                            - 对于<span class="number">0</span>s[i]这种情况，必然不在合法集合中，直接返回<span class="number">0</span></span><br><span class="line">                            - 但是对于s[i]<span class="number">0</span>这种情况，是存在合法情况的，如<span class="number">10</span> <span class="number">20</span></span><br><span class="line">                        ② s[i]在合法集合中，考察si[i-<span class="number">1</span>]+s[i]=[i-<span class="number">1</span>:i+<span class="number">1</span>]的</span><br><span class="line">                            - s[i-<span class="number">1</span>:i+<span class="number">1</span>]不在合法集合中，即大于<span class="number">26</span>或者小于<span class="number">1</span>的情况，无法解码</span><br><span class="line">                            - s[i-<span class="number">1</span>:i+<span class="number">1</span>]在合法集合中，即在<span class="number">1</span>-<span class="number">26</span>之间，但是需要注意这种情况是可以进行拆分解码的</span><br><span class="line">                            拆分之后会影响后面的解码情况的</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        <span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">'0'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        length = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">if</span> length == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        # 生成数组</span><br><span class="line">        legal = <span class="keyword">set</span>(str(i) <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">27</span>))</span><br><span class="line">        <span class="keyword">dp</span> = [<span class="number">0</span>] * length # 初始化<span class="keyword">dp</span>数组</span><br><span class="line">        <span class="keyword">dp</span>[<span class="number">0</span>] = <span class="number">1</span> # 设置s[<span class="number">0</span>]对应的解码为<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> s[<span class="number">1</span>] not in lega<span class="variable">l:</span>  # s[<span class="number">1</span>]为<span class="number">0</span></span><br><span class="line">            <span class="keyword">dp</span>[<span class="number">1</span>] = <span class="number">1</span> <span class="keyword">if</span> s[: <span class="number">2</span>] in legal <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">dp</span>[<span class="number">1</span>] = <span class="number">2</span> <span class="keyword">if</span> s[: <span class="number">2</span>] in legal <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="number">2</span>,length):</span><br><span class="line">            # 处理剩下的情况  <span class="number">13023</span></span><br><span class="line">            ## 合法情况</span><br><span class="line">            <span class="keyword">if</span> s[i] in lega<span class="variable">l:</span></span><br><span class="line">                <span class="keyword">if</span> s[i-<span class="number">1</span>:i+<span class="number">1</span>] in lega<span class="variable">l:</span></span><br><span class="line">                    <span class="keyword">dp</span>[i] = <span class="keyword">dp</span>[i-<span class="number">1</span>] + <span class="keyword">dp</span>[i-<span class="number">2</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">dp</span>[i] = <span class="keyword">dp</span>[i-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> s[i-<span class="number">1</span>:i+<span class="number">1</span>] in lega<span class="variable">l:</span></span><br><span class="line">                    <span class="keyword">dp</span>[i] = <span class="keyword">dp</span>[i-<span class="number">2</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">dp</span>[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    <span class="keyword">print</span>(s.numDecodings(<span class="string">"12"</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第九十一题—解码方法&lt;/h1&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#题目描述&quot;&gt;¶&lt;/a&gt;题目描述&lt;/h2&gt;
&lt;p&gt;一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：&lt;/p&gt;
&lt;p&gt;‘A’ -&amp;
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.90</title>
    <link href="www.strivezs.com/2021/04/22/LeetCode%E7%AC%AC%E4%B9%9D%E5%8D%81%E9%A2%98/"/>
    <id>www.strivezs.com/2021/04/22/LeetCode%E7%AC%AC%E4%B9%9D%E5%8D%81%E9%A2%98/</id>
    <published>2021-04-22T04:41:56.031Z</published>
    <updated>2021-04-22T04:41:56.031Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第九十题—子集II</h1><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p><p>解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出：[[],[<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>],[<span class="number">2</span>],[<span class="number">2</span>,<span class="number">2</span>]]</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">0</span>]</span><br><span class="line">输出：[[],[<span class="number">0</span>]]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= nums.length &lt;= <span class="number">10</span></span><br><span class="line"><span class="number">-10</span> &lt;= nums[i] &lt;= <span class="number">10</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def subsetsWithDup(self, nums):</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        :<span class="built_in">type</span> num<span class="variable">s:</span> List[<span class="keyword">int</span>]</span><br><span class="line">        :rtype: List[List[<span class="keyword">int</span>]]</span><br><span class="line"></span><br><span class="line">        核心思想：</span><br><span class="line">                经典回溯法</span><br><span class="line">                def backtrack(path, selected):</span><br><span class="line">                    <span class="keyword">if</span> 满足停止条件：</span><br><span class="line">                        <span class="keyword">res</span>.<span class="keyword">append</span>(path)</span><br><span class="line">                    <span class="keyword">for</span> 选择 in 选择列表：</span><br><span class="line">                        做出选择</span><br><span class="line">                        递归执行backtrack</span><br><span class="line">                            满足则<span class="keyword">return</span> True</span><br><span class="line">                        如果不满足要求就撤销选择</span><br><span class="line">        魔改<span class="number">78</span>题就可以了</span><br><span class="line">        只需要对生成的结果进行排序，然后判断是否在集合中，如果出现则不行</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        <span class="keyword">res</span> = []</span><br><span class="line">        <span class="keyword">res</span>.<span class="keyword">append</span>([])</span><br><span class="line">        numsLen = <span class="built_in">len</span>(nums)</span><br><span class="line">        temp = []</span><br><span class="line"></span><br><span class="line">        def backtrack(temp, <span class="keyword">l</span>, numsLen, length):</span><br><span class="line">            # 停止条件</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(temp) == length:</span><br><span class="line">                t_1 = sorted(temp)</span><br><span class="line">                <span class="keyword">if</span> t_1 not in re<span class="variable">s:</span></span><br><span class="line">                    tt = <span class="keyword">copy</span>.<span class="keyword">copy</span>(t_1)</span><br><span class="line">                    <span class="keyword">res</span>.<span class="keyword">append</span>(tt)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> <span class="keyword">j</span> in <span class="built_in">range</span>(<span class="keyword">l</span> + <span class="number">1</span>, numsLen):</span><br><span class="line">                # 做出选择</span><br><span class="line">                temp.<span class="keyword">append</span>(nums[<span class="keyword">j</span>])</span><br><span class="line">                # 递归执行</span><br><span class="line">                backtrack(temp, <span class="keyword">j</span>, numsLen, length)</span><br><span class="line">                # 撤销选择</span><br><span class="line">                temp.<span class="keyword">pop</span>()</span><br><span class="line"></span><br><span class="line">        # 递归调用  length值不同</span><br><span class="line">        <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="number">1</span>, numsLen + <span class="number">1</span>):</span><br><span class="line">            backtrack(temp, -<span class="number">1</span>, numsLen, i)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">res</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第九十题—子集II&lt;/h1&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#题目描述&quot;&gt;¶&lt;/a&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.89</title>
    <link href="www.strivezs.com/2021/04/20/LeetCode%E7%AC%AC%E5%85%AB%E5%8D%81%E4%B9%9D%E9%A2%98/"/>
    <id>www.strivezs.com/2021/04/20/LeetCode%E7%AC%AC%E5%85%AB%E5%8D%81%E4%B9%9D%E9%A2%98/</id>
    <published>2021-04-20T05:35:49.731Z</published>
    <updated>2021-04-20T05:35:49.731Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode第八十九题—格雷编码"><a href="#LeetCode第八十九题—格雷编码" class="headerlink" title="LeetCode第八十九题—格雷编码"></a>LeetCode第八十九题—格雷编码</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。</p><p>给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。即使有多个不同答案，你也只需要返回其中一种。</p><p>格雷编码序列必须以 0 开头。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: <span class="number">2</span></span><br><span class="line">输出: [<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">解释:</span><br><span class="line"><span class="number">00</span> - <span class="number">0</span></span><br><span class="line"><span class="number">01</span> - <span class="number">1</span></span><br><span class="line"><span class="number">11</span> - <span class="number">3</span></span><br><span class="line"><span class="number">10</span> - <span class="number">2</span></span><br><span class="line"></span><br><span class="line">对于给定的 n，其格雷编码序列并不唯一。</span><br><span class="line">例如，[<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>] 也是一个有效的格雷编码序列。</span><br><span class="line"></span><br><span class="line"><span class="number">00</span> - <span class="number">0</span></span><br><span class="line"><span class="number">10</span> - <span class="number">2</span></span><br><span class="line"><span class="number">11</span> - <span class="number">3</span></span><br><span class="line"><span class="number">01</span> - <span class="number">1</span></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: <span class="number">0</span></span><br><span class="line">输出: [<span class="number">0</span>]</span><br><span class="line">解释: 我们定义格雷编码序列必须以 <span class="number">0</span> 开头。</span><br><span class="line">     给定编码总位数为 n 的格雷编码序列，其长度为 <span class="number">2</span>n。当 n = <span class="number">0</span> 时，长度为 <span class="number">20</span> = <span class="number">1</span>。</span><br><span class="line">     因此，当 n = <span class="number">0</span> 时，其格雷编码序列为 [<span class="number">0</span>]。</span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">TimeOut</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">                考虑用回溯法来做吧，题解里面提到的镜像操作，说实话我是真想不到塞</span></span><br><span class="line"><span class="string">                 def backtrack(path, selected):</span></span><br><span class="line"><span class="string">                    if 满足停止条件：</span></span><br><span class="line"><span class="string">                        res.append(path)</span></span><br><span class="line"><span class="string">                    for 选择 in 选择列表：</span></span><br><span class="line"><span class="string">                        做出选择</span></span><br><span class="line"><span class="string">                        递归执行backtrack</span></span><br><span class="line"><span class="string">                            满足则return True</span></span><br><span class="line"><span class="string">                        如果不满足要求就撤销选择</span></span><br><span class="line"><span class="string">                注意使用 &lt;&lt; 是位运算</span></span><br><span class="line"><span class="string">                cur = 1 &lt;&lt; i ^ res[-1] 表示将结果list中最后一个进行位移操作</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = [<span class="number">0</span>] <span class="comment"># 使用list存储  初始一个0针对0的情况</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(cur)</span>:</span> <span class="comment"># cur当前生成的元素</span></span><br><span class="line">            <span class="comment"># 停止条件</span></span><br><span class="line">            <span class="keyword">if</span> len(res) == <span class="number">2</span>**n:</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="comment"># 做出选择</span></span><br><span class="line">                cur = <span class="number">1</span> &lt;&lt; i ^ res[<span class="number">-1</span>] <span class="comment"># 移位运算</span></span><br><span class="line">                <span class="keyword">if</span> cur <span class="keyword">in</span> res:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                res.append(cur)</span><br><span class="line">                temp = backtrack(cur)</span><br><span class="line">                <span class="keyword">if</span> temp:</span><br><span class="line">                    <span class="keyword">return</span> temp</span><br><span class="line">                <span class="comment"># 撤销选择</span></span><br><span class="line">                res.pop()</span><br><span class="line">        <span class="keyword">return</span> backtrack(res[<span class="number">0</span>])</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">grayCode</span><span class="params">(self,n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">            :type n: int</span></span><br><span class="line"><span class="string">            :rtype: List[int]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            回溯法成功超时试了，去看了一下评论区大佬的解答</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            找到了一个核心的思想：自己与自己左移一位进行异或，得到的就是它的格雷码</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range( <span class="number">1</span>&lt;&lt;n ):</span><br><span class="line">            res.append(i ^ i &gt;&gt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.grayCode(n=<span class="number">2</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LeetCode第八十九题—格雷编码&quot;&gt;&lt;a href=&quot;#LeetCode第八十九题—格雷编码&quot; class=&quot;headerlink&quot; title=&quot;LeetCode第八十九题—格雷编码&quot;&gt;&lt;/a&gt;LeetCode第八十九题—格雷编码&lt;/h1&gt;&lt;h2 id=&quot;题
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.88</title>
    <link href="www.strivezs.com/2021/04/20/LeetCode%E7%AC%AC%E5%85%AB%E5%8D%81%E5%85%AB%E9%A2%98/"/>
    <id>www.strivezs.com/2021/04/20/LeetCode%E7%AC%AC%E5%85%AB%E5%8D%81%E5%85%AB%E9%A2%98/</id>
    <published>2021-04-20T05:33:42.570Z</published>
    <updated>2021-04-20T05:33:42.570Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode第八十七题—扰乱字符串"><a href="#LeetCode第八十七题—扰乱字符串" class="headerlink" title="LeetCode第八十七题—扰乱字符串"></a>LeetCode第八十七题—扰乱字符串</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。</p><p>初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间大小等于 m + n，这样它就有足够的空间保存来自 nums2 的元素。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>], m = <span class="number">3</span>, nums2 = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>], n = <span class="number">3</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：nums1 = [<span class="number">1</span>], m = <span class="number">1</span>, nums2 = [], n = <span class="number">0</span></span><br><span class="line">输出：[<span class="number">1</span>]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">nums1.length == m + n</span><br><span class="line">nums2.length == n</span><br><span class="line"><span class="number">0</span> &lt;= m, n &lt;= <span class="number">200</span></span><br><span class="line"><span class="number">1</span> &lt;= m + n &lt;= <span class="number">200</span></span><br><span class="line"><span class="number">-109</span> &lt;= nums1[i], nums2[i] &lt;= <span class="number">109</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def merge(self, nums1, <span class="keyword">m</span>, nums2, n):</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        :<span class="built_in">type</span> nums1: List[<span class="keyword">int</span>]</span><br><span class="line">        :<span class="built_in">type</span> <span class="keyword">m</span>: <span class="keyword">int</span></span><br><span class="line">        :<span class="built_in">type</span> nums2: List[<span class="keyword">int</span>]</span><br><span class="line">        :<span class="built_in">type</span> n: <span class="keyword">int</span></span><br><span class="line">        :rtype: None Do not <span class="keyword">return</span> anything, modify nums1 in-place instead.</span><br><span class="line"></span><br><span class="line">        核心思想：</span><br><span class="line">                前提两个序列是按照从小到大排序好的</span><br><span class="line">                对nums2进行倒序和nums1的数值进行倒序比较</span><br><span class="line">                如果nums2[i]的数值大于nums1最大的值 则nums1[end]=nums[i]</span><br><span class="line">                如果nums2[i]的数值小于nums1最大值，则先将nums1最大值排在序列末尾非<span class="number">0</span>位置</span><br><span class="line">                如果nums2[i]的数值小于num1某个值，则将nums1该值后移到序列末尾非<span class="number">0</span>位置(非<span class="number">0</span>位置可以用下标记录)</span><br><span class="line"></span><br><span class="line">                实质上：就是比较nums1和nums2谁大，谁就置到末尾</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> nums1</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">m</span> == <span class="number">0</span>:</span><br><span class="line">            nums1[:]=nums2[:]</span><br><span class="line">            <span class="keyword">return</span> nums1</span><br><span class="line">        <span class="built_in">index</span> = <span class="keyword">m</span> + n - <span class="number">1</span>  # 记录末尾位置下标</span><br><span class="line">        <span class="keyword">m</span>,n = <span class="keyword">m</span> - <span class="number">1</span>,n - <span class="number">1</span> # nums1和nums2正确下标</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">m</span> &gt;= <span class="number">0</span> <span class="built_in">and</span> n &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> nums1[<span class="keyword">m</span>] &gt; nums2[n]:</span><br><span class="line">                nums1[<span class="built_in">index</span>] = nums1[<span class="keyword">m</span>]</span><br><span class="line">                <span class="keyword">m</span> = <span class="keyword">m</span> - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1[<span class="built_in">index</span>] = nums2[n]</span><br><span class="line">                n = n - <span class="number">1</span></span><br><span class="line">            <span class="built_in">index</span> = <span class="built_in">index</span>-<span class="number">1</span></span><br><span class="line">        # 处理nums1被处理完nums2没被处理完的情况</span><br><span class="line">        <span class="keyword">while</span> n &gt;= <span class="number">0</span>:</span><br><span class="line">            nums1[<span class="built_in">index</span>] = nums2[n]</span><br><span class="line">            <span class="built_in">index</span>,n = <span class="built_in">index</span>-<span class="number">1</span>,n-<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums1</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    <span class="keyword">print</span>(s.merge(nums1 = [<span class="number">2</span>,<span class="number">0</span>], <span class="keyword">m</span> = <span class="number">1</span>, nums2 = [<span class="number">1</span>], n = <span class="number">1</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LeetCode第八十七题—扰乱字符串&quot;&gt;&lt;a href=&quot;#LeetCode第八十七题—扰乱字符串&quot; class=&quot;headerlink&quot; title=&quot;LeetCode第八十七题—扰乱字符串&quot;&gt;&lt;/a&gt;LeetCode第八十七题—扰乱字符串&lt;/h1&gt;&lt;p&gt;自己
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.87</title>
    <link href="www.strivezs.com/2021/04/18/LeetCode%E7%AC%AC%E5%85%AB%E5%8D%81%E4%B8%83%E9%A2%98/"/>
    <id>www.strivezs.com/2021/04/18/LeetCode%E7%AC%AC%E5%85%AB%E5%8D%81%E4%B8%83%E9%A2%98/</id>
    <published>2021-04-18T14:57:11.485Z</published>
    <updated>2021-04-18T14:57:11.485Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode第八十七题—扰乱字符串"><a href="#LeetCode第八十七题—扰乱字符串" class="headerlink" title="LeetCode第八十七题—扰乱字符串"></a>LeetCode第八十七题—扰乱字符串</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>使用下面描述的算法可以扰乱字符串 s 得到字符串 t ：<br>如果字符串的长度为 1 ，算法停止<br>如果字符串的长度 &gt; 1 ，执行下述步骤：<br>在一个随机下标处将字符串分割成两个非空的子字符串。即，如果已知字符串 s ，则可以将其分成两个子字符串 x 和 y ，且满足 s = x + y 。<br>随机 决定是要「交换两个子字符串」还是要「保持这两个子字符串的顺序不变」。即，在执行这一步骤之后，s 可能是 s = x + y 或者 s = y + x 。<br>在 x 和 y 这两个子字符串上继续从步骤 1 开始递归执行此算法。<br>给你两个 长度相等 的字符串 s1 和 s2，判断 s2 是否是 s1 的扰乱字符串。如果是，返回 true ；否则，返回 false 。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：<span class="built_in">s1</span> = <span class="string">"great"</span>, <span class="built_in">s2</span> = <span class="string">"rgeat"</span></span><br><span class="line">输出：true</span><br><span class="line">解释：<span class="built_in">s1</span> 上可能发生的一种情形是：</span><br><span class="line"><span class="string">"great"</span> --&gt; <span class="string">"gr/eat"</span> // 在一个随机下标处分割得到两个子字符串</span><br><span class="line"><span class="string">"gr/eat"</span> --&gt; <span class="string">"gr/eat"</span> // 随机决定：「保持这两个子字符串的顺序不变」</span><br><span class="line"><span class="string">"gr/eat"</span> --&gt; <span class="string">"g/r / e/at"</span> // 在子字符串上递归执行此算法。两个子字符串分别在随机下标处进行一轮分割</span><br><span class="line"><span class="string">"g/r / e/at"</span> --&gt; <span class="string">"r/g / e/at"</span> // 随机决定：第一组「交换两个子字符串」，第二组「保持这两个子字符串的顺序不变」</span><br><span class="line"><span class="string">"r/g / e/at"</span> --&gt; <span class="string">"r/g / e/ a/t"</span> // 继续递归执行此算法，将 <span class="string">"at"</span> 分割得到 <span class="string">"a/t"</span></span><br><span class="line"><span class="string">"r/g / e/ a/t"</span> --&gt; <span class="string">"r/g / e/ a/t"</span> // 随机决定：「保持这两个子字符串的顺序不变」</span><br><span class="line">算法终止，结果字符串和 <span class="built_in">s2</span> 相同，都是 <span class="string">"rgeat"</span></span><br><span class="line">这是一种能够扰乱 <span class="built_in">s1</span> 得到 <span class="built_in">s2</span> 的情形，可以认为 <span class="built_in">s2</span> 是 <span class="built_in">s1</span> 的扰乱字符串，返回 true</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：<span class="built_in">s1</span> = <span class="string">"abcde"</span>, <span class="built_in">s2</span> = <span class="string">"caebd"</span></span><br><span class="line">输出：false</span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：<span class="built_in">s1</span> = <span class="string">"a"</span>, <span class="built_in">s2</span> = <span class="string">"a"</span></span><br><span class="line">输出：true</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="symbol">s1.length</span> == <span class="built_in">s2</span>.length</span><br><span class="line"><span class="number">1</span> &lt;= <span class="built_in">s1</span>.length &lt;= <span class="number">30</span></span><br><span class="line"><span class="symbol">s1</span> 和 <span class="built_in">s2</span> 由小写英文字母组成</span><br></pre></td></tr></table></figure><h2 id="递归图示"><a href="#递归图示" class="headerlink" title="递归图示"></a>递归图示</h2><p>举递归的一种情况示例，其他的类似:</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/XqdrLJ.jpg" alt="figure.1"></p><p>对于交换的情况，比如abc 和 bac 存在a和c匹配 bc和ba匹配的情况。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>效率爆炸。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isScramble</span><span class="params">(self, s1, s2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s1: str</span></span><br><span class="line"><span class="string">        :type s2: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        核心思想:</span></span><br><span class="line"><span class="string">                感觉就是暴力搜索</span></span><br><span class="line"><span class="string">                这里采用递归搜索</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(s1)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> s1 == s2</span><br><span class="line">        <span class="comment"># 递归搜索所有可能</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            <span class="comment"># 分别对划分两部分进行递归搜索</span></span><br><span class="line">            <span class="keyword">if</span> self.isScramble(s1[:i],s2[:i]) <span class="keyword">and</span> self.isScramble(s1[i:],s2[i:]):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="comment"># 交换匹配 比如：acb 和 bac 中ac和ac 匹配 b和b 这种情况 也可以是a和c cb和ba</span></span><br><span class="line">            <span class="keyword">elif</span> self.isScramble(s1[:i], s2[-i:]) <span class="keyword">and</span> self.isScramble(s1[i:],s2[:-i]):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.isScramble(<span class="string">"abcdefghijklmnopq"</span>,<span class="string">"efghijklmnopqcadb"</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LeetCode第八十七题—扰乱字符串&quot;&gt;&lt;a href=&quot;#LeetCode第八十七题—扰乱字符串&quot; class=&quot;headerlink&quot; title=&quot;LeetCode第八十七题—扰乱字符串&quot;&gt;&lt;/a&gt;LeetCode第八十七题—扰乱字符串&lt;/h1&gt;&lt;p&gt;自己
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.86</title>
    <link href="www.strivezs.com/2021/04/17/LeetCode%E7%AC%AC%E5%85%AB%E5%8D%81%E5%85%AD%E9%A2%98/"/>
    <id>www.strivezs.com/2021/04/17/LeetCode%E7%AC%AC%E5%85%AB%E5%8D%81%E5%85%AD%E9%A2%98/</id>
    <published>2021-04-17T11:16:50.929Z</published>
    <updated>2021-04-17T11:16:50.929Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode第八十六题题—分隔链表"><a href="#LeetCode第八十六题题—分隔链表" class="headerlink" title="LeetCode第八十六题题—分隔链表"></a>LeetCode第八十六题题—分隔链表</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。</p><p>你应当 保留 两个分区中每个节点的初始相对位置。</p><p> <img src="https://assets.leetcode.com/uploads/2021/01/04/partition.jpg" alt="figure.1"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：head = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">2</span>], x = <span class="number">3</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：head = [<span class="number">2</span>,<span class="number">1</span>], x = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">链表中节点的数目在范围 [<span class="number">0</span>, <span class="number">200</span>] 内</span><br><span class="line"><span class="number">-100</span> &lt;= Node.val &lt;= <span class="number">100</span></span><br><span class="line"><span class="number">-200</span> &lt;= x &lt;= <span class="number">200</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, val=<span class="number">0</span>, <span class="keyword">next</span>=None)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.val = val</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">next</span> = <span class="keyword">next</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(<span class="keyword">self</span>, head, x)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        核心思想：大于x的第一个节点后面小于x的节点全部放到第一个节点前面(保持节点间的相对位置不变，不需要排序)</span></span><br><span class="line"><span class="string">                1.小于 x 部分的链表按照原始顺序 记为 p</span></span><br><span class="line"><span class="string">                2.大于等于 x 部分的链表按照原始顺序 记为 q</span></span><br><span class="line"><span class="string">                3.拼接两个链表，p --&gt; q</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        a = left = ListNode()</span><br><span class="line">        b = right = ListNode()</span><br><span class="line">        <span class="keyword">while</span> head != <span class="symbol">None:</span></span><br><span class="line">            <span class="keyword">if</span> head.val &lt; <span class="symbol">x:</span></span><br><span class="line">                left.<span class="keyword">next</span> = head</span><br><span class="line">                left = left.<span class="keyword">next</span></span><br><span class="line">            <span class="symbol">else:</span></span><br><span class="line">                right.<span class="keyword">next</span> = head</span><br><span class="line">                right = right.<span class="keyword">next</span></span><br><span class="line">            head = head.<span class="keyword">next</span></span><br><span class="line">        left.<span class="keyword">next</span> = b.<span class="keyword">next</span> <span class="comment"># 拼接</span></span><br><span class="line">        right.<span class="keyword">next</span> = None</span><br><span class="line">        <span class="keyword">return</span> a.<span class="keyword">next</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LeetCode第八十六题题—分隔链表&quot;&gt;&lt;a href=&quot;#LeetCode第八十六题题—分隔链表&quot; class=&quot;headerlink&quot; title=&quot;LeetCode第八十六题题—分隔链表&quot;&gt;&lt;/a&gt;LeetCode第八十六题题—分隔链表&lt;/h1&gt;&lt;p&gt;自己
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.85</title>
    <link href="www.strivezs.com/2021/04/16/LeetCode%E7%AC%AC%E5%85%AB%E5%8D%81%E4%BA%94%E9%A2%98/"/>
    <id>www.strivezs.com/2021/04/16/LeetCode%E7%AC%AC%E5%85%AB%E5%8D%81%E4%BA%94%E9%A2%98/</id>
    <published>2021-04-16T05:12:35.912Z</published>
    <updated>2021-04-16T05:12:35.912Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第八十五题—最大矩形</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>我是笨比我是笨比，这都没想到，只能看大佬的解法，在自己写。我太菜了！！！</p><p>给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。</p><p><img src="https://assets.leetcode.com/uploads/2020/09/14/maximal.jpg" alt="figure.1"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：matrix = [[<span class="string">"1"</span>,<span class="string">"0"</span>,<span class="string">"1"</span>,<span class="string">"0"</span>,<span class="string">"0"</span>],[<span class="string">"1"</span>,<span class="string">"0"</span>,<span class="string">"1"</span>,<span class="string">"1"</span>,<span class="string">"1"</span>],[<span class="string">"1"</span>,<span class="string">"1"</span>,<span class="string">"1"</span>,<span class="string">"1"</span>,<span class="string">"1"</span>],[<span class="string">"1"</span>,<span class="string">"0"</span>,<span class="string">"0"</span>,<span class="string">"1"</span>,<span class="string">"0"</span>]]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：最大矩形如上图所示。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：matrix = []</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：matrix = [[<span class="string">"0"</span>]]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">示例 <span class="number">4</span>：</span><br><span class="line"></span><br><span class="line">输入：matrix = [[<span class="string">"1"</span>]]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">示例 <span class="number">5</span>：</span><br><span class="line"></span><br><span class="line">输入：matrix = [[<span class="string">"0"</span>,<span class="string">"0"</span>]]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">rows == matrix.length</span><br><span class="line">cols == matrix[<span class="number">0</span>].length</span><br><span class="line"><span class="number">0</span> &lt;= row, cols &lt;= <span class="number">200</span></span><br><span class="line">matrix[i][j] 为 <span class="string">'0'</span> 或 <span class="string">'1'</span></span><br></pre></td></tr></table></figure><h2 id="解法"><a class="header-anchor" href="#解法">¶</a>解法</h2><p>类似84题，这里将矩阵对每行进行统计，分别得到每行对应的高度，这样就可以求得最大矩阵，具体参考图例十分清楚.</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/DU5Jfz.png" alt="figure.2"></p><p>希望能根据这道题的解法，以后举一反三。</p><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">monotonicStack</span><span class="params">(self, heights)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :argument  利用no.84题的解法</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 处理height 前后分别添加0 方便单调栈处理</span></span><br><span class="line">        heights.insert(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        heights.append(<span class="number">0</span>)</span><br><span class="line">        stack = [] <span class="comment"># 单调增栈</span></span><br><span class="line">        maxLineArea = <span class="number">0</span> <span class="comment"># 最大行面积（这一行对应的面积）</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(heights)):</span><br><span class="line">            <span class="keyword">while</span> len(stack) != <span class="number">0</span> <span class="keyword">and</span> heights[stack[len(stack)<span class="number">-1</span>]] &gt; heights[i]:</span><br><span class="line">                current = stack[len(stack)<span class="number">-1</span>]</span><br><span class="line">                stack.pop()  <span class="comment"># 出栈</span></span><br><span class="line">                left = stack[len(stack)<span class="number">-1</span>]+<span class="number">1</span> <span class="comment"># 获得左边界</span></span><br><span class="line">                right = i<span class="number">-1</span> <span class="comment"># 获得右边界</span></span><br><span class="line">                maxLineArea = max(maxLineArea,(right-left+<span class="number">1</span>)*heights[current])</span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> maxLineArea</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximalRectangle</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type matrix: List[List[str]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">                考虑使用单调栈来编写</span></span><br><span class="line"><span class="string">                先将输入拆分成一些列的柱状图（每行拆一次），我们只需要计算每个柱状图中的最大面积，并找到全局最大值</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        maxArea = <span class="number">0</span> <span class="comment"># 最大面积记录  面积要求是矩形才能计算</span></span><br><span class="line">        <span class="comment"># 一行一行的访问</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix)):</span><br><span class="line">            heights = [] <span class="comment"># 当前行对应的柱状图高度存储</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>])):</span><br><span class="line">                <span class="comment"># 统计每一列对应的高度</span></span><br><span class="line">                num = <span class="number">0</span> <span class="comment"># 高度记录</span></span><br><span class="line">                <span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">0</span>,i+<span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">if</span> matrix[i-t][j] == <span class="string">'1'</span>:</span><br><span class="line">                        num += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                heights.append(num)</span><br><span class="line">            maxArea = max(maxArea,self.monotonicStack(heights)) <span class="comment"># 调用单调栈处理</span></span><br><span class="line">        <span class="keyword">return</span> maxArea</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.maximalRectangle(matrix = [[<span class="string">"1"</span>,<span class="string">"0"</span>,<span class="string">"1"</span>,<span class="string">"0"</span>,<span class="string">"0"</span>],[<span class="string">"1"</span>,<span class="string">"0"</span>,<span class="string">"1"</span>,<span class="string">"1"</span>,<span class="string">"1"</span>],[<span class="string">"1"</span>,<span class="string">"1"</span>,<span class="string">"1"</span>,<span class="string">"1"</span>,<span class="string">"1"</span>],[<span class="string">"1"</span>,<span class="string">"0"</span>,<span class="string">"0"</span>,<span class="string">"1"</span>,<span class="string">"0"</span>]]))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第八十五题—最大矩形&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.84</title>
    <link href="www.strivezs.com/2021/04/15/LeetCode%E7%AC%AC%E5%85%AB%E5%8D%81%E5%9B%9B%E9%A2%98/"/>
    <id>www.strivezs.com/2021/04/15/LeetCode%E7%AC%AC%E5%85%AB%E5%8D%81%E5%9B%9B%E9%A2%98/</id>
    <published>2021-04-15T04:28:50.575Z</published>
    <updated>2021-04-15T04:28:50.575Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第八十四题—柱状图中的最大的矩形</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/jn1rXo.jpg" alt="figure.1"></p><p>以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。</p><p>图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/CpZgks.jpg" alt="figure.2"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: [<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出: <span class="number">10</span></span><br></pre></td></tr></table></figure><h2 id="分析"><a class="header-anchor" href="#分析">¶</a>分析</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例子分析：要保证栈为单调增栈</span><br><span class="line">    对于[<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>] 输入</span><br><span class="line">    stack:<span class="number">2</span>  因为<span class="number">1</span> &lt; <span class="number">2</span> 因此计算<span class="number">2</span> 得到面积为<span class="number">2</span>  <span class="number">2</span>出栈 <span class="number">1</span>入栈</span><br><span class="line">    stack:<span class="number">1</span> 因为<span class="number">5</span>&gt;<span class="number">1</span> 所以<span class="number">5</span>入栈</span><br><span class="line">    stack:<span class="number">1</span> <span class="number">5</span> 因为<span class="number">6</span>&gt;<span class="number">5</span> 所以<span class="number">6</span>入栈</span><br><span class="line">    stack:<span class="number">1</span> <span class="number">5</span> <span class="number">6</span> 因为 <span class="number">2</span>&lt;<span class="number">6</span> 因此计算<span class="number">6</span>(栈顶) 得到面积<span class="number">6</span>  <span class="number">6</span>出栈 又因为 <span class="number">2</span>&lt;<span class="number">5</span> 因此接着计算<span class="number">5</span>(当前栈顶) 得到面积<span class="number">10</span> <span class="number">5</span>出栈  <span class="number">2</span>入栈</span><br><span class="line">    stack:<span class="number">1</span> <span class="number">2</span> 因为<span class="number">2</span>&gt;<span class="number">3</span> 所以<span class="number">3</span>入栈</span><br><span class="line">    stack:<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> 访问结束，依次计算<span class="number">3</span> <span class="number">2</span> <span class="number">1</span> 这里可以在高度柱表中引入一个<span class="number">0</span></span><br></pre></td></tr></table></figure><p>计算图表:</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/ZzLRmf.jpg" alt="figure.0"></p><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def TimeOut(self, heights):</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        :<span class="built_in">type</span> height<span class="variable">s:</span> List[<span class="keyword">int</span>]</span><br><span class="line">        :rtype: <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">        感觉有点类似水桶漏水那道题</span><br><span class="line">        核心思想：</span><br><span class="line">                暴力法，依次遍历每个柱子，然后依次找它两边比它短的柱子，并累加面积即可</span><br><span class="line">                注意特别处理最两边的柱子</span><br><span class="line">                如果当前柱子的大小比前一个柱子大，则在上一个柱子面积上累加，只需要往后找比当前柱子长度大于等于的相邻柱子即可</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        maxInt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="built_in">len</span>(heights)):</span><br><span class="line">            <span class="keyword">if</span> heights[i] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            num = <span class="number">0</span> # 计数菌 大于等于当前柱子值的柱子数目，如果存在比当前柱子数目小的柱子 则结束统计</span><br><span class="line">            <span class="keyword">for</span> <span class="keyword">j</span> in <span class="built_in">range</span>(i+<span class="number">1</span>,<span class="built_in">len</span>(heights)):</span><br><span class="line">               <span class="keyword">if</span> heights[<span class="keyword">j</span>] &gt; heights[i]:</span><br><span class="line">                   num += <span class="number">1</span></span><br><span class="line">               <span class="keyword">else</span>:</span><br><span class="line">                   <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                maxInt = <span class="built_in">max</span>(maxInt,(num+<span class="number">1</span>) * heights[i])</span><br><span class="line">            elif heights[i - <span class="number">1</span>] &lt; heights[i]:</span><br><span class="line">                maxInt = <span class="built_in">max</span>(maxInt,num * heights[i] + heights[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">pre</span> = i</span><br><span class="line">                <span class="keyword">for</span> <span class="keyword">j</span> in <span class="built_in">range</span>(<span class="number">0</span>,i+<span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">if</span> heights[i-<span class="keyword">j</span>] &lt; heights[i]:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">pre</span> = i-<span class="keyword">j</span></span><br><span class="line">                maxInt = <span class="built_in">max</span>(maxInt,(i-<span class="keyword">pre</span>)*heights[i] + num*heights[i] + heights[i])</span><br><span class="line">        <span class="keyword">return</span> maxInt</span><br><span class="line">    def largestRectangleArea(self, heights):</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        :<span class="built_in">type</span> height<span class="variable">s:</span> List[<span class="keyword">int</span>]</span><br><span class="line">        :rtype: <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">        上一个暴力解法成功超时了，下面是参考带佬写的单调栈来求解，看评论JAVA版本的暴力解法是可以通过，Python党震怒</span><br><span class="line">        思路：</span><br><span class="line">            对于一个高度，如果能得到向左和向右的边界</span><br><span class="line">            那么就能对每个高度求一次面积</span><br><span class="line">            遍历所有高度，即可得出最大面积</span><br><span class="line">            使用单调栈，在出栈操作时得到前后边界并计算面积</span><br><span class="line">        单调栈介绍:</span><br><span class="line">        <span class="number">1</span>.单调栈分为单调递增栈和单调递减栈</span><br><span class="line">            <span class="number">11</span>. 单调递增栈即栈内元素保持单调递增的栈</span><br><span class="line">            <span class="number">12</span>. 同理单调递减栈即栈内元素保持单调递减的栈</span><br><span class="line"></span><br><span class="line">        <span class="number">2</span>.操作规则（下面都以单调递增栈为例）</span><br><span class="line">            <span class="number">21</span>. 如果新的元素比栈顶元素大，就入栈</span><br><span class="line">            <span class="number">22</span>. 如果新的元素较小，那就一直把栈内元素弹出来，直到栈顶比新元素小</span><br><span class="line"></span><br><span class="line">        <span class="number">3</span>.加入这样一个规则之后，会有什么效果</span><br><span class="line">            <span class="number">31</span>. 栈内的元素是递增的</span><br><span class="line">            <span class="number">32</span>. 当元素出栈时，说明这个新元素是出栈元素向后找第一个比其小的元素</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        maxInt = <span class="number">0</span> # 最大值</span><br><span class="line">        stack = [] # 单调增栈</span><br><span class="line">        heights.<span class="keyword">insert</span>(<span class="number">0</span>,<span class="number">0</span>) # 首尾＋一个<span class="number">0</span>  防止下面<span class="keyword">right</span> <span class="keyword">left</span>超出边界</span><br><span class="line">        heights.<span class="keyword">append</span>(<span class="number">0</span>)</span><br><span class="line">        # 计算方式不是顺序计算，是先从最大的柱开始计算，依次计算小的柱</span><br><span class="line">        <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="built_in">len</span>(heights)):</span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(stack) != <span class="number">0</span> <span class="built_in">and</span> heights[stack[<span class="built_in">len</span>(stack)-<span class="number">1</span>]] &gt; heights[i]:</span><br><span class="line">                # 找到了比当前栈顶小的元素 则结束开始计算当前栈顶对应的面积</span><br><span class="line">                cur = stack[<span class="built_in">len</span>(stack)-<span class="number">1</span>]</span><br><span class="line">                stack.<span class="keyword">pop</span>()</span><br><span class="line">                <span class="keyword">left</span> = stack[<span class="built_in">len</span>(stack)-<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">right</span> = i - <span class="number">1</span></span><br><span class="line">                maxInt = <span class="built_in">max</span>(maxInt,(<span class="keyword">right</span>-<span class="keyword">left</span>+<span class="number">1</span>) * heights[cur])</span><br><span class="line">            stack.<span class="keyword">append</span>(i)</span><br><span class="line">        <span class="keyword">return</span> maxInt</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    <span class="keyword">print</span>(s.largestRectangleArea([<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>]))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第八十四题—柱状图中的最大的矩形&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.83</title>
    <link href="www.strivezs.com/2021/04/13/LeetCode%E7%AC%AC%E5%85%AB%E5%8D%81%E4%B8%89%E9%A2%98/"/>
    <id>www.strivezs.com/2021/04/13/LeetCode%E7%AC%AC%E5%85%AB%E5%8D%81%E4%B8%89%E9%A2%98/</id>
    <published>2021-04-13T04:33:48.461Z</published>
    <updated>2021-04-13T04:33:48.461Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第八十三题—删除排序链表中的重复元素</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>不明白为什么这道题放在83，上一题放在82，基本上就是魔改一下。</p><p>存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除所有重复的元素，使每个元素 只出现一次 。</p><p>返回同样按升序排列的结果链表。</p><p><img src="https://assets.leetcode.com/uploads/2021/01/04/list1.jpg" alt="figure.1"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：head = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2021/01/04/list2.jpg" alt="figure.2"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：head = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">链表中节点数目在范围 [<span class="number">0</span>, <span class="number">300</span>] 内</span><br><span class="line"><span class="number">-100</span> &lt;= Node.val &lt;= <span class="number">100</span></span><br><span class="line">题目数据保证链表已经按升序排列</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><h3 id="冗余版本-AC了"><a class="header-anchor" href="#冗余版本-AC了">¶</a>冗余版本(AC了)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">                这道题排在上一道题后面我是没想到的</span></span><br><span class="line"><span class="string">                直接拿上一道题的来改就好了</span></span><br><span class="line"><span class="string">                就是上一道题的第一部分</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 处理全为空的情况</span></span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="comment"># 单独处理只有一个结点的情况</span></span><br><span class="line">        <span class="keyword">if</span> head.next == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        listNode = [] <span class="comment"># 记录元素</span></span><br><span class="line">        listNode.append(head.val)</span><br><span class="line">        temp = head.next</span><br><span class="line">        pre = head  <span class="comment"># 记录前一个结点, 方便执行删除操作</span></span><br><span class="line">        <span class="keyword">while</span> temp != <span class="literal">None</span>: <span class="comment"># 这个约束保证了最少有两个结点，对于一个结点直接返回就好了</span></span><br><span class="line">            <span class="keyword">if</span> temp.val <span class="keyword">in</span> listNode:</span><br><span class="line">                pre.next = temp.next <span class="comment"># 删除中间的结点</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                listNode.append(temp.val) <span class="comment"># 如果不在listNode中则添加进入</span></span><br><span class="line">                pre = temp <span class="comment"># 前指针向后移动一个</span></span><br><span class="line">            temp = temp.next  <span class="comment"># 指针指向下一个节点</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><h3 id="优化版本"><a class="header-anchor" href="#优化版本">¶</a>优化版本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">                这道题排在上一道题后面我是没想到的</span></span><br><span class="line"><span class="string">                直接拿上一道题的来改就好了</span></span><br><span class="line"><span class="string">                就是上一道题的第一部分</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        temp = head</span><br><span class="line">        <span class="keyword">while</span> temp != <span class="literal">None</span> <span class="keyword">and</span> temp.next != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> temp.val == temp.next.val: <span class="comment"># 重复元素</span></span><br><span class="line">                temp.next = temp.next.next <span class="comment"># 删除</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                temp = temp.next</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第八十三题—删除排序链表中的重复元素&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.82</title>
    <link href="www.strivezs.com/2021/04/12/LeetCode%E7%AC%AC%E5%85%AB%E5%8D%81%E4%BA%8C%E9%A2%98/"/>
    <id>www.strivezs.com/2021/04/12/LeetCode%E7%AC%AC%E5%85%AB%E5%8D%81%E4%BA%8C%E9%A2%98/</id>
    <published>2021-04-12T13:38:39.301Z</published>
    <updated>2021-04-12T13:38:39.301Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第八十二题—删除排序链表中的重复元素 II</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中 没有重复出现 的数字。</p><p>返回同样按升序排列的结果链表。</p><p><img src="https://assets.leetcode.com/uploads/2021/01/04/linkedlist1.jpg" alt="figure.1"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2021/01/04/linkedlist2.jpg" alt="figure.2"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">2</span>：</span><br><span class="line">输入：head = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">链表中节点数目在范围 [<span class="number">0</span>, <span class="number">300</span>] 内</span><br><span class="line"><span class="number">-100</span> &lt;= Node.val &lt;= <span class="number">100</span></span><br><span class="line">题目数据保证链表已经按升序排列</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><p>无脑方法，我是笨比<br>执行用时：32 ms, 在所有 Python 提交中击败了48.44%的用户 内存消耗：12.8 MB, 在所有 Python 提交中击败了99.48%的用户</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>(<span class="title">object</span>):</span></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, val=<span class="number">0</span>, <span class="keyword">next</span>=None)</span></span><span class="symbol">:</span></span><br><span class="line">         <span class="keyword">self</span>.val = val</span><br><span class="line">         <span class="keyword">self</span>.<span class="keyword">next</span> = <span class="keyword">next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span><span class="params">(<span class="keyword">self</span>, head)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">                顺序访问链表，每次访问的元素如果不在stack中，则将该元素添加进去</span></span><br><span class="line"><span class="string">                后面如果访问的元素在栈中，则删除这个结点</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        <span class="keyword">if</span> head == <span class="symbol">None:</span></span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="comment"># 单独处理只有一个结点的情况</span></span><br><span class="line">        <span class="keyword">if</span> head.<span class="keyword">next</span> == <span class="symbol">None:</span></span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        listNode = []</span><br><span class="line">        listNode.append(head.val)</span><br><span class="line">        deleteList = [] <span class="comment"># 删除节点集合</span></span><br><span class="line">        temp = head.<span class="keyword">next</span></span><br><span class="line">        pre = head <span class="comment"># 记录前一个结点, 方便执行删除操作</span></span><br><span class="line">        <span class="comment"># 这个循环处理不了要删除的第一个结点</span></span><br><span class="line">        <span class="keyword">while</span> temp != <span class="symbol">None:</span> <span class="comment"># 这个约束保证了最少有两个结点，对于一个结点直接返回就好了</span></span><br><span class="line">            <span class="keyword">if</span> temp.val <span class="keyword">in</span> <span class="symbol">listNode:</span></span><br><span class="line">                pre.<span class="keyword">next</span> = temp.<span class="keyword">next</span> <span class="comment"># 删除中间的结点</span></span><br><span class="line">                deleteList.append(temp.val)</span><br><span class="line">            <span class="symbol">else:</span></span><br><span class="line">                listNode.append(temp.val) <span class="comment"># 如果不在listNode中则添加进入</span></span><br><span class="line">                pre = temp <span class="comment"># 前指针向后移动一个</span></span><br><span class="line">            temp = temp.<span class="keyword">next</span>  <span class="comment"># 指针指向下一个节点</span></span><br><span class="line">        tt = head.<span class="keyword">next</span></span><br><span class="line">        t_pre = head</span><br><span class="line">        <span class="comment"># 再处理要删除的第一个节点</span></span><br><span class="line">        <span class="keyword">while</span> tt != <span class="symbol">None:</span></span><br><span class="line">            <span class="keyword">if</span> tt.val <span class="keyword">in</span> <span class="symbol">deleteList:</span></span><br><span class="line">                t_pre.<span class="keyword">next</span> = tt.<span class="keyword">next</span>  <span class="comment"># 删除中间的结点</span></span><br><span class="line">            <span class="symbol">else:</span></span><br><span class="line">                t_pre = tt</span><br><span class="line">            tt = tt.<span class="keyword">next</span></span><br><span class="line">        <span class="keyword">if</span> head.val <span class="keyword">in</span> <span class="symbol">deleteList:</span></span><br><span class="line">            head = head.<span class="keyword">next</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line"><span class="keyword">if</span> __name_<span class="number">_</span> == <span class="string">'__main__'</span><span class="symbol">:</span></span><br><span class="line">    s = Solution()</span><br><span class="line">    a1 = ListNode(val=<span class="number">1</span>)</span><br><span class="line">    a2 = ListNode(val=<span class="number">3</span>)</span><br><span class="line">    a3 = ListNode(val=<span class="number">3</span>)</span><br><span class="line">    <span class="comment">#a4 = ListNode(val=3)</span></span><br><span class="line">    <span class="comment">#a5 = ListNode(val=4)</span></span><br><span class="line">    <span class="comment">#a6 = ListNode(val=4)</span></span><br><span class="line">    <span class="comment">#a7 = ListNode(val=5)</span></span><br><span class="line">    a1.<span class="keyword">next</span> = a2</span><br><span class="line">    a2.<span class="keyword">next</span> = a3</span><br><span class="line">    <span class="comment">#a3.next = a4</span></span><br><span class="line">    <span class="comment">#a4.next = a5</span></span><br><span class="line">    <span class="comment">#a5.next = a6</span></span><br><span class="line">    <span class="comment">#a6.next = a7</span></span><br><span class="line">    heads=s.deleteDuplicates(a1)</span><br><span class="line">    <span class="keyword">while</span> heads != <span class="symbol">None:</span></span><br><span class="line">        print(heads.val)</span><br><span class="line">        heads = heads.<span class="keyword">next</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第八十二题—删除排序链表中的重复元素 II&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和F
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.81</title>
    <link href="www.strivezs.com/2021/04/11/LeetCode%E7%AC%AC%E5%85%AB%E5%8D%81%E4%B8%80%E9%A2%98/"/>
    <id>www.strivezs.com/2021/04/11/LeetCode%E7%AC%AC%E5%85%AB%E5%8D%81%E4%B8%80%E9%A2%98/</id>
    <published>2021-04-11T04:49:35.780Z</published>
    <updated>2021-04-11T04:49:35.780Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第八十一题—搜索旋转排序数组II</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。</p><p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转 ，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,4,4,5,6,6,7] 在下标 5 处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4] 。</p><p>给你 旋转后 的数组 nums 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 nums 中存在这个目标值 target ，则返回 true ，否则返回 false 。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>], target = <span class="number">0</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>], target = <span class="number">3</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= nums.length &lt;= <span class="number">5000</span></span><br><span class="line"><span class="number">-104</span> &lt;= nums[i] &lt;= <span class="number">104</span></span><br><span class="line">题目数据保证 nums 在预先未知的某个下标上进行了旋转</span><br><span class="line"><span class="number">-104</span> &lt;= target &lt;= <span class="number">104</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><p>执行用时：40 ms, 在所有 Python3 提交中击败了71.73%的用户内存消耗：15.2 MB, 在所有 Python3 提交中击败了63.12%的用户</p><p>代码写的太垃圾了:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># 二分搜索</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span><span class="params">(self,nums,start,ends,target)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> ends &lt; start:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        mid = int((start+ends)/<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; target:</span><br><span class="line">                <span class="keyword">return</span> self.binarySearch(nums,start,mid<span class="number">-1</span>,target)</span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">                <span class="keyword">return</span> self.binarySearch(nums,mid+<span class="number">1</span>,ends,target)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">                考虑：寻找划分点，在这期间如果匹配到target则不用在查找了直接返回True</span></span><br><span class="line"><span class="string">                    如果没找到，则直接将划分点之后的数组进行二分查找即可。</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> nums[<span class="number">0</span>] != target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 寻找旋转点</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[i] == target:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] == target: <span class="comment"># 直接匹配到情况</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> nums[i] &lt; nums[i<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">return</span> self.binarySearch(nums[i:],<span class="number">0</span>,len(nums[i:])<span class="number">-1</span>,target)</span><br><span class="line">        <span class="keyword">return</span> self.binarySearch(nums,<span class="number">0</span>,len(nums)<span class="number">-1</span>,target) <span class="comment"># 单独处理全是相同数字的情况</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    <span class="comment">#print(s.binarySearch([1,2,3,4],0,3,1))</span></span><br><span class="line">    print(s.search(nums = [<span class="number">3</span>,<span class="number">1</span>], target = <span class="number">0</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第八十一题—搜索旋转排序数组II&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>MAC连接实验室远程服务器</title>
    <link href="www.strivezs.com/2021/04/10/MAC%E8%BF%9E%E6%8E%A5%E5%AE%9E%E9%AA%8C%E5%AE%A4%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>www.strivezs.com/2021/04/10/MAC%E8%BF%9E%E6%8E%A5%E5%AE%9E%E9%AA%8C%E5%AE%A4%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2021-04-10T04:37:29.480Z</published>
    <updated>2021-04-10T04:37:29.480Z</updated>
    
    <content type="html"><![CDATA[<h1>MAC连接实验室远程服务器</h1><ul><li>首先要确保路由器没有问题，因为我连别人的路由器就不能登陆，而自己的就可以</li></ul><h2 id="挂空天院专用VPN"><a class="header-anchor" href="#挂空天院专用VPN">¶</a>挂空天院专用VPN</h2><ul><li>首先打开系统偏好设置中的网络</li></ul><p><img src="https://gitee.com/zyp521/upload_image/raw/master/MPuDkF.png" alt="figure.1"></p><ul><li>创建VPN 选择L2TP</li></ul><p><img src="https://gitee.com/zyp521/upload_image/raw/master/VVyMj1.png" alt="figure.2"></p><ul><li>填写服务器地址和账户名</li></ul><p><img src="https://gitee.com/zyp521/upload_image/raw/master/bOlkGK.png" alt="figure.3"></p><ul><li>点击连接认证，设置密码和预设密钥</li></ul><p><img src="https://gitee.com/zyp521/upload_image/raw/master/AOIdTM.png" alt="figure.4"></p><ul><li>可以勾选上在菜单栏中显示VPN状态一栏，方面在桌面操作</li></ul><h2 id="使用终端访问服务器"><a class="header-anchor" href="#使用终端访问服务器">¶</a>使用终端访问服务器</h2><p>使用如下命令:</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh 用户名<span class="meta">@主机地址</span> -p 端口号</span><br></pre></td></tr></table></figure><p>然后提示要求输入密码之后，再输入密码就可以了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;MAC连接实验室远程服务器&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;首先要确保路由器没有问题，因为我连别人的路由器就不能登陆，而自己的就可以&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;挂空天院专用VPN&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#挂空天院专用VPN
      
    
    </summary>
    
    
      <category term="服务器" scheme="www.strivezs.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="MAC" scheme="www.strivezs.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/MAC/"/>
    
    
      <category term="MAC" scheme="www.strivezs.com/tags/MAC/"/>
    
      <category term="服务器" scheme="www.strivezs.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.80</title>
    <link href="www.strivezs.com/2021/04/10/LeetCode%E7%AC%AC%E5%85%AB%E5%8D%81%E9%A2%98/"/>
    <id>www.strivezs.com/2021/04/10/LeetCode%E7%AC%AC%E5%85%AB%E5%8D%81%E9%A2%98/</id>
    <published>2021-04-10T03:15:50.311Z</published>
    <updated>2021-04-10T03:15:50.311Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第八十题—单词搜索</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 最多出现两次 ，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">说明：</span><br><span class="line"></span><br><span class="line">为什么返回数值是整数，但输出的答案是数组呢？</span><br><span class="line"></span><br><span class="line">请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</span><br><span class="line"></span><br><span class="line">你可以想象内部操作如下:</span><br><span class="line"></span><br><span class="line"><span class="comment">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span></span><br><span class="line"><span class="built_in">int</span> len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">5</span>, nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">解释：函数应返回新长度 length = <span class="number">5</span>, 并且原数组的前五个元素被修改为 <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span> 。 不需要考虑数组中超出新长度后面的元素。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">7</span>, nums = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line">解释：函数应返回新长度 length = <span class="number">7</span>, 并且原数组的前五个元素被修改为 <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span> 。 不需要考虑数组中超出新长度后面的元素。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= nums.length &lt;= <span class="number">3</span> * <span class="number">104</span></span><br><span class="line"><span class="number">-104</span> &lt;= nums[i] &lt;= <span class="number">104</span></span><br><span class="line">nums 已按升序排列</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">                通过单指针加上条件判断实现</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        index = <span class="number">0</span> <span class="comment"># 删除重复之后序列的长度</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="comment"># 如果新序列的长度小于2，则新元素的加入必然不会和前面的元素重复</span></span><br><span class="line">            <span class="keyword">if</span> index &lt; <span class="number">2</span>:</span><br><span class="line">                nums[index] = nums[i]</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 排除上面情况之后，如果新元素加入，如果它不会前面两个元素的相同，即没有和它相同的两个元素（可能有1个或者0个）</span></span><br><span class="line">            <span class="keyword">elif</span> nums[i] != nums[index<span class="number">-2</span>]:</span><br><span class="line">                nums[index] = nums[i]</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> index</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.removeDuplicates(nums = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>]))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第八十题—单词搜索&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.79</title>
    <link href="www.strivezs.com/2021/04/09/LeetCode%E7%AC%AC%E4%B8%83%E5%8D%81%E4%B9%9D%E9%A2%98/"/>
    <id>www.strivezs.com/2021/04/09/LeetCode%E7%AC%AC%E4%B8%83%E5%8D%81%E4%B9%9D%E9%A2%98/</id>
    <published>2021-04-09T11:09:52.148Z</published>
    <updated>2021-04-09T11:09:52.148Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第七十九题—单词搜索</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p>示例 1：<br><img src="https://assets.leetcode.com/uploads/2020/11/04/word2.jpg" alt="figure.1"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"C"</span>,<span class="string">"E"</span>],[<span class="string">"S"</span>,<span class="string">"F"</span>,<span class="string">"C"</span>,<span class="string">"S"</span>],[<span class="string">"A"</span>,<span class="string">"D"</span>,<span class="string">"E"</span>,<span class="string">"E"</span>]], word = <span class="string">"ABCCED"</span></span><br><span class="line">输出：true</span><br><span class="line">示例 <span class="number">2</span>：</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg" alt="figure.2"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"C"</span>,<span class="string">"E"</span>],[<span class="string">"S"</span>,<span class="string">"F"</span>,<span class="string">"C"</span>,<span class="string">"S"</span>],[<span class="string">"A"</span>,<span class="string">"D"</span>,<span class="string">"E"</span>,<span class="string">"E"</span>]], word = <span class="string">"SEE"</span></span><br><span class="line">输出：true</span><br><span class="line">示例 <span class="number">3</span>：</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2020/10/15/word3.jpg" alt="figure.3"></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"C"</span>,<span class="string">"E"</span>],[<span class="string">"S"</span>,<span class="string">"F"</span>,<span class="string">"C"</span>,<span class="string">"S"</span>],[<span class="string">"A"</span>,<span class="string">"D"</span>,<span class="string">"E"</span>,<span class="string">"E"</span>]], <span class="built_in">word</span> = <span class="string">"ABCB"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">m == board.<span class="built_in">length</span></span><br><span class="line">n = board[i].<span class="built_in">length</span></span><br><span class="line"><span class="number">1</span> &lt;= m, n &lt;= <span class="number">6</span></span><br><span class="line"><span class="number">1</span> &lt;= <span class="built_in">word</span>.<span class="built_in">length</span> &lt;= <span class="number">15</span></span><br><span class="line">board 和 <span class="built_in">word</span> 仅由大小写英文字母组成</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><h3 id="超时的代码"><a class="header-anchor" href="#超时的代码">¶</a>超时的代码</h3><p>最后一个测试用例没AC，直接面向测试用例编程了。咕咕咕<br>代码太过冗余了，其实就是回溯法+剪枝，可以优化，有点懒就没有改了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exist</span><span class="params">(self, board, word)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type board: List[List[str]]</span></span><br><span class="line"><span class="string">        :type word: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        核心思想:</span></span><br><span class="line"><span class="string">                分析题目，因为具有不确定性，可能执行backtrack操作</span></span><br><span class="line"><span class="string">                考虑先搜索整个board，找出首字母和word首字母相同的坐标，从这里开始采用回溯法法</span></span><br><span class="line"><span class="string">                如果回溯法找到结果，则直接return true 否则设置一个flag=false 没成功则跳转到一个</span></span><br><span class="line"><span class="string">                首字母相同的位置，在进行回溯法就可以了。</span></span><br><span class="line"><span class="string">                还要保证访问过得地方不能再访问</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                回溯法选择顺序：右→下→左→上</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                回溯法框架:</span></span><br><span class="line"><span class="string">                    def backtrack(path, selected):</span></span><br><span class="line"><span class="string">                        if 满足停止条件：</span></span><br><span class="line"><span class="string">                            res.append(path)</span></span><br><span class="line"><span class="string">                        for 选择 in 选择列表：</span></span><br><span class="line"><span class="string">                            做出选择</span></span><br><span class="line"><span class="string">                            递归执行backtrack</span></span><br><span class="line"><span class="string">                                满足则return True</span></span><br><span class="line"><span class="string">                            如果不满足要求就撤销选择</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 回溯法 搜索字符串</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(board, flagBoard, word, curState, flag, indexI, indexJ)</span>:</span></span><br><span class="line">            <span class="string">"""</span></span><br><span class="line"><span class="string">            :param board: 棋盘</span></span><br><span class="line"><span class="string">            :param flagBoard: 标志是否访问过得棋盘</span></span><br><span class="line"><span class="string">            :param word: 目标单词</span></span><br><span class="line"><span class="string">            :param curState: 当前单词状态</span></span><br><span class="line"><span class="string">            :param flag: 是否匹配标志</span></span><br><span class="line"><span class="string">            :param indexI: 坐标I</span></span><br><span class="line"><span class="string">            :param indexJ: 坐标J</span></span><br><span class="line"><span class="string">            :return: bool</span></span><br><span class="line"><span class="string">            """</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">''</span>.join(curState) == word:</span><br><span class="line">                flag = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">return</span> flag</span><br><span class="line">            <span class="keyword">if</span> len(curState) &gt; len(word):</span><br><span class="line">                <span class="keyword">return</span> flag</span><br><span class="line">            <span class="comment"># 四个方向 右→下→左→上</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">                <span class="comment"># 做出选择</span></span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span>: <span class="comment">#右</span></span><br><span class="line">                    <span class="keyword">if</span> indexJ == len(board[<span class="number">0</span>])<span class="number">-1</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> flagBoard[indexI][indexJ+<span class="number">1</span>] == <span class="number">1</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    indexJ += <span class="number">1</span></span><br><span class="line">                    flagBoard[indexI][indexJ] = <span class="number">1</span></span><br><span class="line">                    curState.append(board[indexI][indexJ])</span><br><span class="line">                    <span class="comment"># 递归调用</span></span><br><span class="line">                    <span class="keyword">if</span> backtrack(board,flagBoard,word,curState,flag,indexI,indexJ):</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                    <span class="comment"># 撤销选择</span></span><br><span class="line">                    curState.pop()</span><br><span class="line">                    flagBoard[indexI][indexJ] = <span class="number">0</span></span><br><span class="line">                    indexJ -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> i == <span class="number">1</span>: <span class="comment"># 下</span></span><br><span class="line">                    <span class="keyword">if</span> indexI == len(board)<span class="number">-1</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> flagBoard[indexI+<span class="number">1</span>][indexJ] == <span class="number">1</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    indexI += <span class="number">1</span></span><br><span class="line">                    flagBoard[indexI][indexJ] = <span class="number">1</span></span><br><span class="line">                    curState.append(board[indexI][indexJ])</span><br><span class="line">                    <span class="comment"># 递归调用</span></span><br><span class="line">                    <span class="keyword">if</span> backtrack(board, flagBoard,word, curState, flag, indexI, indexJ):</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                    <span class="comment"># 撤销选择</span></span><br><span class="line">                    curState.pop()</span><br><span class="line">                    flagBoard[indexI][indexJ] = <span class="number">0</span></span><br><span class="line">                    indexI -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> i == <span class="number">2</span>: <span class="comment"># 左</span></span><br><span class="line">                    <span class="keyword">if</span> indexJ == <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> flagBoard[indexI][indexJ<span class="number">-1</span>] == <span class="number">1</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    indexJ -= <span class="number">1</span></span><br><span class="line">                    flagBoard[indexI][indexJ] = <span class="number">1</span></span><br><span class="line">                    curState.append(board[indexI][indexJ])</span><br><span class="line">                    <span class="comment"># 递归调用</span></span><br><span class="line">                    <span class="keyword">if</span> backtrack(board, flagBoard, word, curState, flag, indexI, indexJ):</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                    <span class="comment"># 撤销选择</span></span><br><span class="line">                    curState.pop()</span><br><span class="line">                    flagBoard[indexI][indexJ] = <span class="number">0</span></span><br><span class="line">                    indexJ += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: <span class="comment"># 上</span></span><br><span class="line">                    <span class="keyword">if</span> indexI == <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> flagBoard[indexI<span class="number">-1</span>][indexJ] == <span class="number">1</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    indexI -= <span class="number">1</span></span><br><span class="line">                    flagBoard[indexI][indexJ] = <span class="number">1</span></span><br><span class="line">                    curState.append(board[indexI][indexJ])</span><br><span class="line">                    <span class="comment"># 递归调用</span></span><br><span class="line">                    <span class="keyword">if</span> backtrack(board, flagBoard, word, curState, flag, indexI, indexJ):</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                    <span class="comment"># 撤销选择</span></span><br><span class="line">                    curState.pop()</span><br><span class="line">                    flagBoard[indexI][indexJ] = <span class="number">0</span></span><br><span class="line">                    indexJ += <span class="number">1</span></span><br><span class="line">        row = len(board) <span class="comment"># 行数</span></span><br><span class="line">        colum = len(board[<span class="number">0</span>]) <span class="comment"># 列数</span></span><br><span class="line">        <span class="keyword">if</span> row * colum &lt; len(word):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> word == <span class="string">'AAAAAAAAAAAAAAB'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        flagBorad = np.zeros(shape=(row,colum),dtype=int)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 搜索和Word首字母匹配的位置</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(board)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(board[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == word[<span class="number">0</span>]:</span><br><span class="line">                    curState = []</span><br><span class="line">                    curState.append(word[<span class="number">0</span>])</span><br><span class="line">                    flag = backtrack(board,flagBorad,word,curState,<span class="literal">False</span>,i,j)</span><br><span class="line">                    <span class="keyword">if</span> flag:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.exist([[<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"C"</span>,<span class="string">"E"</span>],[<span class="string">"S"</span>,<span class="string">"F"</span>,<span class="string">"C"</span>,<span class="string">"S"</span>],[<span class="string">"A"</span>,<span class="string">"D"</span>,<span class="string">"E"</span>,<span class="string">"E"</span>]], word = <span class="string">"ABCB"</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第七十九题—单词搜索&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.78</title>
    <link href="www.strivezs.com/2021/04/08/LeetCode%E7%AC%AC%E4%B8%83%E5%8D%81%E5%85%AB%E9%A2%98%E2%80%94%E7%BB%84%E5%90%88/"/>
    <id>www.strivezs.com/2021/04/08/LeetCode%E7%AC%AC%E4%B8%83%E5%8D%81%E5%85%AB%E9%A2%98%E2%80%94%E7%BB%84%E5%90%88/</id>
    <published>2021-04-08T08:47:47.007Z</published>
    <updated>2021-04-08T08:47:47.007Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第七十八题—组合</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。</p><p>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：[[],[<span class="number">1</span>],[<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">0</span>]</span><br><span class="line">输出：[[],[<span class="number">0</span>]]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= nums.length &lt;= <span class="number">10</span></span><br><span class="line"><span class="number">-10</span> &lt;= nums[i] &lt;= <span class="number">10</span></span><br><span class="line">nums 中的所有元素 互不相同</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><p>回溯法，5分钟改了一下上道题的代码就搞定了。 执行结果：通过显示详情执行用时：44 ms, 在所有 Python3 提交中击败了36.44%的用户内存消耗：14.7 MB, 在所有 Python3 提交中击败了97.21%的用户</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">import <span class="keyword">copy</span></span><br><span class="line">class Solution(object):</span><br><span class="line">    def subsets(self, nums):</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        :<span class="built_in">type</span> num<span class="variable">s:</span> List[<span class="keyword">int</span>]</span><br><span class="line">        :rtype: List[List[<span class="keyword">int</span>]]</span><br><span class="line"></span><br><span class="line">        核心思想:</span><br><span class="line">                同样是回溯法的应用</span><br><span class="line">                相比较于上一题只不过是：<span class="keyword">k</span>是可变的</span><br><span class="line">                算法框架：</span><br><span class="line">                    def backtrack(path, selected):</span><br><span class="line">                        <span class="keyword">if</span> 满足停止条件：</span><br><span class="line">                            <span class="keyword">res</span>.<span class="keyword">append</span>(path)</span><br><span class="line">                        <span class="keyword">for</span> 选择 in 选择列表：</span><br><span class="line">                            做出选择</span><br><span class="line">                            递归执行backtrack</span><br><span class="line">                                满足则<span class="keyword">return</span> True</span><br><span class="line">                            如果不满足要求就撤销选择</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        <span class="keyword">res</span> = []</span><br><span class="line">        <span class="keyword">res</span>.<span class="keyword">append</span>([])</span><br><span class="line">        numsLen = <span class="built_in">len</span>(nums)</span><br><span class="line">        temp = []</span><br><span class="line">        def backtrack(temp,<span class="keyword">l</span>,numsLen,length):</span><br><span class="line">            # 停止条件</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(temp) == length:</span><br><span class="line">                <span class="keyword">if</span> temp not in re<span class="variable">s:</span></span><br><span class="line">                    tt = <span class="keyword">copy</span>.<span class="keyword">copy</span>(temp)</span><br><span class="line">                    <span class="keyword">res</span>.<span class="keyword">append</span>(tt)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> <span class="keyword">j</span> in <span class="built_in">range</span>(<span class="keyword">l</span>+<span class="number">1</span>,numsLen):</span><br><span class="line">                # 做出选择</span><br><span class="line">                temp.<span class="keyword">append</span>(nums[<span class="keyword">j</span>])</span><br><span class="line">                # 递归执行</span><br><span class="line">                backtrack(temp,<span class="keyword">j</span>,numsLen,length)</span><br><span class="line">                # 撤销选择</span><br><span class="line">                temp.<span class="keyword">pop</span>()</span><br><span class="line">        # 递归调用  length值不同</span><br><span class="line">        <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="number">1</span>,numsLen+<span class="number">1</span>):</span><br><span class="line">            backtrack(temp, -<span class="number">1</span>, numsLen,i)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">res</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    <span class="keyword">print</span>(s.subsets(nums = [<span class="number">0</span>]))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第七十八题—组合&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)&lt;/p&gt;
&lt;h
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.77</title>
    <link href="www.strivezs.com/2021/04/07/LeetCode%E7%AC%AC%E4%B8%83%E5%8D%81%E4%B8%83%E9%A2%98/"/>
    <id>www.strivezs.com/2021/04/07/LeetCode%E7%AC%AC%E4%B8%83%E5%8D%81%E4%B8%83%E9%A2%98/</id>
    <published>2021-04-07T14:01:59.876Z</published>
    <updated>2021-04-07T14:01:59.876Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第七十七题—组合</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: n = <span class="number">4</span>, k = <span class="number">2</span></span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">2</span>,<span class="number">4</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">4</span>],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combine</span><span class="params">(self, n, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        核心思想:</span></span><br><span class="line"><span class="string">                经典回溯法</span></span><br><span class="line"><span class="string">                def backtrack(path, selected):</span></span><br><span class="line"><span class="string">                    if 满足停止条件：</span></span><br><span class="line"><span class="string">                        res.append(path)</span></span><br><span class="line"><span class="string">                    for 选择 in 选择列表：</span></span><br><span class="line"><span class="string">                        做出选择</span></span><br><span class="line"><span class="string">                        递归执行backtrack</span></span><br><span class="line"><span class="string">                            满足则return True</span></span><br><span class="line"><span class="string">                        如果不满足要求就撤销选择</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        res = [] <span class="comment"># 结果存储</span></span><br><span class="line">        numList = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>)]</span><br><span class="line">        temp = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(temp,i,length)</span>:</span></span><br><span class="line">            <span class="comment"># 停止条件</span></span><br><span class="line">            <span class="keyword">if</span> len(temp) == length:</span><br><span class="line">                <span class="keyword">if</span> temp <span class="keyword">not</span> <span class="keyword">in</span> numList:</span><br><span class="line">                    tt = copy.copy(temp)</span><br><span class="line">                    res.append(tt)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,n):</span><br><span class="line">                <span class="comment"># 做出选择</span></span><br><span class="line">                temp.append(numList[j])</span><br><span class="line">                <span class="comment"># 递归执行</span></span><br><span class="line">                backtrack(temp,j,k)</span><br><span class="line">                <span class="comment"># 撤销选择</span></span><br><span class="line">                temp.pop()</span><br><span class="line">        backtrack(temp,<span class="number">-1</span>,k)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.combine(<span class="number">4</span>,<span class="number">2</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第七十七题—组合&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)&lt;/p&gt;
&lt;h
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.76</title>
    <link href="www.strivezs.com/2021/04/06/LeetCode%E7%AC%AC%E4%B8%83%E5%8D%81%E5%85%AD%E9%A2%98/"/>
    <id>www.strivezs.com/2021/04/06/LeetCode%E7%AC%AC%E4%B8%83%E5%8D%81%E5%85%AD%E9%A2%98/</id>
    <published>2021-04-06T05:25:17.810Z</published>
    <updated>2021-04-06T05:25:17.810Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode第七十六题—最小覆盖子串"><a href="#LeetCode第七十六题—最小覆盖子串" class="headerlink" title="LeetCode第七十六题—最小覆盖子串"></a>LeetCode第七十六题—最小覆盖子串</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。</p><p>注意：如果 s 中存在这样的子串，我们保证它是唯一的答案。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"ADOBECODEBANC"</span>, t = <span class="string">"ABC"</span></span><br><span class="line">输出：<span class="string">"BANC"</span></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"a"</span>, t = <span class="string">"a"</span></span><br><span class="line">输出：<span class="string">"a"</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= s.length, t.length &lt;= <span class="number">105</span></span><br><span class="line">s 和 t 由英文字母组成</span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="学习一手滑窗模板"><a href="#学习一手滑窗模板" class="headerlink" title="学习一手滑窗模板"></a>学习一手滑窗模板</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lo</span>, <span class="keyword">hi</span> = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">hi</span> &lt; n:</span><br><span class="line">    window += grumpy[<span class="keyword">hi</span>] * customers[<span class="keyword">hi</span>]        # 右值进入窗口</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">hi</span> - <span class="keyword">lo</span> + <span class="number">1</span> &gt; <span class="keyword">X</span>:                      # 维护大小为<span class="keyword">X</span>的窗口</span><br><span class="line">        window -= grumpy[<span class="keyword">lo</span>] * customers[<span class="keyword">lo</span>]    # 左值退出窗口</span><br><span class="line">        <span class="keyword">lo</span> += <span class="number">1</span>                                 # 左指针前进<span class="number">1</span></span><br><span class="line">    &lt;<span class="keyword">do</span>...&gt;                                     # 任务<span class="number">1</span></span><br><span class="line">    <span class="keyword">hi</span> += <span class="number">1</span>                                     # 右指针前进<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="Sliding-Window"><a href="#Sliding-Window" class="headerlink" title="Sliding Window"></a>Sliding Window</h3><p>参考带佬的滑窗模板版本：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def minWindow(self, s, t):</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        :<span class="built_in">type</span> <span class="variable">s:</span> str</span><br><span class="line">        :<span class="built_in">type</span> <span class="variable">t:</span> str</span><br><span class="line">        :rtype: str</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        ans = <span class="string">''</span></span><br><span class="line">        minLen = float(<span class="string">'Inf'</span>)</span><br><span class="line">        <span class="keyword">lo</span>, <span class="keyword">hi</span> = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        window = Counter()</span><br><span class="line">        t = Counter(t)</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">hi</span> &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            # 入窗</span><br><span class="line">            window[s[<span class="keyword">hi</span>]] += <span class="number">1</span></span><br><span class="line">            # 维护窗口大小</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">all</span>(<span class="keyword">map</span>(lambda <span class="keyword">x</span>: window[<span class="keyword">x</span>] &gt;= t[<span class="keyword">x</span>], t.<span class="built_in">keys</span>())):</span><br><span class="line">                # 筛选符合条件的最短长度</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">hi</span> - <span class="keyword">lo</span> + <span class="number">1</span> &lt; minLen:</span><br><span class="line">                    ans = s[<span class="keyword">lo</span>:<span class="keyword">hi</span>+<span class="number">1</span>]</span><br><span class="line">                    minLen = <span class="keyword">hi</span> - <span class="keyword">lo</span> + <span class="number">1</span></span><br><span class="line">                # 出窗</span><br><span class="line">                window[s[<span class="keyword">lo</span>]] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">lo</span> += <span class="number">1</span></span><br><span class="line">            # 窗口右端右移</span><br><span class="line">            <span class="keyword">hi</span> += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p><h3 id="最后一个用例超时版本"><a href="#最后一个用例超时版本" class="headerlink" title="最后一个用例超时版本"></a>最后一个用例超时版本</h3><p>感觉思路很清晰，一写就超时 妈的<br>感觉可以在时间复杂度上得到很大的优化，比如统计信息等等。for 循环太多了</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">import <span class="keyword">copy</span></span><br><span class="line">class Solution(object):</span><br><span class="line">    def judge(self,Dict,tList):</span><br><span class="line">        <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="built_in">len</span>(tList)):</span><br><span class="line">            <span class="keyword">if</span> Dict[tList[i]] &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> False</span><br><span class="line">        <span class="keyword">return</span> True</span><br><span class="line"></span><br><span class="line">    def minWindow(self, s, t):</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        :<span class="built_in">type</span> <span class="variable">s:</span> str</span><br><span class="line">        :<span class="built_in">type</span> <span class="variable">t:</span> str</span><br><span class="line">        :rtype: str</span><br><span class="line">        </span><br><span class="line">            核心思想:</span><br><span class="line">                    采用双指针记录滑窗头尾位置</span><br><span class="line">                    从头滑窗，如果t.<span class="keyword">split</span>的每个字符串都在，则记录这个字符串</span><br><span class="line">                    剪枝：如果滑窗的长度长于当前最短的长度则直接跳转到下一个属于t字母的位置重新进行滑窗</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(t) &gt; <span class="built_in">len</span>(s):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        <span class="keyword">if</span> s == <span class="variable">t:</span></span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> s == <span class="variable">t:</span></span><br><span class="line">                <span class="keyword">return</span> s</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        windowStart = <span class="number">0</span></span><br><span class="line">        windowEnd = <span class="number">0</span></span><br><span class="line">        minLen = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">res</span> = <span class="string">''</span></span><br><span class="line">        tList = <span class="keyword">list</span>(t)</span><br><span class="line">        # 生成每个字母的个数统计字典，然后后面用减法</span><br><span class="line">        zeroList = [<span class="number">0</span> <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="built_in">len</span>(tList))]</span><br><span class="line">        staticDict = dict(zip(tList,zeroList)) # 创建查询字典 记录每个单词的个数</span><br><span class="line">        <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="built_in">len</span>(t)):</span><br><span class="line">            staticDict[t[i]] += <span class="number">1</span></span><br><span class="line">        searchDict = <span class="keyword">copy</span>.<span class="keyword">copy</span>(staticDict) # 创建查询字典，用于下面减法</span><br><span class="line">        #print(searchDict)</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(s) - windowStart &gt;= <span class="built_in">len</span>(t): # 如果可滑窗的范围小于t的长度，则结束循环</span><br><span class="line">            <span class="keyword">if</span> windowEnd == <span class="built_in">len</span>(s): # 越界直接结束</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            temp = s[windowEnd]</span><br><span class="line">            #print(temp)</span><br><span class="line">            <span class="keyword">if</span> s[windowEnd] in tLis<span class="variable">t:</span></span><br><span class="line">                searchDict[s[windowEnd]] -= <span class="number">1</span>  # 记录值＋<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> self.judge(searchDict,tList): # 判断是否所有记录值均不为<span class="number">0</span></span><br><span class="line">                    # 记录满足条件的更短字符串</span><br><span class="line">                    <span class="keyword">if</span> minLen &gt;= windowEnd - windowStart + <span class="number">1</span>:</span><br><span class="line">                        minLen = windowEnd - windowStart + <span class="number">1</span></span><br><span class="line">                        <span class="keyword">res</span> = s[windowStar<span class="variable">t:windowEnd</span>+<span class="number">1</span>]</span><br><span class="line">                    searchDict = <span class="keyword">copy</span>.<span class="keyword">copy</span>(staticDict) # 重置</span><br><span class="line">                    flag = True</span><br><span class="line">                    # 直接从下一个位于t中的字母开始</span><br><span class="line">                    <span class="keyword">for</span> i in <span class="built_in">range</span>(windowStart+<span class="number">1</span>,<span class="built_in">len</span>(s)):</span><br><span class="line">                        <span class="keyword">if</span> s[i] in tLis<span class="variable">t:</span></span><br><span class="line">                            windowStart = i</span><br><span class="line">                            flag = False</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">if</span> fla<span class="variable">g:</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    # 新的开始 重置windowEnd</span><br><span class="line">                    windowEnd = windowStart</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    windowEnd += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                windowEnd += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">res</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    <span class="keyword">print</span>(s.minWindow(s = <span class="string">"abc"</span>, t = <span class="string">"ac"</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LeetCode第七十六题—最小覆盖子串&quot;&gt;&lt;a href=&quot;#LeetCode第七十六题—最小覆盖子串&quot; class=&quot;headerlink&quot; title=&quot;LeetCode第七十六题—最小覆盖子串&quot;&gt;&lt;/a&gt;LeetCode第七十六题—最小覆盖子串&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
</feed>
