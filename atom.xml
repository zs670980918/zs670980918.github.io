<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>StriveZs的博客</title>
  
  <subtitle>Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="www.strivezs.com/"/>
  <updated>2021-05-13T11:05:48.299Z</updated>
  <id>www.strivezs.com/</id>
  
  <author>
    <name>StriveZs</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode No.107</title>
    <link href="www.strivezs.com/2021/05/13/LeetCode%E7%AC%AC107%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/13/LeetCode%E7%AC%AC107%E9%A2%98/</id>
    <published>2021-05-13T11:05:48.299Z</published>
    <updated>2021-05-13T11:05:48.299Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第107题—二叉树的层序遍历II</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定一个二叉树，返回其节点值自底向上的层序遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">给定二叉树 [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">15</span>,<span class="number">7</span>],</span><br><span class="line"></span><br><span class="line">    <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">9</span>  <span class="number">20</span></span><br><span class="line">    /  \</span><br><span class="line">   <span class="number">15</span>   <span class="number">7</span></span><br><span class="line">返回其自底向上的层序遍历为：</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [<span class="number">15</span>,<span class="number">7</span>],</span><br><span class="line">  [<span class="number">9</span>,<span class="number">20</span>],</span><br><span class="line">  [<span class="number">3</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><p>魔改102题就好了。直接reverse.<br>执行用时：40 ms, 在所有 Python3 提交中击败了76.52%的用户内存消耗：15.7 MB, 在所有 Python3 提交中击败了6.45%的用户</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, val=<span class="number">0</span>, left=None, right=None)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.val = val</span><br><span class="line">        <span class="keyword">self</span>.left = left</span><br><span class="line">        <span class="keyword">self</span>.right = right</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="title">object</span>):</span></span><br><span class="line">    res = dict()  <span class="comment"># 用字典存储对应深度的结果</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forwardSearch</span><span class="params">(<span class="keyword">self</span>, root, depth)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">if</span> root != <span class="symbol">None:</span></span><br><span class="line">            <span class="keyword">if</span> depth <span class="keyword">not</span> <span class="keyword">in</span> <span class="keyword">self</span>.res.keys()<span class="symbol">:</span></span><br><span class="line">                <span class="keyword">self</span>.res[depth] = []</span><br><span class="line">            <span class="keyword">self</span>.res[depth].append(root.val)</span><br><span class="line">            <span class="keyword">self</span>.forwardSearch(root.left, depth + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">self</span>.forwardSearch(root.right, depth + <span class="number">1</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrderBottom</span><span class="params">(<span class="keyword">self</span>, root)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">            延续二叉树的层序遍历第一期的思想</span></span><br><span class="line"><span class="string">            只不过是将最终得到的结果reverse就可以了。</span></span><br><span class="line"><span class="string">            同样是采用前序遍历，按照深度进行划分，只不过是从最大深度开始存储就可以了</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        <span class="keyword">self</span>.forwardSearch(root, <span class="number">1</span>)</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">self</span>.dic = dict()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">self</span>.res.keys()<span class="symbol">:</span></span><br><span class="line">            result.append(<span class="keyword">self</span>.res[i])</span><br><span class="line">        <span class="keyword">return</span> result[<span class="symbol">:</span><span class="symbol">:-</span><span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name_<span class="number">_</span> == <span class="string">'__main__'</span><span class="symbol">:</span></span><br><span class="line">    root = TreeNode(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.levelOrderBottom(root))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第107题—二叉树的层序遍历II&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.106</title>
    <link href="www.strivezs.com/2021/05/12/LeetCode%E7%AC%AC106%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/12/LeetCode%E7%AC%AC106%E9%A2%98/</id>
    <published>2021-05-12T15:25:25.531Z</published>
    <updated>2021-05-12T15:25:25.531Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第106题—从中序与后序遍历序列构造二叉树</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p><p>注意:<br>你可以假设树中没有重复的元素。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">例如，给出</span><br><span class="line"></span><br><span class="line">中序遍历 inorder = [<span class="number">9</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>]</span><br><span class="line">后序遍历 postorder = [<span class="number">9</span>,<span class="number">15</span>,<span class="number">7</span>,<span class="number">20</span>,<span class="number">3</span>]</span><br><span class="line">返回如下的二叉树：</span><br><span class="line"></span><br><span class="line">    <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">9</span>  <span class="number">20</span></span><br><span class="line">    /  \</span><br><span class="line">   <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><p>我只改了我105题一行代码。其实就是把后序遍历的节点从队尾读取，而对于前序遍历的话则是从队首读取就可以了</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, val=<span class="number">0</span>, left=None, right=None)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.val = val</span><br><span class="line">        <span class="keyword">self</span>.left = left</span><br><span class="line">        <span class="keyword">self</span>.right = right</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">irritationBuildTree</span><span class="params">(<span class="keyword">self</span>,postorder,inorder)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">if</span> len(postorder) == <span class="number">0</span>: <span class="comment"># 则证明没有根节点了</span></span><br><span class="line">            <span class="keyword">return</span> None</span><br><span class="line">        curRoot = postorder.pop() <span class="comment"># 获得当前子树根节点</span></span><br><span class="line">        node = TreeNode(curRoot) <span class="comment"># 生成节点</span></span><br><span class="line">        index = inorder.index(curRoot) <span class="comment"># 获得当前根节点在中序遍历中的位置，左边划分为左子树，右边为右子树</span></span><br><span class="line">        node.left = <span class="keyword">self</span>.irritationBuildTree(postorder[<span class="symbol">:index</span>],inorder[<span class="symbol">:index</span>]) <span class="comment"># 递归构建左子树</span></span><br><span class="line">        node.right = <span class="keyword">self</span>.irritationBuildTree(postorder[<span class="symbol">index:</span>],inorder[index+<span class="number">1</span><span class="symbol">:</span>]) <span class="comment"># 递归构建右子树</span></span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(<span class="keyword">self</span>, inorder, postorder)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        :type inorder: List[int]</span></span><br><span class="line"><span class="string">        :type postorder: List[int]</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">            类似上一道题，只不过从前序遍历变成了后序遍历</span></span><br><span class="line"><span class="string">            后序遍历的话，最后的元素为当前子树的根节点，其他的同理</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.irritationBuildTree(postorder, inorder)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第106题—从中序与后序遍历序列构造二叉树&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和F
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.105</title>
    <link href="www.strivezs.com/2021/05/11/LeetCode%E7%AC%AC105%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/11/LeetCode%E7%AC%AC105%E9%A2%98/</id>
    <published>2021-05-11T04:17:56.002Z</published>
    <updated>2021-05-11T04:17:56.002Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第105题—从前序与中序遍历序列构造二叉树</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>根据一棵树的前序遍历与中序遍历构造二叉树。</p><p>注意:<br>你可以假设树中没有重复的元素。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">例如，给出</span><br><span class="line"></span><br><span class="line">前序遍历 preorder = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">中序遍历 inorder = [<span class="number">9</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>]</span><br><span class="line">返回如下的二叉树：</span><br><span class="line"></span><br><span class="line">    <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">9</span>  <span class="number">20</span></span><br><span class="line">    /  \</span><br><span class="line">   <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, val=<span class="number">0</span>, left=None, right=None)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.val = val</span><br><span class="line">        <span class="keyword">self</span>.left = left</span><br><span class="line">        <span class="keyword">self</span>.right = right</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">irritationBuildTree</span><span class="params">(<span class="keyword">self</span>,preorder,inorder)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">if</span> len(preorder) == <span class="number">0</span>: <span class="comment"># 则证明没有根节点了</span></span><br><span class="line">            <span class="keyword">return</span> None</span><br><span class="line">        curRoot = preorder.pop(<span class="number">0</span>) <span class="comment"># 获得当前子树根节点</span></span><br><span class="line">        node = TreeNode(curRoot) <span class="comment"># 生成节点</span></span><br><span class="line">        index = inorder.index(curRoot) <span class="comment"># 获得当前根节点在中序遍历中的位置，左边划分为左子树，右边为右子树</span></span><br><span class="line">        node.left = <span class="keyword">self</span>.irritationBuildTree(preorder[<span class="symbol">:index</span>],inorder[<span class="symbol">:index</span>]) <span class="comment"># 递归构建左子树</span></span><br><span class="line">        node.right = <span class="keyword">self</span>.irritationBuildTree(preorder[<span class="symbol">index:</span>],inorder[index+<span class="number">1</span><span class="symbol">:</span>]) <span class="comment"># 递归构建右子树</span></span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(<span class="keyword">self</span>, preorder, inorder)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        :type preorder: List[int]</span></span><br><span class="line"><span class="string">        :type inorder: List[int]</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">            根据前序遍历和中序遍历来确定一颗二叉树</span></span><br><span class="line"><span class="string">            1.确定树的根节点,树根是当前树中所有元素在前序遍历中最先出现的元素。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            2.求解树的子树,找出根节点在中序遍历中的位置，根左边的所有元素就是左子树，</span></span><br><span class="line"><span class="string">            根右边的所有元素就是右子树。若根节点左边或右边为空，则该方向子树为空；</span></span><br><span class="line"><span class="string">            若根节点左边和右边都为空，则根节点已经为叶子节点。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            3.递归求解树,将左子树和右子树分别看成一棵二叉树，重复1、2、3步，直到所有的节点完成定位。</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.irritationBuildTree(preorder,inorder)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name_<span class="number">_</span> == <span class="string">'__main__'</span><span class="symbol">:</span></span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.irritationBuildTree([<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="number">15</span>,<span class="number">7</span>],[<span class="number">9</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>]))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第105题—从前序与中序遍历序列构造二叉树&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和F
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.104</title>
    <link href="www.strivezs.com/2021/05/10/LeetCode%E7%AC%AC104%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/10/LeetCode%E7%AC%AC104%E9%A2%98/</id>
    <published>2021-05-10T10:36:04.737Z</published>
    <updated>2021-05-10T10:36:04.737Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第104题—二叉树的最大深度</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">给定二叉树 [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">15</span>,<span class="number">7</span>]，</span><br><span class="line"></span><br><span class="line">    <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">9</span>  <span class="number">20</span></span><br><span class="line">    /  \</span><br><span class="line">   <span class="number">15</span>   <span class="number">7</span></span><br><span class="line">返回它的最大深度 <span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><p>执行用时：24 ms, 在所有 Python 提交中击败了92.24%的用户内存消耗：15.5 MB, 在所有 Python 提交中击败了85.16%的用户 深度遍历DFS，求深度</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, val=<span class="number">0</span>, left=None, right=None)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.val = val</span><br><span class="line">        <span class="keyword">self</span>.left = left</span><br><span class="line">        <span class="keyword">self</span>.right = right</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="title">object</span>):</span></span><br><span class="line">    maxdepth = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs_depth</span><span class="params">(<span class="keyword">self</span>,node,depth)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">if</span> node != <span class="symbol">None:</span></span><br><span class="line">            <span class="keyword">self</span>.dfs_depth(node.left,depth+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> depth &gt; <span class="keyword">self</span>.<span class="symbol">maxdepth:</span></span><br><span class="line">                <span class="keyword">self</span>.maxdepth = depth</span><br><span class="line">            <span class="keyword">self</span>.dfs_depth(node.right,depth+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(<span class="keyword">self</span>, root)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">            dfs遍历最大深度，效果最差</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        <span class="keyword">self</span>.dfs_depth(root,<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.maxdepth</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第104题—二叉树的最大深度&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)&lt;
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.103</title>
    <link href="www.strivezs.com/2021/05/09/LeetCode%E7%AC%AC103%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/09/LeetCode%E7%AC%AC103%E9%A2%98/</id>
    <published>2021-05-09T04:59:02.452Z</published>
    <updated>2021-05-09T04:59:02.452Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第103题—二叉树的锯齿形层序遍历</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">给定二叉树 [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">15</span>,<span class="number">7</span>],</span><br><span class="line"></span><br><span class="line">    <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">9</span>  <span class="number">20</span></span><br><span class="line">    /  \</span><br><span class="line">   <span class="number">15</span>   <span class="number">7</span></span><br><span class="line">返回锯齿形层序遍历如下：</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [<span class="number">3</span>],</span><br><span class="line">  [<span class="number">20</span>,<span class="number">9</span>],</span><br><span class="line">  [<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><p>比较懒直接把上一题的结果，拿过来，将偶数层逆序就好了。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, val=<span class="number">0</span>, left=None, right=None)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.val = val</span><br><span class="line">        <span class="keyword">self</span>.left = left</span><br><span class="line">        <span class="keyword">self</span>.right = right</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="title">object</span>):</span></span><br><span class="line">    res = dict()  <span class="comment"># 用字典存储对应深度的结果</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forwardSearch</span><span class="params">(<span class="keyword">self</span>, root, depth)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">if</span> root != <span class="symbol">None:</span></span><br><span class="line">            <span class="keyword">if</span> depth <span class="keyword">not</span> <span class="keyword">in</span> <span class="keyword">self</span>.res.keys()<span class="symbol">:</span></span><br><span class="line">                <span class="keyword">self</span>.res[depth] = []</span><br><span class="line">            <span class="keyword">self</span>.res[depth].append(root.val)</span><br><span class="line">            <span class="keyword">self</span>.forwardSearch(root.left, depth + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">self</span>.forwardSearch(root.right, depth + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">zigzagLevelOrder</span><span class="params">(<span class="keyword">self</span>, root)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">            类似上一题的方法，先得到层序的结果</span></span><br><span class="line"><span class="string">            然后将深度为偶数的结果倒序就好了</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        <span class="keyword">self</span>.res = dict()</span><br><span class="line">        <span class="keyword">self</span>.forwardSearch(root, <span class="number">1</span>)</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">self</span>.res.keys()<span class="symbol">:</span></span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span><span class="symbol">:</span></span><br><span class="line">                result.append(<span class="keyword">self</span>.res[i][<span class="symbol">:</span><span class="symbol">:-</span><span class="number">1</span>])</span><br><span class="line">            <span class="symbol">else:</span></span><br><span class="line">                result.append(<span class="keyword">self</span>.res[i])</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name_<span class="number">_</span> == <span class="string">'__main__'</span><span class="symbol">:</span></span><br><span class="line">    root = TreeNode(<span class="number">1</span>)</span><br><span class="line">    node1 = TreeNode(<span class="number">2</span>)</span><br><span class="line">    node2 = TreeNode(<span class="number">3</span>)</span><br><span class="line">    node3 = TreeNode(<span class="number">4</span>)</span><br><span class="line">    node4 = TreeNode(<span class="number">5</span>)</span><br><span class="line">    root.left = node1</span><br><span class="line">    root.right = node2</span><br><span class="line">    node1.left = node3</span><br><span class="line">    node2.right = node4</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.zigzagLevelOrder(root))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第103题—二叉树的锯齿形层序遍历&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork 
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.102</title>
    <link href="www.strivezs.com/2021/05/08/LeetCode%E7%AC%AC102%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/08/LeetCode%E7%AC%AC102%E9%A2%98/</id>
    <published>2021-05-08T07:58:17.809Z</published>
    <updated>2021-05-08T07:58:17.809Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第102题—二叉树的层序遍历</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">二叉树：[<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">15</span>,<span class="number">7</span>],</span><br><span class="line"></span><br><span class="line">    <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">9</span>  <span class="number">20</span></span><br><span class="line">    /  \</span><br><span class="line">   <span class="number">15</span>   <span class="number">7</span></span><br><span class="line">返回其层序遍历结果：</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [<span class="number">3</span>],</span><br><span class="line">  [<span class="number">9</span>,<span class="number">20</span>],</span><br><span class="line">  [<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, val=<span class="number">0</span>, left=None, right=None)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.val = val</span><br><span class="line">        <span class="keyword">self</span>.left = left</span><br><span class="line">        <span class="keyword">self</span>.right = right</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="title">object</span>):</span></span><br><span class="line">    res = dict() <span class="comment"># 用字典存储对应深度的结果</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forwardSearch</span><span class="params">(<span class="keyword">self</span>,root,depth)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">if</span> root != <span class="symbol">None:</span></span><br><span class="line">            <span class="keyword">if</span> depth <span class="keyword">not</span> <span class="keyword">in</span> <span class="keyword">self</span>.res.keys()<span class="symbol">:</span></span><br><span class="line">                <span class="keyword">self</span>.res[depth] = []</span><br><span class="line">            <span class="keyword">self</span>.res[depth].append(root.val)</span><br><span class="line">            <span class="keyword">self</span>.forwardSearch(root.left,depth+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">self</span>.forwardSearch(root.right,depth+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(<span class="keyword">self</span>, root)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">            采用前序遍历，这样的话会先访问根节点，再访问左节点，最后再访问右节点</span></span><br><span class="line"><span class="string">            对于例题中的例子:</span></span><br><span class="line"><span class="string">                    3</span></span><br><span class="line"><span class="string">                   / \</span></span><br><span class="line"><span class="string">                  9  20</span></span><br><span class="line"><span class="string">                    /  \</span></span><br><span class="line"><span class="string">                   15   7</span></span><br><span class="line"><span class="string">        前序遍历的结果正好就是 3 9 20 15 7</span></span><br><span class="line"><span class="string">        只需要添加depth就可以区分深度了</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        <span class="keyword">self</span>.forwardSearch(root,<span class="number">1</span>)</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">self</span>.res.keys()<span class="symbol">:</span></span><br><span class="line">            result.append(<span class="keyword">self</span>.res[i])</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name_<span class="number">_</span> == <span class="string">'__main__'</span><span class="symbol">:</span></span><br><span class="line">    root = TreeNode(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.levelOrder(root))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第102题—二叉树的层序遍历&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)&lt;
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.101</title>
    <link href="www.strivezs.com/2021/05/07/LeetCode%E7%AC%AC101%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/07/LeetCode%E7%AC%AC101%E9%A2%98/</id>
    <published>2021-05-07T09:20:44.668Z</published>
    <updated>2021-05-07T09:20:44.668Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第101题—对称二叉树</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定一个二叉树，检查它是否是镜像对称的。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">例如，二叉树 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">3</span>] 是对称的。</span><br><span class="line"></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">2</span></span><br><span class="line"> / \ / \</span><br><span class="line"><span class="number">3</span>  <span class="number">4</span> <span class="number">4</span>  <span class="number">3</span></span><br><span class="line"> </span><br><span class="line">但是下面这个 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="literal">null</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="number">3</span>] 则不是镜像对称的:</span><br><span class="line"></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">2</span></span><br><span class="line">   \   \</span><br><span class="line">   <span class="number">3</span>    <span class="number">3</span></span><br><span class="line"> </span><br><span class="line">进阶：</span><br><span class="line"></span><br><span class="line">你可以运用递归和迭代两种方法解决这个问题吗？</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><p>一遍AC，思路很简单。就是效率不行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMirror</span><span class="params">(self,node1,node2)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> node1 != <span class="literal">None</span> <span class="keyword">and</span> node2 == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> node1 == <span class="literal">None</span> <span class="keyword">and</span> node2 != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> node1 != <span class="literal">None</span> <span class="keyword">and</span> node2 != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> self.isMirror(node1.left, node2.right) == <span class="literal">False</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> node1.val != node2.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> self.isMirror(node1.right,node2.left) == <span class="literal">False</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">            方法①：直接中序遍历，将得到的结果，如果得到序列是对称的则证明是镜像对称的 这种方法太蠢了</span></span><br><span class="line"><span class="string">            方法②：直接使用递归一边遍历左子树，一边遍历右子树，左边采用中序遍历进行，右边的话采用镜像中序遍历的方法进行遍历即可</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.isMirror(root,root)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第101题—对称二叉树&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中变量、作用域和内存问题</title>
    <link href="www.strivezs.com/2021/05/06/JavaScript%E4%B8%AD%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/06/JavaScript%E4%B8%AD%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/</id>
    <published>2021-05-06T08:01:38.571Z</published>
    <updated>2021-05-06T08:01:38.571Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript学习笔记。  Github同步链接: <a href="https://github.com/zs670980918/JavaScript_Study">click here</a></p><h1>变量、作用域和内存问题</h1><h2 id="基本类型和引用类型的值"><a class="header-anchor" href="#基本类型和引用类型的值">¶</a>基本类型和引用类型的值</h2><p>JavaScript变量可能包含两种不同的数据类型的值：基本类型值和引用类型值。</p><ul><li>基本类型值指的是简单的数据段</li><li>引用类型值指的是那些可能由多个值构成的对象</li></ul><p>引用类型的值是保存在内存中的对象。JavaScript不允许直接访问内存中的位置，即不能直接操作对象的内存空间。</p><h3 id="动态的属性"><a class="header-anchor" href="#动态的属性">¶</a>动态的属性</h3><p>定义基本类型值和引用类型值的方法是类似的：创建一个变量并为该变量赋值。但是当这个值保存到变量中以后，对不同类型值可以执行的操作是不同的。对于引用类型的值，我们可以为其添加属性和方法，也可以改变和删除其属性和方法，如下例子:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var person = <span class="built_in">new</span> <span class="keyword">Object</span>();</span><br><span class="line">person.name = "Niko";</span><br><span class="line"><span class="keyword">alter</span>(person.name);</span><br></pre></td></tr></table></figure><p>以上代码创建了一个对象并将其保存在了变量person中，然后我们为该对象添加了一个名为name的属性，并将字符串“Niko”赋给了它。这个person就属于引用类型。而对于基本类型则无法添加属性，比如:</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var <span class="built_in">name</span> = <span class="string">"Niko"</span>;</span><br><span class="line"><span class="built_in">name</span>.age = <span class="number">13</span>; <span class="comment">// 会报错</span></span><br></pre></td></tr></table></figure><p>引用类型一般指的是对象，基本类型值的是之前提到的基本数据类型</p><h3 id="复制变量值"><a class="header-anchor" href="#复制变量值">¶</a>复制变量值</h3><p>除了保存的方式不同之外，在从一个变量向另一个变量复制基本类型值和引用类型时，也存在不同。如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制到新的变量分配的位置上。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var <span class="symbol">num1</span> = <span class="number">5</span>;</span><br><span class="line">var <span class="symbol">num2</span> = <span class="symbol">num1</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/zyp521/upload_image/raw/master/24RzR1.png" alt="figure.1"></p><p>当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。复制操作结束后，两个变量实际上将引用同一个对象，因此，<strong>改变其中一个变量，就会影响另一个变量</strong>。</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/zmvJyy.png" alt="figure.2"></p><h3 id="传递参数"><a class="header-anchor" href="#传递参数">¶</a>传递参数</h3><p>JavaScript中所有的函数的参数都是按值传递的。即把函数外部的值赋值给函数内部的参数，就和把值从一个变量复制到另一个变量一样。基本类型值的传递如同基本类型变量的复制，引用类型的值，则如同引用类型变量的值一样。</p><h3 id="检测类型"><a class="header-anchor" href="#检测类型">¶</a>检测类型</h3><p>要检测一个变量是不是基本数据类型，使用typeof操作符是最佳的工作。如果变量的值是一个对象或null，则typeof操作符会如下返回object：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">"123"</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">22</span>;</span><br><span class="line"><span class="keyword">var</span> u;</span><br><span class="line"><span class="keyword">var</span> n = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span>(s); <span class="comment">// string</span></span><br><span class="line"><span class="keyword">typeof</span>(b); <span class="comment">// number</span></span><br><span class="line"><span class="keyword">typeof</span>(i); <span class="comment">// boolean</span></span><br><span class="line"><span class="keyword">typeof</span>(u); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">typeof</span>(n); <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span>(m); <span class="comment">// object</span></span><br></pre></td></tr></table></figure><p>在检测基本数据类型时，typeof十分好用，但是在检测引用类型的值时，这个操作符用处则不大。为了知道某个值是什么类型的对象，我们可以使用instanceof操作符：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">result = variable instanceof <span class="function"><span class="keyword">constructor</span>;</span></span><br><span class="line"></span><br><span class="line">person instanceof <span class="keyword">Object</span>; <span class="comment">//变量person是Object类型的对象吗</span></span><br><span class="line">colors instanceof <span class="keyword">Array</span>; <span class="comment">//变量colors是Array吗？</span></span><br></pre></td></tr></table></figure><p>根据规定，所有引用类型的值都是Object的实例。因此，在检测一个引用类型值和Object构造函数时，instanceof操作符始终会返回True，如果用instanceof检测基本类型的值，则始终会返回false。因为基本类型不是对象。</p><h2 id="执行环境及作用域"><a class="header-anchor" href="#执行环境及作用域">¶</a>执行环境及作用域</h2><p>执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。<br>全局执行环境是最外围的一个执行环境。根据JavaScript实现所在的宿主环境不同，表示执行环境的对象也不一样。在Web浏览器中，全局执行环境是window对象，因此所有全局变量和函数都是作为window对象的属性和方法创建的。某个执行环境中的所有代码执行完之后，该环境会被销毁，保存在其中的所有变量和函数定义也会随之销毁。</p><p>当代码在一个环境中执行时，会创建变量对象的一个作用域链。<strong>作用域链</strong>的用途是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。标识符解析是沿着作用域链一级一级地搜索标识符的过程，搜索过程始终从作用域链的前段开始，然后逐级地向后回溯，直到找到标识符位为止。</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">color</span> = <span class="string">"blue"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> temp = <span class="string">"yellow"</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">color</span> == <span class="string">"blue"</span>)&#123;</span><br><span class="line">        <span class="built_in">color</span> = <span class="string">"red"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title">else</span>&#123;</span><br><span class="line">        <span class="built_in">color</span> = <span class="string">"blue"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">changeColor();</span><br></pre></td></tr></table></figure><p>上述代码中changColor()的作用域链包含两个对象：他自己的变量对象(temp)和全局环境的变量对象(color)。可以在函数内部访问全局变量color。<br>同理看下面代码：</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">color</span> = <span class="string">"blue"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> temp = <span class="string">"yellow"</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">color</span> == <span class="string">"blue"</span>)&#123;</span><br><span class="line">        <span class="built_in">color</span> = <span class="string">"red"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title">else</span>&#123;</span><br><span class="line">        <span class="built_in">color</span> = <span class="string">"blue"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">changeColor();</span><br><span class="line">alter(<span class="built_in">color</span>); <span class="comment">// 显示red</span></span><br><span class="line">alter(temp); <span class="comment">// 会报错</span></span><br></pre></td></tr></table></figure><p>这里temp为changColor的局部变量，只可以在函数的局部环境中访问，而不能在全局环境中访问，而color则是全局变量，既可以在全局环境中访问，又可以在局部环境中访问。</p><h3 id="延长作用域链"><a class="header-anchor" href="#延长作用域链">¶</a>延长作用域链</h3><p>执行环境类型总共有两种——全局和局部，但是还是有其他办法来延长作用于链。当执行流进入下列任何一个语句时，作用域链就会得到加长：</p><ul><li>try-catch语句的catch块</li><li>with语句</li></ul><p>这两个语句都会在作用域链的前端添加一个变量对象。对with语句来说，会将指定的对象添加到作用域链中，对catch语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildUrl</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> qs = <span class="string">"?debuge=true"</span>;</span><br><span class="line">    <span class="keyword">with</span>(location)&#123;</span><br><span class="line">        <span class="keyword">var</span> <span class="built_in">url</span> = href + qs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">url</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于with语句内部，定义了一个url变量，这个url就会成为函数执行环境的一部分，所有可以作为函数的值被返回。</p><h3 id="没有块级作用域"><a class="header-anchor" href="#没有块级作用域">¶</a>没有块级作用域</h3><p>JavaScript没有块级作用域，比如下面代码:</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="built_in">var</span> <span class="built_in">color</span> = <span class="string">"blue"</span>;</span><br><span class="line">&#125;</span><br><span class="line">alter(<span class="built_in">color</span>);</span><br></pre></td></tr></table></figure><p>在C++、C和Java中，color会在if语句执行完毕后被销毁。但是JavaScript中，if语句中的变量声明会将变量添加到当前的执行环境（上文的代码指的是全局环境中）。在使用for语句时一定要记住这一点差异。因为要定义i:</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (<span class="name">var</span> i=0<span class="comment">; i&lt;10; i++)&#123;</span></span><br><span class="line">    doSomething(<span class="name">i</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">alter(<span class="name">i</span>)<span class="comment">; // i=10</span></span><br></pre></td></tr></table></figure><p>这里i在for中被声明后，当退出for的块之后，这个变量i还是会存在于外部的执行环境中的。这里适合C++、Java等语言不同的地方。</p><h4 id="声明变量"><a class="header-anchor" href="#声明变量">¶</a>声明变量</h4><p>使用var声明的变量会自动被添加到最接近的环境中，在函数内部，最接近的环境就是函数的局部环境。在with语句中，最接近的环境是函数环境。如果初始化变量时没有使用var声明，该变量会自动被添加到全局环境。</p><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(num1,num2)</span>&#123;</span></span><br><span class="line">    var <span class="built_in">sum</span> = num1 + num2;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>;</span><br><span class="line">&#125;</span><br><span class="line">var result = add(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sum</span>; <span class="comment">// 会报错，因为sum在函数环境中</span></span><br></pre></td></tr></table></figure><p>但是如何在函数中sum省略了var声明，则sum会被自动添加到全局环境中。但是不建议这样使用！</p><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(num1,num2)</span>&#123;</span></span><br><span class="line">    <span class="built_in">sum</span> = num1 + num2; <span class="comment">// 声明未使用var，sum被添加到全局环境中</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>;</span><br><span class="line">&#125;</span><br><span class="line">var result = add(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sum</span>; <span class="comment">// 30</span></span><br></pre></td></tr></table></figure><p>这种声明方式不被推荐使用，应该按照严格的方式来声明变量。</p><h4 id="查询标识符"><a class="header-anchor" href="#查询标识符">¶</a>查询标识符</h4><p>当在某个环境中为了读取或写入而引用一个标识符时，必须通过搜索来确定该标识符实际代表什么。搜索过程从作用域链的前段开始，向上逐级查询与给定名字匹配的标识符。如果在局部环境中找到了该标识符，搜索过程停止，变量就绪，如果在局部环境中没有找到变量名，则继续沿着作用域链向上搜索。搜索过程将会一直追溯到全局环境的变量对象。如果在全局环境中也没有找到这个变量，则意味着该变量未声明。（先找局部环境，局部环境没有再找全局环境）</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">color</span> = <span class="string">"blue"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">color</span>;</span><br><span class="line">&#125;</span><br><span class="line">alter(getColor()); <span class="comment">// blue</span></span><br></pre></td></tr></table></figure><p>上述过程，因为函数环境中没有blue，因此搜索了全局环境中的color。</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">color</span> = <span class="string">"blue"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">color</span> = <span class="string">"red"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">color</span>;</span><br><span class="line">&#125;</span><br><span class="line">alter(getColor()); <span class="comment">// red</span></span><br></pre></td></tr></table></figure><p>上述过程，因为函数局部环境中有red，因此不需要在搜索全局环境了。</p><h2 id="垃圾收集"><a class="header-anchor" href="#垃圾收集">¶</a>垃圾收集</h2><p>JavaScript具有自动垃圾收集机制，即执行环境会负责管理代码执行过程中使用的内存。垃圾收集机制的原理：找出那些不再继续使用的变量，然后释放其占用的内存。因此垃圾收集机制会按照固定的时间间隔周期性的执行操作。</p><h3 id="标记清除"><a class="header-anchor" href="#标记清除">¶</a>标记清除</h3><p>JavaScript中最常用的垃圾收集方式是标记清除。当环境进入环境时，就将这个变量标记为进入环境。从逻辑上讲，永远不能释放进入环境的变量所占的内存，因为执行流可能要用到它们，当变量离开环境时，则将其标记为离开环境。<br>可以使用任何方法来标记变量，垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记，然后，他们会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，最后垃圾收集器完成内存清楚工作，销毁那些带有标记的值并且回收他们所占用的内存空间。</p><p>目前主流的浏览器都是采用这种垃圾收集策略的。</p><h3 id="引用计数"><a class="header-anchor" href="#引用计数">¶</a>引用计数</h3><p>另一种不太常见的垃圾收集策略叫做引用计数。引用技术的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。同样对于其他的变量也是类似的加1。而如果包含对这个值引用变量又取得了另外一个值，则这个值的引用次数就减1.当这个值的引用次数变成0之后，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。</p><h3 id="性能问题"><a class="header-anchor" href="#性能问题">¶</a>性能问题</h3><p>垃圾收集器是周期性运行的，而且如果为变量分配的内存数量很可观，那么回收工作量也是相当大的。在这种情况下，确定垃圾收集的时间间隔是十分重要的。后面JavaScript引擎的垃圾收集例程改变了工作方式：触发垃圾收集的变量分配、字面量和数组元素的临界值被调整为动态修正。</p><h3 id="内存管理"><a class="header-anchor" href="#内存管理">¶</a>内存管理</h3><p>一般来说，出于安全考虑分配给浏览器的内存数量通常要不分配给桌面应用的内存少。目的是防止运行JavaScript的网页耗尽系统全部内存而导致系统崩溃。<br>因此确保占用最少内存可以让页面获得更好地性能，一般来说对于不使用的数据，最好将其设置为null来释放其引用，这个做法叫做解决引用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JavaScript学习笔记。  Github同步链接: &lt;a href=&quot;https://github.com/zs670980918/JavaScript_Study&quot;&gt;click here&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;变量、作用域和内存问题&lt;/h1&gt;
&lt;h2 id=&quot;基本
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="www.strivezs.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="www.strivezs.com/tags/JavaScript/"/>
    
      <category term="LearningNote" scheme="www.strivezs.com/tags/LearningNote/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.100</title>
    <link href="www.strivezs.com/2021/05/06/LeetCode%E7%AC%AC%E4%B8%80%E7%99%BE%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/06/LeetCode%E7%AC%AC%E4%B8%80%E7%99%BE%E9%A2%98/</id>
    <published>2021-05-06T04:35:43.952Z</published>
    <updated>2021-05-06T04:35:43.952Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第一百题—相同的数</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><p><img src="https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg" alt="figure.1"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：p = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], q = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg" alt="figure.2"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">2</span>：</span><br><span class="line">输入：p = [<span class="number">1</span>,<span class="number">2</span>], q = [<span class="number">1</span>,<span class="literal">null</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg" alt="figure.3"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">3</span>：</span><br><span class="line">输入：p = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>], q = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">两棵树上的节点数目都在范围 [<span class="number">0</span>, <span class="number">100</span>] 内</span><br><span class="line"><span class="number">-104</span> &lt;= Node.val &lt;= <span class="number">104</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><p>执行用时：36 ms, 在所有 Python3 提交中击败了84.05%的用户内存消耗：14.9 MB, 在所有 Python3 提交中击败了53.64%的用户. 刷题的第100个，每天都在坚持，希望自己博士毕业能够把所有题刷完。</p><p>代码难得一遍AC</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val=<span class="number">0</span>, left=None, right=None)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">middle_search</span><span class="params">(self,node1,node2)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> node1 == <span class="literal">None</span> <span class="keyword">and</span> node2 == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> node1 == <span class="literal">None</span> <span class="keyword">and</span> node2 != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> node1 != <span class="literal">None</span> <span class="keyword">and</span> node2 == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> self.middle_search(node1.left,node2.left) == <span class="literal">False</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> node1.val != node2.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> self.middle_search(node1.right, node2.right) == <span class="literal">False</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span><span class="params">(self, p, q)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type p: TreeNode</span></span><br><span class="line"><span class="string">        :type q: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">                同时对两个棵树进行先序遍历、中序遍历、后序遍历都可以，执行DFS就行了，然后同时比较结果，</span></span><br><span class="line"><span class="string">            如果存在不同的情况，则返回False</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.middle_search(p,q)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第一百题—相同的数&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.99</title>
    <link href="www.strivezs.com/2021/05/05/LeetCode%E7%AC%AC%E4%B9%9D%E5%8D%81%E4%B9%9D%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/05/LeetCode%E7%AC%AC%E4%B9%9D%E5%8D%81%E4%B9%9D%E9%A2%98/</id>
    <published>2021-05-05T05:01:15.142Z</published>
    <updated>2021-05-05T05:01:15.142Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第九十九题—恢复二叉搜索树</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给你二叉搜索树的根节点 root ，该树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树。</p><p>进阶：使用 O(n) 空间复杂度的解法很容易实现。你能想出一个只使用常数空间的解决方案吗？</p><p><img src="https://assets.leetcode.com/uploads/2020/10/28/recover1.jpg" alt="figure.1"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">1</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">2</span>]</span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">1</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">2</span>]</span><br><span class="line">解释：<span class="number">3</span> 不能是 <span class="number">1</span> 左孩子，因为 <span class="number">3</span> &gt; <span class="number">1</span> 。交换 <span class="number">1</span> 和 <span class="number">3</span> 使二叉搜索树有效。</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2020/10/28/recover2.jpg" alt="figure.2"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">2</span>：</span><br><span class="line">输入：root = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">2</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">3</span>]</span><br><span class="line">解释：<span class="number">2</span> 不能在 <span class="number">3</span> 的右子树中，因为 <span class="number">2</span> &lt; <span class="number">3</span> 。交换 <span class="number">2</span> 和 <span class="number">3</span> 使二叉搜索树有效。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">树上节点的数目在范围 [<span class="number">2</span>, <span class="number">1000</span>] 内</span><br><span class="line"><span class="number">-231</span> &lt;= Node.val &lt;= <span class="number">231</span> - <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line">import sys</span><br><span class="line">import copy</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, val=<span class="number">0</span>, left=None, right=None)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.val = val</span><br><span class="line">        <span class="keyword">self</span>.left = left</span><br><span class="line">        <span class="keyword">self</span>.right = right</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="title">object</span>):</span></span><br><span class="line">    errorNode1 = TreeNode() <span class="comment"># 记录错误节点1</span></span><br><span class="line">    errorNode2 = TreeNode() <span class="comment"># 记录错误节点2</span></span><br><span class="line">    pre = TreeNode(-sys.maxsize) <span class="comment"># 记录前一个值</span></span><br><span class="line">    flag = True</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">middleSearch</span><span class="params">(<span class="keyword">self</span>,node)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">if</span> node == <span class="symbol">None:</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">self</span>.middleSearch(node.left) <span class="comment"># 访问左子树</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.pre.val &gt; node.val <span class="keyword">and</span> <span class="keyword">self</span>.pre.val != -sys.<span class="symbol">maxsize:</span> <span class="comment"># 这里的-sys.maxsize是一个最小值</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">self</span>.<span class="symbol">flag:</span></span><br><span class="line">                <span class="keyword">self</span>.errorNode1 = <span class="keyword">self</span>.pre <span class="comment"># 由于当前节点小于上一个节点，因此记录上一个节点比如：321 应该是记录3</span></span><br><span class="line">                <span class="keyword">self</span>.flag = False</span><br><span class="line">            <span class="keyword">self</span>.errorNode2 = node <span class="comment"># 如321，记录完3之后应该记录1，所以是记录当前node</span></span><br><span class="line">        <span class="keyword">self</span>.pre = node</span><br><span class="line">        <span class="keyword">self</span>.middleSearch(node.right) <span class="comment"># 访问右子树</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recoverTree</span><span class="params">(<span class="keyword">self</span>, root)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">            依然是采用中序遍历，并记录两个错误顺序的点，最后进行交换</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        <span class="keyword">self</span>.middleSearch(root)</span><br><span class="line">        print(<span class="keyword">self</span>.errorNode1.val, <span class="keyword">self</span>.errorNode2.val)</span><br><span class="line">        temp = <span class="keyword">self</span>.errorNode1.val</span><br><span class="line">        <span class="keyword">self</span>.errorNode1.val = <span class="keyword">self</span>.errorNode2.val</span><br><span class="line">        <span class="keyword">self</span>.errorNode2.val = temp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name_<span class="number">_</span> == <span class="string">'__main__'</span><span class="symbol">:</span></span><br><span class="line">    root = TreeNode(<span class="number">5</span>)</span><br><span class="line">    node1 = TreeNode(<span class="number">3</span>)</span><br><span class="line">    node2 = TreeNode(<span class="number">9</span>)</span><br><span class="line">    node3 = TreeNode(-<span class="number">2147483648</span>)</span><br><span class="line">    node4 = TreeNode(<span class="number">2</span>)</span><br><span class="line">    root.left = node1</span><br><span class="line">    root.right = node2</span><br><span class="line">    node1.left = node3</span><br><span class="line">    node1.right = node4</span><br><span class="line">    s = Solution()</span><br><span class="line">    s.recoverTree(root)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第九十九题—恢复二叉搜索树&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)&lt;/
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.98</title>
    <link href="www.strivezs.com/2021/05/04/LeetCode%E7%AC%AC%E4%B9%9D%E5%8D%81%E5%85%AB%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/04/LeetCode%E7%AC%AC%E4%B9%9D%E5%8D%81%E5%85%AB%E9%A2%98/</id>
    <published>2021-05-04T12:19:35.868Z</published>
    <updated>2021-05-04T12:19:35.868Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第九十八题—验证二叉搜索树</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p><p>假设一个二叉搜索树具有如下特征：</p><p>节点的左子树只包含小于当前节点的数。<br>节点的右子树只包含大于当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">    <span class="number">2</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">1</span>   <span class="number">3</span></span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">    <span class="number">5</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">1</span>   <span class="number">4</span></span><br><span class="line">     / \</span><br><span class="line">    <span class="number">3</span>   <span class="number">6</span></span><br><span class="line">输出: <span class="literal">false</span></span><br><span class="line">解释: 输入为: [<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">3</span>,<span class="number">6</span>]。</span><br><span class="line">     根节点的值为 <span class="number">5</span> ，但是其右子节点值为 <span class="number">4</span> 。</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><h3 id="没有AC的版本"><a class="header-anchor" href="#没有AC的版本">¶</a>没有AC的版本</h3><p>虽然没有AC但是我真的没有找到错误！！！！！！！！！！！！因为我写一个一模一样的C++版本就同过了！！！！！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    valList = []</span><br><span class="line">    pre = -sys.maxsize</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">middleSearch</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.middleSearch(node.left)</span><br><span class="line">        self.valList.append(node.val)</span><br><span class="line">        self.middleSearch(node.right)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        题目分析：</span></span><br><span class="line"><span class="string">            二叉搜索树具有如下特征：</span></span><br><span class="line"><span class="string">                节点的左子树只包含小于当前节点的数。</span></span><br><span class="line"><span class="string">                节点的右子树只包含大于当前节点的数。</span></span><br><span class="line"><span class="string">                所有左子树和右子树自身必须也是二叉搜索树</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            采用中序遍历，如果遍历当前的数值比上一次遍历的结果小则返回false，证明不是二叉搜索树</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> root.left == <span class="literal">None</span> <span class="keyword">and</span> root.right == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        self.middleSearch(root)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(self.valList)):</span><br><span class="line">            <span class="keyword">if</span> self.valList[i] &lt;= self.valList[i<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h3 id="AC版本"><a class="header-anchor" href="#AC版本">¶</a>AC版本</h3><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    pre = <span class="params">-sys.maxsize</span></span><br><span class="line">    def <span class="literal">new</span>(<span class="built_in">self</span>,node):</span><br><span class="line">        <span class="keyword">if</span> node != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">self</span>.<span class="literal">new</span>(node.left) == <span class="literal">False</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> node.val &lt;= <span class="built_in">self</span>.pre:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="built_in">self</span>.pre = node.val</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">self</span>.<span class="literal">new</span>(node.right)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    def newVersion(<span class="built_in">self</span>,root):</span><br><span class="line">        <span class="keyword">if</span> root.left == <span class="literal">None</span> <span class="literal">and</span> root.right == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">self</span>.<span class="literal">new</span>(root)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第九十八题—验证二叉搜索树&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)&lt;/
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.97</title>
    <link href="www.strivezs.com/2021/05/03/LeetCode%E7%AC%AC%E4%B9%9D%E5%8D%81%E4%B8%83%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/03/LeetCode%E7%AC%AC%E4%B9%9D%E5%8D%81%E4%B8%83%E9%A2%98/</id>
    <published>2021-05-03T14:05:43.371Z</published>
    <updated>2021-05-03T14:05:43.371Z</updated>
    
    <content type="html"><![CDATA[<p>五一出去旅游了，鸽了几天，回来接着更新塞。</p><h1>LeetCode第九十七题—交错字符串</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定三个字符串 s1、s2、s3，请你帮忙验证 s3 是否是由 s1 和 s2 交错 组成的。</p><p>两个字符串 s 和 t 交错 的定义与过程如下，其中每个字符串都会被分割成若干 非空 子字符串：</p><p>s = s1 + s2 + … + sn<br>t = t1 + t2 + … + tm<br>|n - m| &lt;= 1<br>交错 是 s1 + t1 + s2 + t2 + s3 + t3 + … 或者 t1 + s1 + t2 + s2 + t3 + s3 + …<br>提示：a + b 意味着字符串 a 和 b 连接。</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/EbJwpE.jpg" alt="figure.1"></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：<span class="built_in">s1</span> = <span class="string">"aabcc"</span>, <span class="built_in">s2</span> = <span class="string">"dbbca"</span>, <span class="built_in">s3</span> = <span class="string">"aadbbcbcac"</span></span><br><span class="line">输出：true</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：<span class="built_in">s1</span> = <span class="string">"aabcc"</span>, <span class="built_in">s2</span> = <span class="string">"dbbca"</span>, <span class="built_in">s3</span> = <span class="string">"aadbbbaccc"</span></span><br><span class="line">输出：false</span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：<span class="built_in">s1</span> = <span class="string">""</span>, <span class="built_in">s2</span> = <span class="string">""</span>, <span class="built_in">s3</span> = <span class="string">""</span></span><br><span class="line">输出：true</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> &lt;= <span class="built_in">s1</span>.length, <span class="built_in">s2</span>.length &lt;= <span class="number">100</span></span><br><span class="line"><span class="number">0</span> &lt;= <span class="built_in">s3</span>.length &lt;= <span class="number">200</span></span><br><span class="line"><span class="built_in">s1</span>、<span class="built_in">s2</span>、和 <span class="built_in">s3</span> 都由小写英文字母组成</span><br></pre></td></tr></table></figure><h2 id="核心思想"><a class="header-anchor" href="#核心思想">¶</a>核心思想</h2><p>我太菜了，真想不出来。参考大佬的作答。</p><p>看成是一个寻找路径的问题。采用动态规划解决,如下图所示:</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/gumBAx.jpg" alt="figure.2"></p><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def isInterleave(self, s1, s2, s3):</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        :<span class="built_in">type</span> s1: str</span><br><span class="line">        :<span class="built_in">type</span> s2: str</span><br><span class="line">        :<span class="built_in">type</span> s3: str</span><br><span class="line">        :rtype: bool</span><br><span class="line"></span><br><span class="line">        核心思想:</span><br><span class="line">                考虑最脑残的方法，直接对s1和s2的所有字母进行统计</span><br><span class="line">                然后在对s3进行统计</span><br><span class="line">                如果两种字母数量和类别不一样的话，则返回false</span><br><span class="line">                否则返回true</span><br><span class="line"></span><br><span class="line">                考虑使用字典存储</span><br><span class="line"></span><br><span class="line">                上述方法失败，还要我忽略了还要保证顺序的问题</span><br><span class="line"></span><br><span class="line">                如果s1的长度+s2的长度不等于s3的长度，则一定不行</span><br><span class="line"></span><br><span class="line">                考虑使用动态规划来解决</span><br><span class="line">                可以将本问题看成寻找路径的问题，<span class="keyword">dp</span>[i][<span class="keyword">j</span>]表示s1的前i个字符和s2的前<span class="keyword">j</span>个字符是否可以构成s3前i+<span class="keyword">j</span>个字符</span><br><span class="line">                <span class="keyword">dp</span>[<span class="number">0</span>][<span class="number">0</span>]为<span class="string">""</span>和<span class="string">""</span></span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s1) + <span class="built_in">len</span>(s2) != <span class="built_in">len</span>(s3):</span><br><span class="line">            <span class="keyword">return</span> False</span><br><span class="line">        <span class="keyword">dp</span> = [[False <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="built_in">len</span>(s2)+<span class="number">1</span>)] <span class="keyword">for</span> <span class="keyword">j</span> in <span class="built_in">range</span>(<span class="built_in">len</span>(s1)+<span class="number">1</span>)] # 初始<span class="keyword">dp</span>数组</span><br><span class="line">        <span class="keyword">dp</span>[<span class="number">0</span>][<span class="number">0</span>] = True</span><br><span class="line">        # 先处理s2为<span class="string">""</span>，s1不为<span class="string">""</span>的情况</span><br><span class="line">        <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(s1)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">dp</span>[i][<span class="number">0</span>] = <span class="keyword">dp</span>[i-<span class="number">1</span>][<span class="number">0</span>] <span class="built_in">and</span> s1[i-<span class="number">1</span>] == s3[i-<span class="number">1</span>]</span><br><span class="line">        # 处理s1为<span class="string">""</span>，s2不为<span class="string">""</span>的情况</span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">j</span> in <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(s2)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">dp</span>[<span class="number">0</span>][<span class="keyword">j</span>] = <span class="keyword">dp</span>[<span class="number">0</span>][<span class="keyword">j</span>-<span class="number">1</span>] <span class="built_in">and</span> s2[<span class="keyword">j</span>-<span class="number">1</span>] == s3[<span class="keyword">j</span>-<span class="number">1</span>]</span><br><span class="line">        # s1和s2均不为<span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(s1)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> <span class="keyword">j</span> in <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(s2)+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">dp</span>[i][<span class="keyword">j</span>] = (<span class="keyword">dp</span>[i-<span class="number">1</span>][<span class="keyword">j</span>] <span class="built_in">and</span> s1[i-<span class="number">1</span>]==s3[i+<span class="keyword">j</span>-<span class="number">1</span>]) <span class="built_in">or</span> (<span class="keyword">dp</span>[i][<span class="keyword">j</span>-<span class="number">1</span>] <span class="built_in">and</span> s2[<span class="keyword">j</span>-<span class="number">1</span>]==s3[i+<span class="keyword">j</span>-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">dp</span>[-<span class="number">1</span>][-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    <span class="keyword">print</span>(s.isInterleave(s1 = <span class="string">"aabcc"</span>, s2 = <span class="string">"dbbca"</span>, s3 = <span class="string">"aadbbcbcac"</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;五一出去旅游了，鸽了几天，回来接着更新塞。&lt;/p&gt;
&lt;h1&gt;LeetCode第九十七题—交错字符串&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.96</title>
    <link href="www.strivezs.com/2021/04/28/LeetCode%E7%AC%AC%E4%B9%9D%E5%8D%81%E5%85%AD%E9%A2%98/"/>
    <id>www.strivezs.com/2021/04/28/LeetCode%E7%AC%AC%E4%B9%9D%E5%8D%81%E5%85%AD%E9%A2%98/</id>
    <published>2021-04-28T10:50:17.386Z</published>
    <updated>2021-04-28T10:50:17.386Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第九十六题—不同的二叉搜索树</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: <span class="number">3</span></span><br><span class="line">输出: <span class="number">5</span></span><br><span class="line">解释:</span><br><span class="line">给定 n = <span class="number">3</span>, 一共有 <span class="number">5</span> 种不同结构的二叉搜索树:</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span>         <span class="number">3</span>     <span class="number">3</span>      <span class="number">2</span>      <span class="number">1</span></span><br><span class="line">    \       /     /      / \      \</span><br><span class="line">     <span class="number">3</span>     <span class="number">2</span>     <span class="number">1</span>      <span class="number">1</span>   <span class="number">3</span>      <span class="number">2</span></span><br><span class="line">    /     /       \                 \</span><br><span class="line">   <span class="number">2</span>     <span class="number">1</span>         <span class="number">2</span>                 <span class="number">3</span></span><br><span class="line">通过次数<span class="number">120</span>,<span class="number">434</span>提交次数<span class="number">173</span>,<span class="number">199</span></span><br></pre></td></tr></table></figure><h2 id="代码-题目分析"><a class="header-anchor" href="#代码-题目分析">¶</a>代码+题目分析</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def numTrees(self, n):</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        :<span class="built_in">type</span> n: <span class="keyword">int</span></span><br><span class="line">        :rtype: <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">        上一道题的改编吧，这个什么鬼顺序，明明这道题前面比较好吧。除了直接把上一题的结果返回一个<span class="built_in">len</span>之外的别的办法</span><br><span class="line">        直接改变上一题的方法有点蠢，必然花费时间很大。因此考虑其他办法</span><br><span class="line">        考虑使用动态规划</span><br><span class="line">        思路：</span><br><span class="line">            同上一题的思路：如果<span class="number">1</span>-n中，第<span class="keyword">k</span>个节点去作为根节点划分，那么<span class="number">1</span>-<span class="keyword">k</span>-<span class="number">1</span>则进行构建左子搜索树，<span class="keyword">k</span>+<span class="number">1</span>-n则构建右子搜索树</span><br><span class="line">            对于左子树同样重复上述方法进行划分，同样右子树也是重复上述方法进行划分</span><br><span class="line">            假设左子树有<span class="keyword">a</span>种形态，右子树有<span class="keyword">b</span>种形态，则以<span class="keyword">k</span>为根节点的搜索树则有<span class="keyword">a</span>*<span class="keyword">b</span>种形态</span><br><span class="line"></span><br><span class="line">        定义DP问题：</span><br><span class="line">            n=<span class="number">2</span>时，用<span class="number">1</span>，<span class="number">2</span>构建搜索树，以<span class="number">1</span>为根，则用<span class="number">2</span>只能构建一种搜索树，以<span class="number">2</span>为根，则用<span class="number">1</span>只能构建一种搜索树</span><br><span class="line">            <span class="number">1</span>        <span class="number">2</span></span><br><span class="line">             \      /</span><br><span class="line">              <span class="number">2</span>    <span class="number">1</span></span><br><span class="line">            n=<span class="number">3</span>时，用<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>构建搜索树，以<span class="number">1</span>为根，针对<span class="number">2</span>，<span class="number">3</span>的话类似上面会有两种结果，</span><br><span class="line">                                   以<span class="number">2</span>为根，针对<span class="number">1</span>左子树，<span class="number">3</span>右子树，只有一种结果，</span><br><span class="line">                                   以<span class="number">3</span>为根，针对<span class="number">1</span>，<span class="number">2</span>的话类似上面会有两种结果</span><br><span class="line">            n=<span class="number">4</span>时，用<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span>构建搜索树，以<span class="number">1</span>为根，根据n=<span class="number">3</span>的结果，有<span class="number">5</span>种结果</span><br><span class="line">                                       以<span class="number">2</span>为根，左子树一种结结果，右子树<span class="number">3</span>，<span class="number">4</span>有两种结果</span><br><span class="line">                                       以<span class="number">3</span>为根，左子树两种结果，右子树一种结果</span><br><span class="line">                                       以<span class="number">4</span>为根，左子树<span class="number">5</span>种结果</span><br><span class="line">            对于n=<span class="number">5</span>，n=<span class="number">6</span>都类似。  其实感觉通过递推可以直接找到规律了</span><br><span class="line">            因此<span class="keyword">dp</span>[i]可以用来表示为连续的i个数构成的搜索树的个数 比如i=<span class="number">2</span> 则是<span class="number">1</span>，<span class="number">2</span>或者<span class="number">2</span>，<span class="number">3</span>或者<span class="number">3</span>，<span class="number">4</span>等只能构成<span class="number">2</span>个数</span><br><span class="line">        状态转移方程：</span><br><span class="line">            这里我们依次要用<span class="number">1</span>-n分别作为根节点来构建状态转移方程。去掉根节点之后左右两侧的节点分别用于构建左子树和右子树</span><br><span class="line">            根据上面<span class="keyword">dp</span>[i]的定义我们可以得到下述方程:</span><br><span class="line">            <span class="keyword">dp</span>[i]是连续i个数可以构成的子树的个数</span><br><span class="line">            <span class="keyword">dp</span>[i] = ∑ <span class="keyword">dp</span>[<span class="keyword">j</span>]*<span class="keyword">dp</span>[i-<span class="keyword">j</span>-<span class="number">1</span>] // 求和是用来除以<span class="keyword">j</span>从<span class="number">0</span>到i-<span class="number">1</span>所有的情况，-<span class="number">1</span>的目的是因为有一个节点要作为根节点</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        # 处理特殊情况</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span> <span class="built_in">or</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        # 正常遍历</span><br><span class="line">        <span class="keyword">dp</span> = [<span class="number">0</span>]*(n+<span class="number">1</span>) # 创建数组</span><br><span class="line">        # 只有 <span class="number">1</span>个或者<span class="number">0</span>个节点智能生成一棵树</span><br><span class="line">        <span class="keyword">dp</span>[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">dp</span>[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> <span class="keyword">j</span> in <span class="built_in">range</span>(<span class="number">0</span>,i):</span><br><span class="line">                <span class="keyword">dp</span>[i] += <span class="keyword">dp</span>[<span class="keyword">j</span>] * <span class="keyword">dp</span>[i-<span class="keyword">j</span>-<span class="number">1</span>] # 状态转移方程</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">dp</span>[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第九十六题—不同的二叉搜索树&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)&lt;
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.95</title>
    <link href="www.strivezs.com/2021/04/27/LeetCode%E7%AC%AC%E4%B9%9D%E5%8D%81%E4%BA%94%E9%A2%98/"/>
    <id>www.strivezs.com/2021/04/27/LeetCode%E7%AC%AC%E4%B9%9D%E5%8D%81%E4%BA%94%E9%A2%98/</id>
    <published>2021-04-27T05:18:22.880Z</published>
    <updated>2021-04-27T05:18:22.880Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第九十五题—不同的二叉搜索II</h1><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定一个整数 n，生成所有由 1 … n 为节点所组成的 二叉搜索树 。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：<span class="number">3</span></span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="literal">null</span>,<span class="number">3</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">2</span>,<span class="literal">null</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">1</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="literal">null</span>,<span class="number">2</span>,<span class="literal">null</span>,<span class="number">3</span>]</span><br><span class="line">]</span><br><span class="line">解释：</span><br><span class="line">以上的输出对应以下 <span class="number">5</span> 种不同结构的二叉搜索树：</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span>         <span class="number">3</span>     <span class="number">3</span>      <span class="number">2</span>      <span class="number">1</span></span><br><span class="line">    \       /     /      / \      \</span><br><span class="line">     <span class="number">3</span>     <span class="number">2</span>     <span class="number">1</span>      <span class="number">1</span>   <span class="number">3</span>      <span class="number">2</span></span><br><span class="line">    /     /       \                 \</span><br><span class="line">   <span class="number">2</span>     <span class="number">1</span>         <span class="number">2</span>                 <span class="number">3</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> &lt;= n &lt;= <span class="number">8</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val=<span class="number">0</span>, left=None, right=None)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateTrees</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[TreeNode]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        题目分析：</span></span><br><span class="line"><span class="string">                根据给的例子可以看出，每个访问的情况都是使用的中序遍历，而且中序遍历得到的结果要满足[1,2,3]</span></span><br><span class="line"><span class="string">                二叉搜索树的性质：</span></span><br><span class="line"><span class="string">                    根节点的左子树的元素都要小于根节点，根节点的右子树元素都要大于根节点</span></span><br><span class="line"><span class="string">                根据上面性质可以想到，对于每一个子树都满足上述的性质，因此可以将问题看成一个分而治之的问题，</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        解题思路：</span></span><br><span class="line"><span class="string">                采用分治的方法，选取一个节点作为根节点，前面的部分作为作为左子树，后面的部分作为右子树</span></span><br><span class="line"><span class="string">                针对左子树，同样采样上述方法，针对右子树同样采用上述方法</span></span><br><span class="line"><span class="string">                依次按照上述方法划分，然后在进行拼接即可</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">generateSearchTree</span><span class="params">(start,end)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> start &gt; end:</span><br><span class="line">                <span class="keyword">return</span> [<span class="literal">None</span>,]</span><br><span class="line">            allTress = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(start,end+<span class="number">1</span>): <span class="comment"># 针对所有情况进行枚举，因为每个节点都可以作为根节点</span></span><br><span class="line">                <span class="comment"># 对左子树建立二叉搜索树</span></span><br><span class="line">                leftTree = generateSearchTree(start,i<span class="number">-1</span>) <span class="comment"># 获得所有的左子树的可能</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 针对右子树建立二叉搜索树</span></span><br><span class="line">                rightTree = generateSearchTree(i+<span class="number">1</span>,end) <span class="comment"># 所有所有右子树的可能</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 针对对左子树和右子树进行组合，将他们分别拼接到根节点上</span></span><br><span class="line">                <span class="keyword">for</span> lt <span class="keyword">in</span> leftTree:</span><br><span class="line">                    <span class="keyword">for</span> rt <span class="keyword">in</span> rightTree:</span><br><span class="line">                        current_root = TreeNode(i) <span class="comment"># 当前根节点</span></span><br><span class="line">                        current_root.left = lt <span class="comment"># 拼接左子树</span></span><br><span class="line">                        current_root.right = rt <span class="comment"># 拼接右子树</span></span><br><span class="line">                        allTress.append(current_root) <span class="comment"># 添加到当前根节点对应的划分情况</span></span><br><span class="line">            <span class="comment"># 针对子级调用的话，则上一次就返回的是以这个根节点为划分的左子树/右子树的所有可能</span></span><br><span class="line">            <span class="comment"># 如上面rightTree/leftTree 进行generateSearchTree调用返回的是这个子树对应的所有二叉搜索树的情况</span></span><br><span class="line">            <span class="comment"># 对于最开始的调用，则返回的就是最终的结果</span></span><br><span class="line">            <span class="keyword">return</span> allTress</span><br><span class="line">        <span class="keyword">return</span> generateSearchTree(<span class="number">1</span>,n)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第九十五题—不同的二叉搜索II&lt;/h1&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#题目描述&quot;&gt;¶&lt;/a&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给定一个整数 n，生成所有由 1 … n 为节点所组成的 二叉搜索树 。&lt;
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.94</title>
    <link href="www.strivezs.com/2021/04/26/LeetCode%E7%AC%AC%E4%B9%9D%E5%8D%81%E5%9B%9B%E9%A2%98/"/>
    <id>www.strivezs.com/2021/04/26/LeetCode%E7%AC%AC%E4%B9%9D%E5%8D%81%E5%9B%9B%E9%A2%98/</id>
    <published>2021-04-26T11:26:21.554Z</published>
    <updated>2021-04-26T11:26:21.554Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第九十四题—二叉树的中序遍历</h1><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定一个二叉树的根节点 root ，返回它的 中序 遍历。</p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt="figure.1"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">1</span>,<span class="literal">null</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_5.jpg" alt="figure.2"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">4</span>：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_4.jpg" alt="figure.3"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">5</span>：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">1</span>,<span class="literal">null</span>,<span class="number">2</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">树中节点数目在范围 [<span class="number">0</span>, <span class="number">100</span>] 内</span><br><span class="line"><span class="number">-100</span> &lt;= Node.val &lt;= <span class="number">100</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">                中序遍历原理：先遍历左子树，在访问根节点，最后遍历右子树</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">middle_order</span><span class="params">(node)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> node != <span class="literal">None</span>:</span><br><span class="line">                middle_order(node.left)</span><br><span class="line">                self.res.append(node.val)</span><br><span class="line">                middle_order(node.right)</span><br><span class="line">        </span><br><span class="line">        middle_order(root)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第九十四题—二叉树的中序遍历&lt;/h1&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#题目描述&quot;&gt;¶&lt;/a&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给定一个二叉树的根节点 root ，返回它的 中序 遍历。&lt;/p&gt;
&lt;p&gt;&lt;
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.93</title>
    <link href="www.strivezs.com/2021/04/25/LeetCode%E7%AC%AC%E4%B9%9D%E5%8D%81%E4%B8%89%E9%A2%98/"/>
    <id>www.strivezs.com/2021/04/25/LeetCode%E7%AC%AC%E4%B9%9D%E5%8D%81%E4%B8%89%E9%A2%98/</id>
    <published>2021-04-25T11:28:47.264Z</published>
    <updated>2021-04-25T11:28:47.264Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第九十三题—复原IP地址</h1><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定一个只包含数字的字符串，用以表示一个 IP 地址，返回所有可能从 s 获得的 有效 IP 地址 。你可以按任何顺序返回答案。</p><p>有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。</p><p>例如：“0.1.2.201” 和 “192.168.1.1” 是 有效 IP 地址，但是 “0.011.255.245”、“192.168.1.312” 和 “192.168@1.1” 是 无效 IP 地址。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"25525511135"</span></span><br><span class="line">输出：[<span class="string">"255.255.11.135"</span>,<span class="string">"255.255.111.35"</span>]</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"0000"</span></span><br><span class="line">输出：[<span class="string">"0.0.0.0"</span>]</span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"1111"</span></span><br><span class="line">输出：[<span class="string">"1.1.1.1"</span>]</span><br><span class="line">示例 <span class="number">4</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"010010"</span></span><br><span class="line">输出：[<span class="string">"0.10.0.10"</span>,<span class="string">"0.100.1.0"</span>]</span><br><span class="line">示例 <span class="number">5</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"101023"</span></span><br><span class="line">输出：[<span class="string">"1.0.10.23"</span>,<span class="string">"1.0.102.3"</span>,<span class="string">"10.1.0.23"</span>,<span class="string">"10.10.2.3"</span>,<span class="string">"101.0.2.3"</span>]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> &lt;= s.length &lt;= <span class="number">3000</span></span><br><span class="line">s 仅由数字组成</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><p>执行用时：36 ms, 在所有 Python3 提交中击败了94.35%的用户内存消耗：14.9 MB, 在所有 Python3 提交中击败了86.32%的用户</p><p>好像可以缩减一下代码QWQ</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def restoreIpAddresses(self, s):</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        :<span class="built_in">type</span> <span class="variable">s:</span> str</span><br><span class="line">        :rtype: List[str]</span><br><span class="line"></span><br><span class="line">        核心思想:</span><br><span class="line">                回溯算法</span><br><span class="line">                def backtrack(path, selected):</span><br><span class="line">                    <span class="keyword">if</span> 满足停止条件：</span><br><span class="line">                        <span class="keyword">res</span>.<span class="keyword">append</span>(path)</span><br><span class="line">                    <span class="keyword">for</span> 选择 in 选择列表：</span><br><span class="line">                        做出选择</span><br><span class="line">                        递归执行backtrack</span><br><span class="line">                            满足则<span class="keyword">return</span> True</span><br><span class="line">                        如果不满足要求就撤销选择</span><br><span class="line">                满足条件判断：</span><br><span class="line">                    <span class="number">1</span>. 位于<span class="number">0</span>-<span class="number">255</span>之间</span><br><span class="line">                    <span class="number">2</span>. 以<span class="number">0</span>开头的不满足，比如：<span class="number">01</span> <span class="number">02</span> <span class="number">010</span>等</span><br><span class="line">                    <span class="number">3</span>. 含有非法字符不满足</span><br><span class="line">                    <span class="number">4</span>. 划分部分必须等于<span class="number">4</span>部分</span><br><span class="line">                存储结构使用[]存储，将满足的[]在存到result中</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        self.<span class="keyword">res</span> = []</span><br><span class="line">        # 去除长度大于<span class="number">12</span>的情况，因此长度大于<span class="number">12</span>，属于非法的</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) &gt; <span class="number">12</span>:</span><br><span class="line">            <span class="keyword">return</span> self.<span class="keyword">res</span></span><br><span class="line">        # 回溯</span><br><span class="line">        def backtrack(s, path):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="number">4</span>:</span><br><span class="line">                <span class="keyword">if</span> path not in self.re<span class="variable">s:</span></span><br><span class="line">                    self.<span class="keyword">res</span>.<span class="keyword">append</span>(<span class="string">'.'</span>.<span class="keyword">join</span>(path))</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">            # 已经选择了<span class="number">3</span>个</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="number">3</span> <span class="built_in">and</span> s != <span class="string">''</span>:</span><br><span class="line">                temp = s</span><br><span class="line">                # 选择合法的情况</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">int</span>(temp) &gt;= <span class="number">0</span> <span class="built_in">and</span> <span class="keyword">int</span>(temp) &lt;= <span class="number">255</span>:</span><br><span class="line">                    # 去除前导为<span class="number">0</span>的情况，如果前导存在<span class="number">0</span>，则不再进行递归</span><br><span class="line">                    <span class="keyword">if</span> str(<span class="keyword">int</span>(temp)) == temp:</span><br><span class="line">                        backtrack(<span class="string">''</span>,path+[temp])</span><br><span class="line">            # 选择一个<span class="number">1</span>或者两个或者<span class="number">0</span>个的情况都是一样的</span><br><span class="line">            elif <span class="built_in">len</span>(path) &lt; <span class="number">3</span> <span class="built_in">and</span> s != <span class="string">''</span>:</span><br><span class="line">                # 最大可选择的长度为<span class="number">3</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(s) &lt;= <span class="number">3</span>:</span><br><span class="line">                    <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">                        temp = s[:i+<span class="number">1</span>]</span><br><span class="line">                        <span class="keyword">next</span> = s[i+<span class="number">1</span>:]</span><br><span class="line">                        <span class="keyword">if</span> <span class="keyword">int</span>(temp) &gt;= <span class="number">0</span> <span class="built_in">and</span> <span class="keyword">int</span>(temp) &lt;= <span class="number">255</span>:</span><br><span class="line">                            # 去除前导为<span class="number">0</span>的情况，如果前导存在<span class="number">0</span>，则不再进行递归</span><br><span class="line">                            <span class="keyword">if</span> str(<span class="keyword">int</span>(temp)) == temp:</span><br><span class="line">                                backtrack(<span class="keyword">next</span>, path+[temp])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">                        temp = s[:i + <span class="number">1</span>]</span><br><span class="line">                        <span class="keyword">next</span> = s[i + <span class="number">1</span>:]</span><br><span class="line">                        <span class="keyword">if</span> <span class="keyword">int</span>(temp) &gt;= <span class="number">0</span> <span class="built_in">and</span> <span class="keyword">int</span>(temp) &lt;= <span class="number">255</span>:</span><br><span class="line">                            # 去除前导为<span class="number">0</span>的情况，如果前导存在<span class="number">0</span>，则不再进行递归</span><br><span class="line">                            <span class="keyword">if</span> str(<span class="keyword">int</span>(temp)) == temp:</span><br><span class="line">                                backtrack(<span class="keyword">next</span>, path+[temp])</span><br><span class="line">        backtrack(s, [])</span><br><span class="line">        <span class="keyword">return</span> self.<span class="keyword">res</span></span><br><span class="line">                        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    <span class="keyword">print</span>(s.restoreIpAddresses(<span class="string">"1111"</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第九十三题—复原IP地址&lt;/h1&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#题目描述&quot;&gt;¶&lt;/a&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给定一个只包含数字的字符串，用以表示一个 IP 地址，返回所有可能从 s 获得的
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>MAC安装Cesium环境</title>
    <link href="www.strivezs.com/2021/04/25/MAC%E5%AE%89%E8%A3%85Cesium%E7%8E%AF%E5%A2%83/"/>
    <id>www.strivezs.com/2021/04/25/MAC%E5%AE%89%E8%A3%85Cesium%E7%8E%AF%E5%A2%83/</id>
    <published>2021-04-25T10:43:19.293Z</published>
    <updated>2021-04-25T10:43:19.293Z</updated>
    
    <content type="html"><![CDATA[<h1>MAC安装Cesium环境</h1><h2 id="配置NodeJs-nvm-npm"><a class="header-anchor" href="#配置NodeJs-nvm-npm">¶</a>配置NodeJs+nvm+npm</h2><p>访问github官方地址，根据官方的文档来安装Mac版本的nvm，<a href="https://github.com/nvm-sh/nvm">click here</a></p><p>这里建议用<a href="https://github.com/nvm-sh/nvm">nvm</a>安装管理Node.js</p><p><strong>cURL:</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -<span class="keyword">o</span>- http<span class="variable">s:</span>//raw.githubusercontent.<span class="keyword">com</span>/nvm-<span class="keyword">sh</span>/nvm/v0.<span class="number">35.2</span>/install.<span class="keyword">sh</span> | bash</span><br></pre></td></tr></table></figure><p><strong>Wget:</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -qO- http<span class="variable">s:</span>//raw.githubusercontent.<span class="keyword">com</span>/nvm-<span class="keyword">sh</span>/nvm/v0.<span class="number">35.2</span>/install.<span class="keyword">sh</span> | bash</span><br></pre></td></tr></table></figure><p>nvm安装好后，重启终端，然后安装Node.js：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">nvm ls-remote</span></span><br></pre></td></tr></table></figure><p>使用上述命令来查看远程node版本，然后根据需要安装最新版本的Nodejs：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm install <span class="number">10.15</span><span class="number">.1</span></span><br></pre></td></tr></table></figure><p>安装完成之后可以使用</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm <span class="built_in">list</span></span><br></pre></td></tr></table></figure><p>来查看已经安装的nodejs版本，并且使用</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm <span class="keyword">use</span> 版本号</span><br></pre></td></tr></table></figure><p>来使用对应版本的nodejs。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm use <span class="number">10.15</span><span class="number">.1</span></span><br></pre></td></tr></table></figure><p>可以使用如下命令查看当前node版本</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">node</span> <span class="title">-v</span></span><br></pre></td></tr></table></figure><p>我最新版本的NodeJs报错，这里就是使用10.15.1版本的NodeJs</p><h3 id="NodeJs卸载"><a class="header-anchor" href="#NodeJs卸载">¶</a>NodeJs卸载</h3><p>首先使用nvm的命令停止活跃的NodeJs</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">nvm deactivate</span></span><br></pre></td></tr></table></figure><p>然后使用下面命令下载对应版本的NodeJs</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">nvm</span> uninstall xxx版本号</span><br></pre></td></tr></table></figure><h2 id="安装cesium"><a class="header-anchor" href="#安装cesium">¶</a>安装cesium</h2><p>访问Cesium官方网站，<a href="https://cesium.com/downloads/">click here</a>，使用如下命令安装最新版本的Cesium</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> cesium</span><br></pre></td></tr></table></figure><p>另外一种办法是去官方下载CesiumJs，这里我采用的是去官方下载。<br>下载完成之后进入到对应的目录中执行下面安装命令:</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~<span class="string">/Cesium-1.80</span></span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><h2 id="运行Cesium"><a class="header-anchor" href="#运行Cesium">¶</a>运行Cesium</h2><p>安装完成之后，会在Cesium文件夹中生成一个node_moudles文件夹。如下所示是:</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/Gdg5sO.png" alt="figure.1"></p><p>然后运行执行下面命令运行cesium服务。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">①：npm <span class="literal">start</span></span><br><span class="line">②：<span class="keyword">node</span> <span class="title">servcer</span>.cjs</span><br></pre></td></tr></table></figure><p>然后访问<a href="http://localhost:8080/">Connect to http://localhost:8080/</a><br>出现下述界面则表示成功了：</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/OGMzZZ.png" alt="figure.2"></p><p>也可以访问Demo界面(HelloWorld):<a href="http://localhost:8383/Apps/HelloWorld.html">http://localhost:8383/Apps/HelloWorld.html</a></p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/BGTark.png" alt="figure.4"></p><p>两个关键的网址:</p><ul><li><a href="http://localhost:8383/Build/Documentation/index.html">http://localhost:8383/Build/Documentation/index.html</a>  这是所有API说明文档<ul><li>某一个模块的所有函数，属性</li><li>部分效果截图</li><li>部分函数，属性调用代码示例</li></ul></li><li><a href="http://localhost:8383/Apps/Sandcastle/index.html">http://localhost:8383/Apps/Sandcastle/index.html</a>  这是沙盒<ul><li>可以浏览当前版本的一些功能特性</li><li>一个可运行的代码库</li><li>新建一个页面用于代码测试</li><li>导出测试代码</li></ul></li></ul><h2 id="比较好的学习方式"><a class="header-anchor" href="#比较好的学习方式">¶</a>比较好的学习方式</h2><ul><li>(1)先浏览一遍沙盒的所有示例，Cesium能做什么，能做成什么样</li><li>(2)做自己需要的功能时，查找到相关示例的代码，最好是看看深层次代码</li><li>(3)如果时进行深层次的研究，则需要对WebGLass有更新层次的了解</li><li>(4)用它做自己感兴趣的项目</li></ul><h2 id="问题整理"><a class="header-anchor" href="#问题整理">¶</a>问题整理</h2><p>这里注意一下，如果你使用默认的8080端口，出现访问失败的情况，可能是你的端口号被占用了，可以使用mac命令来杀死端口号，但是这里我建议修改成其他的端口号来进行访问即可。</p><p>修改目录中的server.cjs文件</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/O2yuiN.png" alt="figure.3"></p><p>这里我用的是8383</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;MAC安装Cesium环境&lt;/h1&gt;
&lt;h2 id=&quot;配置NodeJs-nvm-npm&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#配置NodeJs-nvm-npm&quot;&gt;¶&lt;/a&gt;配置NodeJs+nvm+npm&lt;/h2&gt;
&lt;p&gt;访问github官方地
      
    
    </summary>
    
    
      <category term="MAC" scheme="www.strivezs.com/categories/MAC/"/>
    
      <category term="Cesium" scheme="www.strivezs.com/categories/MAC/Cesium/"/>
    
    
      <category term="MAC" scheme="www.strivezs.com/tags/MAC/"/>
    
      <category term="Cesium" scheme="www.strivezs.com/tags/Cesium/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.92</title>
    <link href="www.strivezs.com/2021/04/24/LeetCode%E7%AC%AC%E4%B9%9D%E5%8D%81%E4%BA%8C%E9%A2%98/"/>
    <id>www.strivezs.com/2021/04/24/LeetCode%E7%AC%AC%E4%B9%9D%E5%8D%81%E4%BA%8C%E9%A2%98/</id>
    <published>2021-04-24T05:07:34.129Z</published>
    <updated>2021-04-24T05:07:34.129Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第九十二题—反转链表II</h1><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。</p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg" alt="figure.1"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], left = <span class="number">2</span>, right = <span class="number">4</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：head = [<span class="number">5</span>], left = <span class="number">1</span>, right = <span class="number">1</span></span><br><span class="line">输出：[<span class="number">5</span>]</span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">链表中节点数目为 n</span><br><span class="line"><span class="number">1</span> &lt;= n &lt;= <span class="number">500</span></span><br><span class="line"><span class="number">-500</span> &lt;= Node.val &lt;= <span class="number">500</span></span><br><span class="line"><span class="number">1</span> &lt;= left &lt;= right &lt;= n</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, val=<span class="number">0</span>, <span class="keyword">next</span>=None)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.val = val</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">next</span> = <span class="keyword">next</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span><span class="params">(<span class="keyword">self</span>, head, left, right)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type left: int</span></span><br><span class="line"><span class="string">        :type right: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            核心思想：</span></span><br><span class="line"><span class="string">                    使用一个额外的链表来存储翻转后的结果</span></span><br><span class="line"><span class="string">                    对于原链表沿分别记录需要反转部分前后的node</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        <span class="comment"># 处理特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> left == <span class="symbol">right:</span></span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="comment"># 反转部分前后的Node</span></span><br><span class="line">        leftPart = ListNode()</span><br><span class="line">        rightPart = ListNode()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 新出链表存储反转后的结果</span></span><br><span class="line">        newHead = ListNode()</span><br><span class="line">        last = ListNode()</span><br><span class="line"></span><br><span class="line">        num = <span class="number">0</span> <span class="comment"># 计数菌</span></span><br><span class="line">        temp = head <span class="comment"># 访问Node</span></span><br><span class="line">        flag = True</span><br><span class="line">        <span class="keyword">while</span> temp != None <span class="keyword">and</span> <span class="symbol">flag:</span></span><br><span class="line">            num += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 记录左右边界</span></span><br><span class="line">            <span class="keyword">if</span> num == left-<span class="number">1</span><span class="symbol">:</span></span><br><span class="line">                leftPart = temp</span><br><span class="line">            <span class="keyword">if</span> num == right+<span class="number">1</span><span class="symbol">:</span></span><br><span class="line">                rightPart = temp</span><br><span class="line">                flag = False <span class="comment"># 结束标志</span></span><br><span class="line">            <span class="comment"># 反转</span></span><br><span class="line">            <span class="keyword">if</span> num &gt;= left <span class="keyword">and</span> num &lt;= <span class="symbol">right:</span></span><br><span class="line">                tt = ListNode(val=temp.val)</span><br><span class="line">                tt.<span class="keyword">next</span> = newHead.<span class="keyword">next</span></span><br><span class="line">                newHead.<span class="keyword">next</span> = tt</span><br><span class="line">                <span class="keyword">if</span> num == <span class="symbol">left:</span></span><br><span class="line">                    last = tt <span class="comment"># 记录尾结点</span></span><br><span class="line">                    <span class="comment"># print('---' + str(last.val))</span></span><br><span class="line">            temp = temp.<span class="keyword">next</span></span><br><span class="line">        <span class="comment"># 单独处理头尾反转特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> left == <span class="number">1</span> <span class="keyword">and</span> num==<span class="symbol">right:</span></span><br><span class="line">            <span class="keyword">return</span> newHead.<span class="keyword">next</span></span><br><span class="line">        elif left == <span class="number">1</span><span class="symbol">:</span></span><br><span class="line">            last.<span class="keyword">next</span> = rightPart  <span class="comment"># 右边连接</span></span><br><span class="line">            <span class="keyword">return</span> newHead.<span class="keyword">next</span></span><br><span class="line">        elif num == <span class="symbol">right:</span></span><br><span class="line">            leftPart.<span class="keyword">next</span> = newHead.<span class="keyword">next</span>  <span class="comment"># 左边连接</span></span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 链表链接</span></span><br><span class="line">        leftPart.<span class="keyword">next</span> = newHead.<span class="keyword">next</span> <span class="comment"># 左边连接</span></span><br><span class="line">        last.<span class="keyword">next</span> = rightPart  <span class="comment"># 右边连接</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name_<span class="number">_</span> == <span class="string">'__main__'</span><span class="symbol">:</span></span><br><span class="line">    a1 = ListNode(<span class="number">3</span>)</span><br><span class="line">    a2 = ListNode(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    a1.<span class="keyword">next</span> = a2</span><br><span class="line"></span><br><span class="line">    s = Solution()</span><br><span class="line">    head = s.reverseBetween(a1,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">while</span> head != <span class="symbol">None:</span></span><br><span class="line">        print(str(head.val)+<span class="string">' '</span>)</span><br><span class="line">        head = head.<span class="keyword">next</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第九十二题—反转链表II&lt;/h1&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#题目描述&quot;&gt;¶&lt;/a&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给你单链表的头指针 head 和两个整数 left 和 right ，其中 le
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.91</title>
    <link href="www.strivezs.com/2021/04/23/LeetCode%E7%AC%AC%E4%B9%9D%E5%8D%81%E4%B8%80%E9%A2%98/"/>
    <id>www.strivezs.com/2021/04/23/LeetCode%E7%AC%AC%E4%B9%9D%E5%8D%81%E4%B8%80%E9%A2%98/</id>
    <published>2021-04-23T15:52:11.072Z</published>
    <updated>2021-04-23T15:52:11.072Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第九十一题—解码方法</h1><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：</p><p>‘A’ -&gt; 1<br>‘B’ -&gt; 2<br>…<br>‘Z’ -&gt; 26<br>要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，“11106” 可以映射为：</p><p>“AAJF” ，将消息分组为 (1 1 10 6)<br>“KJF” ，将消息分组为 (11 10 6)<br>注意，消息不能分组为  (1 11 06) ，因为 “06” 不能映射为 “F” ，这是由于 “6” 和 “06” 在映射中并不等价。</p><p>给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。</p><p>题目数据保证答案肯定是一个 32 位 的整数。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"12"</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：它可以解码为 <span class="string">"AB"</span>（<span class="number">1</span> <span class="number">2</span>）或者 <span class="string">"L"</span>（<span class="number">12</span>）。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"226"</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：它可以解码为 <span class="string">"BZ"</span> (<span class="number">2</span> <span class="number">26</span>), <span class="string">"VF"</span> (<span class="number">22</span> <span class="number">6</span>), 或者 <span class="string">"BBF"</span> (<span class="number">2</span> <span class="number">2</span> <span class="number">6</span>) 。</span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"0"</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：没有字符映射到以 <span class="number">0</span> 开头的数字。</span><br><span class="line">含有 <span class="number">0</span> 的有效映射是 'J' -&gt; <span class="string">"10"</span> 和 'T'-&gt; <span class="string">"20"</span> 。</span><br><span class="line">由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。</span><br><span class="line">示例 <span class="number">4</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"06"</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：<span class="string">"06"</span> 不能映射到 <span class="string">"F"</span> ，因为字符串含有前导 <span class="number">0</span>（<span class="string">"6"</span> 和 <span class="string">"06"</span> 在映射中并不等价）。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= s.length &lt;= <span class="number">100</span></span><br><span class="line">s 只包含数字，并且可能包含前导零。</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def numDecodings(self, s):</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        :<span class="built_in">type</span> <span class="variable">s:</span> str</span><br><span class="line">        :rtype: <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">        核心思想：动态规划</span><br><span class="line">                s[i]只包含数字，其可能为<span class="number">0</span></span><br><span class="line"></span><br><span class="line">                第一步：定义<span class="keyword">dp</span>数组</span><br><span class="line">                    <span class="keyword">dp</span>[i]表示前i个数字解码的个数，结果直接返回<span class="keyword">dp</span>[-<span class="number">1</span>]</span><br><span class="line">                第二步：确定状态转移方程</span><br><span class="line">                    状态转移方程表示了大规模的问题如何由小规模问题转换而来</span><br><span class="line">                    即如何用<span class="keyword">dp</span>[i-<span class="number">1</span>]...<span class="keyword">dp</span>[<span class="number">0</span>]来得到<span class="keyword">dp</span>[i]</span><br><span class="line"></span><br><span class="line">                    本题分析：对于两个字符来说，只存在被解码成<span class="number">0</span>种、<span class="number">1</span>种、<span class="number">2</span>种的情况，所以需要分别讨论上述情况是如何得到的</span><br><span class="line">                    具体讨论如下:</span><br><span class="line">                        ① s[i]不在合法集合中即s[i]为<span class="number">0</span>，这是来考察si[i-<span class="number">1</span>]+s[i]=[i-<span class="number">1</span>:i+<span class="number">1</span>]的</span><br><span class="line">                            - 对于<span class="number">0</span>s[i]这种情况，必然不在合法集合中，直接返回<span class="number">0</span></span><br><span class="line">                            - 但是对于s[i]<span class="number">0</span>这种情况，是存在合法情况的，如<span class="number">10</span> <span class="number">20</span></span><br><span class="line">                        ② s[i]在合法集合中，考察si[i-<span class="number">1</span>]+s[i]=[i-<span class="number">1</span>:i+<span class="number">1</span>]的</span><br><span class="line">                            - s[i-<span class="number">1</span>:i+<span class="number">1</span>]不在合法集合中，即大于<span class="number">26</span>或者小于<span class="number">1</span>的情况，无法解码</span><br><span class="line">                            - s[i-<span class="number">1</span>:i+<span class="number">1</span>]在合法集合中，即在<span class="number">1</span>-<span class="number">26</span>之间，但是需要注意这种情况是可以进行拆分解码的</span><br><span class="line">                            拆分之后会影响后面的解码情况的</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        <span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">'0'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        length = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">if</span> length == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        # 生成数组</span><br><span class="line">        legal = <span class="keyword">set</span>(str(i) <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">27</span>))</span><br><span class="line">        <span class="keyword">dp</span> = [<span class="number">0</span>] * length # 初始化<span class="keyword">dp</span>数组</span><br><span class="line">        <span class="keyword">dp</span>[<span class="number">0</span>] = <span class="number">1</span> # 设置s[<span class="number">0</span>]对应的解码为<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> s[<span class="number">1</span>] not in lega<span class="variable">l:</span>  # s[<span class="number">1</span>]为<span class="number">0</span></span><br><span class="line">            <span class="keyword">dp</span>[<span class="number">1</span>] = <span class="number">1</span> <span class="keyword">if</span> s[: <span class="number">2</span>] in legal <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">dp</span>[<span class="number">1</span>] = <span class="number">2</span> <span class="keyword">if</span> s[: <span class="number">2</span>] in legal <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="number">2</span>,length):</span><br><span class="line">            # 处理剩下的情况  <span class="number">13023</span></span><br><span class="line">            ## 合法情况</span><br><span class="line">            <span class="keyword">if</span> s[i] in lega<span class="variable">l:</span></span><br><span class="line">                <span class="keyword">if</span> s[i-<span class="number">1</span>:i+<span class="number">1</span>] in lega<span class="variable">l:</span></span><br><span class="line">                    <span class="keyword">dp</span>[i] = <span class="keyword">dp</span>[i-<span class="number">1</span>] + <span class="keyword">dp</span>[i-<span class="number">2</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">dp</span>[i] = <span class="keyword">dp</span>[i-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> s[i-<span class="number">1</span>:i+<span class="number">1</span>] in lega<span class="variable">l:</span></span><br><span class="line">                    <span class="keyword">dp</span>[i] = <span class="keyword">dp</span>[i-<span class="number">2</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">dp</span>[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    <span class="keyword">print</span>(s.numDecodings(<span class="string">"12"</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第九十一题—解码方法&lt;/h1&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#题目描述&quot;&gt;¶&lt;/a&gt;题目描述&lt;/h2&gt;
&lt;p&gt;一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：&lt;/p&gt;
&lt;p&gt;‘A’ -&amp;
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.90</title>
    <link href="www.strivezs.com/2021/04/22/LeetCode%E7%AC%AC%E4%B9%9D%E5%8D%81%E9%A2%98/"/>
    <id>www.strivezs.com/2021/04/22/LeetCode%E7%AC%AC%E4%B9%9D%E5%8D%81%E9%A2%98/</id>
    <published>2021-04-22T04:41:56.031Z</published>
    <updated>2021-04-22T04:41:56.031Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第九十题—子集II</h1><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p><p>解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出：[[],[<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>],[<span class="number">2</span>],[<span class="number">2</span>,<span class="number">2</span>]]</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">0</span>]</span><br><span class="line">输出：[[],[<span class="number">0</span>]]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= nums.length &lt;= <span class="number">10</span></span><br><span class="line"><span class="number">-10</span> &lt;= nums[i] &lt;= <span class="number">10</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def subsetsWithDup(self, nums):</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        :<span class="built_in">type</span> num<span class="variable">s:</span> List[<span class="keyword">int</span>]</span><br><span class="line">        :rtype: List[List[<span class="keyword">int</span>]]</span><br><span class="line"></span><br><span class="line">        核心思想：</span><br><span class="line">                经典回溯法</span><br><span class="line">                def backtrack(path, selected):</span><br><span class="line">                    <span class="keyword">if</span> 满足停止条件：</span><br><span class="line">                        <span class="keyword">res</span>.<span class="keyword">append</span>(path)</span><br><span class="line">                    <span class="keyword">for</span> 选择 in 选择列表：</span><br><span class="line">                        做出选择</span><br><span class="line">                        递归执行backtrack</span><br><span class="line">                            满足则<span class="keyword">return</span> True</span><br><span class="line">                        如果不满足要求就撤销选择</span><br><span class="line">        魔改<span class="number">78</span>题就可以了</span><br><span class="line">        只需要对生成的结果进行排序，然后判断是否在集合中，如果出现则不行</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        <span class="keyword">res</span> = []</span><br><span class="line">        <span class="keyword">res</span>.<span class="keyword">append</span>([])</span><br><span class="line">        numsLen = <span class="built_in">len</span>(nums)</span><br><span class="line">        temp = []</span><br><span class="line"></span><br><span class="line">        def backtrack(temp, <span class="keyword">l</span>, numsLen, length):</span><br><span class="line">            # 停止条件</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(temp) == length:</span><br><span class="line">                t_1 = sorted(temp)</span><br><span class="line">                <span class="keyword">if</span> t_1 not in re<span class="variable">s:</span></span><br><span class="line">                    tt = <span class="keyword">copy</span>.<span class="keyword">copy</span>(t_1)</span><br><span class="line">                    <span class="keyword">res</span>.<span class="keyword">append</span>(tt)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> <span class="keyword">j</span> in <span class="built_in">range</span>(<span class="keyword">l</span> + <span class="number">1</span>, numsLen):</span><br><span class="line">                # 做出选择</span><br><span class="line">                temp.<span class="keyword">append</span>(nums[<span class="keyword">j</span>])</span><br><span class="line">                # 递归执行</span><br><span class="line">                backtrack(temp, <span class="keyword">j</span>, numsLen, length)</span><br><span class="line">                # 撤销选择</span><br><span class="line">                temp.<span class="keyword">pop</span>()</span><br><span class="line"></span><br><span class="line">        # 递归调用  length值不同</span><br><span class="line">        <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="number">1</span>, numsLen + <span class="number">1</span>):</span><br><span class="line">            backtrack(temp, -<span class="number">1</span>, numsLen, i)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">res</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第九十题—子集II&lt;/h1&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#题目描述&quot;&gt;¶&lt;/a&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
</feed>
