<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>StriveZs的博客</title>
  
  <subtitle>Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="www.strivezs.com/"/>
  <updated>2021-06-10T04:48:12.812Z</updated>
  <id>www.strivezs.com/</id>
  
  <author>
    <name>StriveZs</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PyCharm连接远程服务器</title>
    <link href="www.strivezs.com/2021/06/10/PyCharm%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>www.strivezs.com/2021/06/10/PyCharm%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2021-06-10T04:48:12.812Z</published>
    <updated>2021-06-10T04:48:12.812Z</updated>
    
    <content type="html"><![CDATA[<h1>PyCharm连接远程服务器</h1><p>使用PyCharm连接远程服务器，并使用服务器的解释器和代码文件来进行运行。</p><h2 id="配置Deplotment"><a class="header-anchor" href="#配置Deplotment">¶</a>配置Deplotment</h2><p>在这之前首先建议，要单独创建一个项目文件夹，因为当前项目的文件都会被自动上传上去。</p><p><img src="https://pic1.zhimg.com/80/v2-b499139f685fe9d8615d4287c0bff230_1440w.jpg" alt="figure.1"></p><p><img src="https://pic3.zhimg.com/80/v2-c2be0d6a5587784bcac2658aac39d106_1440w.jpg" alt="figure.2"></p><p>选择你的服务器的地址和你本地的地址:</p><p><img src="https://pic4.zhimg.com/80/v2-ad6ee2f63c3d36236a5c796f7810aa2f_1440w.jpg" alt="figure.3"></p><h2 id="配置解释器"><a class="header-anchor" href="#配置解释器">¶</a>配置解释器</h2><p>该项目现在使用的就是远程服务器上的Python解释器了。以后的项目若想/不想使用该解释器，手动更改解释器即可。<br>目前来说直接配置解释器就可以完成上面的Deployment的操作.</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/D2JQ9A.png" alt="figure.4"></p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/G8MUAj.png" alt="figure.5"></p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/V9UfmX.png" alt="figure.6"></p><h2 id="测试"><a class="header-anchor" href="#测试">¶</a>测试</h2><p>新建一个文件，然后同步上去直接使用如下代码进行测试:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">print</span>(<span class="string">'hello'</span>)</span><br><span class="line">import torch</span><br><span class="line">flag = torch.cuda.is_available()</span><br><span class="line"><span class="builtin-name">print</span>(flag)</span><br><span class="line">ngpu= 1</span><br><span class="line"><span class="comment"># Decide which device we want to run on</span></span><br><span class="line">device = torch.device(<span class="string">"cuda:0"</span> <span class="keyword">if</span> (torch.cuda.is_available() <span class="keyword">and</span> ngpu &gt; 0) <span class="keyword">else</span> <span class="string">"cpu"</span>)</span><br><span class="line"><span class="builtin-name">print</span>(device)</span><br><span class="line"><span class="builtin-name">print</span>(torch.cuda.get_device_name(0))</span><br><span class="line"><span class="builtin-name">print</span>(torch.rand(3,3).cuda())</span><br></pre></td></tr></table></figure><p>出现如下结果:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">True</span><br><span class="line">cuda:<span class="number">0</span></span><br><span class="line">GeForce RTX <span class="number">2080</span></span><br><span class="line">tensor([[<span class="number">0.3170</span>, <span class="number">0.4412</span>, <span class="number">0.3377</span>],</span><br><span class="line">        [<span class="number">0.5438</span>, <span class="number">0.0894</span>, <span class="number">0.6420</span>],</span><br><span class="line">        [<span class="number">0.0981</span>, <span class="number">0.2753</span>, <span class="number">0.0179</span>]], device=<span class="string">'cuda:0'</span>)</span><br></pre></td></tr></table></figure><p>则表明成功了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;PyCharm连接远程服务器&lt;/h1&gt;
&lt;p&gt;使用PyCharm连接远程服务器，并使用服务器的解释器和代码文件来进行运行。&lt;/p&gt;
&lt;h2 id=&quot;配置Deplotment&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#配置Deplotment&quot;&gt;¶&lt;
      
    
    </summary>
    
    
      <category term="Python" scheme="www.strivezs.com/categories/Python/"/>
    
    
      <category term="Python" scheme="www.strivezs.com/tags/Python/"/>
    
      <category term="PyCharm" scheme="www.strivezs.com/tags/PyCharm/"/>
    
      <category term="Linux" scheme="www.strivezs.com/tags/Linux/"/>
    
      <category term="服务器" scheme="www.strivezs.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.130</title>
    <link href="www.strivezs.com/2021/06/10/LeetCode%E7%AC%AC130%E9%A2%98/"/>
    <id>www.strivezs.com/2021/06/10/LeetCode%E7%AC%AC130%E9%A2%98/</id>
    <published>2021-06-10T04:45:26.129Z</published>
    <updated>2021-06-10T04:45:26.129Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第130题—被围绕的区域</h1><p>恢复正常！！</p><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给你一个 m x n 的矩阵 board ，由若干字符 ‘X’ 和 ‘O’ ，找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。</p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/xogrid.jpg" alt="figure.1"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：board = [[<span class="string">"X"</span>,<span class="string">"X"</span>,<span class="string">"X"</span>,<span class="string">"X"</span>],[<span class="string">"X"</span>,<span class="string">"O"</span>,<span class="string">"O"</span>,<span class="string">"X"</span>],[<span class="string">"X"</span>,<span class="string">"X"</span>,<span class="string">"O"</span>,<span class="string">"X"</span>],[<span class="string">"X"</span>,<span class="string">"O"</span>,<span class="string">"X"</span>,<span class="string">"X"</span>]]</span><br><span class="line">输出：[[<span class="string">"X"</span>,<span class="string">"X"</span>,<span class="string">"X"</span>,<span class="string">"X"</span>],[<span class="string">"X"</span>,<span class="string">"X"</span>,<span class="string">"X"</span>,<span class="string">"X"</span>],[<span class="string">"X"</span>,<span class="string">"X"</span>,<span class="string">"X"</span>,<span class="string">"X"</span>],[<span class="string">"X"</span>,<span class="string">"O"</span>,<span class="string">"X"</span>,<span class="string">"X"</span>]]</span><br><span class="line">解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的 <span class="string">'O'</span> 都不会被填充为 <span class="string">'X'</span>。 任何不在边界上，或不与边界上的 <span class="string">'O'</span> 相连的 <span class="string">'O'</span> 最终都会被填充为 <span class="string">'X'</span>。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：board = [[<span class="string">"X"</span>]]</span><br><span class="line">输出：[[<span class="string">"X"</span>]]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">m == board.length</span><br><span class="line">n == board[i].length</span><br><span class="line"><span class="number">1</span> &lt;= m, n &lt;= <span class="number">200</span></span><br><span class="line">board[i][j] 为 <span class="string">'X'</span> 或 <span class="string">'O'</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># fixme: BFS</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">BFS</span><span class="params">(self,board, row, col)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :param board: List[List]棋盘</span></span><br><span class="line"><span class="string">        :param row: Int 行</span></span><br><span class="line"><span class="string">        :param col: Int 列</span></span><br><span class="line"><span class="string">        :return: Boolean</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        row_limit, col_limit = len(board), len(board[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 检查越界情况</span></span><br><span class="line">        <span class="keyword">if</span> row &lt; <span class="number">0</span> <span class="keyword">or</span> row &gt;= row_limit <span class="keyword">or</span> col &lt; <span class="number">0</span> <span class="keyword">or</span> col &gt;= col_limit:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> board[row][col] == <span class="string">'O'</span>:</span><br><span class="line">            board[row][col] = <span class="string">'#'</span></span><br><span class="line">            <span class="comment"># 上下左右查找</span></span><br><span class="line">            self.BFS(board, row + <span class="number">1</span>, col)</span><br><span class="line">            self.BFS(board, row - <span class="number">1</span>, col)</span><br><span class="line">            self.BFS(board, row, col - <span class="number">1</span>)</span><br><span class="line">            self.BFS(board, row, col + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(self, board)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        考虑BFS，分析可得如果边界存在O的话，则可能会出现不能全部为X的情况，当然也存在边界为O，但是内部全为X的情况</span></span><br><span class="line"><span class="string">        如果边界全为X的话，则必然最终结果全为X</span></span><br><span class="line"><span class="string">        边界上O可到的的O均为不可以变为X的</span></span><br><span class="line"><span class="string">        边界O上不可达的O均为可以变为X的</span></span><br><span class="line"><span class="string">        :type board: List[List[str]]</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify board in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(board) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        dim1,dim2 = len(board),len(board[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 从边界非X的开始查找  边界上O可到的的O均为不可以变为X的</span></span><br><span class="line">        <span class="comment">## 上下边界</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(dim1):</span><br><span class="line">            self.BFS(board, i, <span class="number">0</span>)</span><br><span class="line">            self.BFS(board, i, dim2<span class="number">-1</span>)</span><br><span class="line">        <span class="comment">## 左右边界</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(dim2):</span><br><span class="line">            self.BFS(board, <span class="number">0</span>, j)</span><br><span class="line">            self.BFS(board, dim1<span class="number">-1</span>, j)</span><br><span class="line">        <span class="comment"># 处理所有的# # 表示不可以变为X的</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(dim1):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(dim2):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">'#'</span>:</span><br><span class="line">                    board[i][j] = <span class="string">'O'</span></span><br><span class="line">                <span class="keyword">elif</span> board[i][j] == <span class="string">'O'</span>:</span><br><span class="line">                    board[i][j] = <span class="string">'X'</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    print((s.solve(board = [[<span class="string">"X"</span>,<span class="string">"X"</span>,<span class="string">"X"</span>,<span class="string">"X"</span>],[<span class="string">"X"</span>,<span class="string">"O"</span>,<span class="string">"O"</span>,<span class="string">"X"</span>],[<span class="string">"X"</span>,<span class="string">"X"</span>,<span class="string">"O"</span>,<span class="string">"X"</span>],[<span class="string">"X"</span>,<span class="string">"O"</span>,<span class="string">"X"</span>,<span class="string">"X"</span>]])))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第130题—被围绕的区域&lt;/h1&gt;
&lt;p&gt;恢复正常！！&lt;/p&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎S
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.129</title>
    <link href="www.strivezs.com/2021/06/09/LeetCode%E7%AC%AC129%E9%A2%98/"/>
    <id>www.strivezs.com/2021/06/09/LeetCode%E7%AC%AC129%E9%A2%98/</id>
    <published>2021-06-09T12:43:52.655Z</published>
    <updated>2021-06-09T12:43:52.655Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第129题—求根节点到叶节点数字之和</h1><p>好久没更新了，最近事情太多了，天天忙的要死，英语也没来得及背，后面会慢慢恢复的，同时也会更新一大堆学习到的东西，敬请期待。</p><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。<br>每条从根节点到叶节点的路径都代表一个数字：</p><p>例如，从根节点到叶节点的路径 1 -&gt; 2 -&gt; 3 表示数字 123 。<br>计算从根节点到叶节点生成的 所有数字之和 。</p><p>叶节点 是指没有子节点的节点。</p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/num1tree.jpg" alt="figure.1"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">25</span></span><br><span class="line">解释：</span><br><span class="line">从根到叶子节点路径 <span class="number">1</span>-&gt;<span class="number">2</span> 代表数字 <span class="number">12</span></span><br><span class="line">从根到叶子节点路径 <span class="number">1</span>-&gt;<span class="number">3</span> 代表数字 <span class="number">13</span></span><br><span class="line">因此，数字总和 = <span class="number">12</span> + <span class="number">13</span> = <span class="number">25</span></span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2021/02/19/num2tree.jpg" alt="figure.2"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">2</span>：</span><br><span class="line">输入：root = [<span class="number">4</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">1026</span></span><br><span class="line">解释：</span><br><span class="line">从根到叶子节点路径 <span class="number">4</span>-&gt;<span class="number">9</span>-&gt;<span class="number">5</span> 代表数字 <span class="number">495</span></span><br><span class="line">从根到叶子节点路径 <span class="number">4</span>-&gt;<span class="number">9</span>-&gt;<span class="number">1</span> 代表数字 <span class="number">491</span></span><br><span class="line">从根到叶子节点路径 <span class="number">4</span>-&gt;<span class="number">0</span> 代表数字 <span class="number">40</span></span><br><span class="line">因此，数字总和 = <span class="number">495</span> + <span class="number">491</span> + <span class="number">40</span> = <span class="number">1026</span></span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">树中节点的数目在范围 [<span class="number">1</span>, <span class="number">1000</span>] 内</span><br><span class="line"><span class="number">0</span> &lt;= Node.val &lt;= <span class="number">9</span></span><br><span class="line">树的深度不超过 <span class="number">10</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val=<span class="number">0</span>, left=None, right=None)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, node, curStr)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> node != <span class="literal">None</span>:</span><br><span class="line">            curStr += str(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.right == <span class="literal">None</span> <span class="keyword">and</span> node.left == <span class="literal">None</span>:</span><br><span class="line">                self.sum += int(curStr)</span><br><span class="line">            self.dfs(node.left, curStr)</span><br><span class="line">            self.dfs(node.right, curStr)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumNumbers</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        D FS 强制类型转换并且记录就好了</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.sum =<span class="number">0</span></span><br><span class="line">        self.dfs(root, <span class="string">''</span>)</span><br><span class="line">        <span class="keyword">return</span> self.sum</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    root = TreeNode(<span class="number">1</span>)</span><br><span class="line">    node1 = TreeNode(<span class="number">2</span>)</span><br><span class="line">    node2 = TreeNode(<span class="number">3</span>)</span><br><span class="line">    root.left = node1</span><br><span class="line">    root.right = node2</span><br><span class="line">    print(s.sumNumbers(root))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第129题—求根节点到叶节点数字之和&lt;/h1&gt;
&lt;p&gt;好久没更新了，最近事情太多了，天天忙的要死，英语也没来得及背，后面会慢慢恢复的，同时也会更新一大堆学习到的东西，敬请期待。&lt;/p&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://githu
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.128</title>
    <link href="www.strivezs.com/2021/06/08/LeetCode%E7%AC%AC128%E9%A2%98/"/>
    <id>www.strivezs.com/2021/06/08/LeetCode%E7%AC%AC128%E9%A2%98/</id>
    <published>2021-06-08T15:17:48.827Z</published>
    <updated>2021-06-08T15:17:48.827Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第128题—最长连续序列</h1><p>好久没更新了，最近事情太多了，天天忙的要死，英语也没来得及背，后面会慢慢恢复的，同时也会更新一大堆学习到的东西，敬请期待。</p><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><p>进阶：你可以设计并实现时间复杂度为 O(n) 的解决方案吗？</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">100</span>,<span class="number">4</span>,<span class="number">200</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：最长数字连续序列是 [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]。它的长度为 <span class="number">4</span>。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">9</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> &lt;= nums.length &lt;= <span class="number">104</span></span><br><span class="line"><span class="number">-109</span> &lt;= nums[i] &lt;= <span class="number">109</span></span><br><span class="line"></span><br><span class="line">`</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestConsecutive</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        核心思想:</span></span><br><span class="line"><span class="string">            考虑用字典存储当前长度</span></span><br><span class="line"><span class="string">            dict[a] = b 表示这个每个端点值对应连续区间的长度</span></span><br><span class="line"><span class="string">            键值是顺序从小到大的</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        max_length = <span class="number">0</span></span><br><span class="line">        res_dict = dict()</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment"># 去掉重复情况</span></span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> res_dict.keys():</span><br><span class="line">                <span class="comment"># 找到它的左端值和右端值</span></span><br><span class="line">                left_length = res_dict.get(num<span class="number">-1</span>,<span class="number">0</span>) <span class="comment"># 如果左边值存在则和左边值连续，否则返回0</span></span><br><span class="line">                right_length = res_dict.get(num+<span class="number">1</span>,<span class="number">0</span>) <span class="comment"># 如果右边值存在，则和右边值连续，否则返回0</span></span><br><span class="line">                length = left_length + right_length + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> length &gt; max_length:</span><br><span class="line">                    max_length = length</span><br><span class="line">                <span class="comment"># 更新字典值</span></span><br><span class="line">                res_dict[num] = length</span><br><span class="line">                <span class="comment"># 更新左邻域最大长度(没有的话不更新)</span></span><br><span class="line">                res_dict[num-left_length] = length</span><br><span class="line">                <span class="comment"># 更新有邻域最大长度(如果没有的话，则不更新)</span></span><br><span class="line">                res_dict[num+right_length] = length</span><br><span class="line">        <span class="keyword">return</span> max_length</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第128题—最长连续序列&lt;/h1&gt;
&lt;p&gt;好久没更新了，最近事情太多了，天天忙的要死，英语也没来得及背，后面会慢慢恢复的，同时也会更新一大堆学习到的东西，敬请期待。&lt;/p&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.127</title>
    <link href="www.strivezs.com/2021/06/03/LeetCode%E7%AC%AC127%E9%A2%98/"/>
    <id>www.strivezs.com/2021/06/03/LeetCode%E7%AC%AC127%E9%A2%98/</id>
    <published>2021-06-03T11:56:11.305Z</published>
    <updated>2021-06-03T11:56:11.305Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode第127题—单词接龙"><a href="#LeetCode第127题—单词接龙" class="headerlink" title="LeetCode第127题—单词接龙"></a>LeetCode第127题—单词接龙</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>字典 wordList 中从单词 beginWord 和 endWord 的 转换序列 是一个按下述规格形成的序列：</p><p>序列中第一个单词是 beginWord 。<br>序列中最后一个单词是 endWord 。<br>每次转换只能改变一个字母。<br>转换过程中的中间单词必须是字典 wordList 中的单词。<br>给你两个单词 beginWord 和 endWord 和一个字典 wordList ，找到从 beginWord 到 endWord 的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回 0。</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：<span class="keyword">begin</span>Word = <span class="string">"hit"</span>, <span class="keyword">end</span>Word = <span class="string">"cog"</span>, wordList = [<span class="string">"hot"</span>,<span class="string">"dot"</span>,<span class="string">"dog"</span>,<span class="string">"lot"</span>,<span class="string">"log"</span>,<span class="string">"cog"</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：一个最短转换序列是 <span class="string">"hit"</span> -&gt; <span class="string">"hot"</span> -&gt; <span class="string">"dot"</span> -&gt; <span class="string">"dog"</span> -&gt; <span class="string">"cog"</span>, 返回它的长度 <span class="number">5</span>。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：<span class="keyword">begin</span>Word = <span class="string">"hit"</span>, <span class="keyword">end</span>Word = <span class="string">"cog"</span>, wordList = [<span class="string">"hot"</span>,<span class="string">"dot"</span>,<span class="string">"dog"</span>,<span class="string">"lot"</span>,<span class="string">"log"</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：<span class="keyword">end</span>Word <span class="string">"cog"</span> 不在字典中，所以无法进行转换。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= <span class="keyword">begin</span>Word.length &lt;= <span class="number">10</span></span><br><span class="line"><span class="keyword">end</span>Word.length == <span class="keyword">begin</span>Word.length</span><br><span class="line"><span class="number">1</span> &lt;= wordList.length &lt;= <span class="number">5000</span></span><br><span class="line">wordList[i].length == <span class="keyword">begin</span>Word.length</span><br><span class="line"><span class="keyword">begin</span>Word、<span class="keyword">end</span>Word 和 wordList[i] 由小写英文字母组成</span><br><span class="line"><span class="keyword">begin</span>Word != <span class="keyword">end</span>Word</span><br><span class="line">wordList 中的所有字符串 互不相同</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p><img src="https://gitee.com/zyp521/upload_image/raw/master/OJ.png" alt="figure.1"></p><p>Python使用BFS的话，还是会超时，最长的那个过不去，这里就参考大佬的方法。<br>反正都是小写字母，每次只变动一位，干脆拿到一个节点时生成所有可能的下一个节点，新生成的节点只要再列表中就参与计算。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="使用了邻接矩阵的超时版本"><a href="#使用了邻接矩阵的超时版本" class="headerlink" title="使用了邻接矩阵的超时版本"></a>使用了邻接矩阵的超时版本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">one_chart_different</span><span class="params">(self, str1, str2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        判断输入的两个字符串是不是只有一个不一样, 默认输入的两个字符串长度相同</span></span><br><span class="line"><span class="string">        :param str1: String</span></span><br><span class="line"><span class="string">        :param str2: String</span></span><br><span class="line"><span class="string">        :return: Boolean True/False</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(str1)):</span><br><span class="line">            <span class="keyword">if</span> str1[i] != str2[i]:</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> num &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="comment"># fixme: 使用BFS进行广度优先搜索</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">BFS_memory_search</span><span class="params">(self, start, end_num, adjacent_matrix)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        使用带有记忆的BFS来进行搜索，层数逐渐增加就可以了，直到最先扩展到最终节点就结束</span></span><br><span class="line"><span class="string">        有点类似树扩展的方法,用字典来记录深度</span></span><br><span class="line"><span class="string">        :param start: Int 给点初始节点在邻接矩阵中的下标</span></span><br><span class="line"><span class="string">        :param end_num: 终止节点</span></span><br><span class="line"><span class="string">        :param adjacent_matrix: 邻接矩阵</span></span><br><span class="line"><span class="string">        :return: distance, path 返回距离和路径</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        inf = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="comment"># 初始化操作</span></span><br><span class="line">        depth_dict = &#123;&#125; <span class="comment"># 记忆深度词典</span></span><br><span class="line">        depth_dict[start] = <span class="number">1</span> <span class="comment"># 初始化</span></span><br><span class="line">        quene = [] <span class="comment"># 队列</span></span><br><span class="line">        quene.append(start)</span><br><span class="line">        n = len(adjacent_matrix) <span class="comment"># 节点个数</span></span><br><span class="line">        step = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> len(quene) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> step</span><br><span class="line">            node = quene.pop(<span class="number">0</span>) <span class="comment"># 队首出列</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> adjacent_matrix[node][j] != inf <span class="keyword">and</span> j <span class="keyword">not</span> <span class="keyword">in</span> depth_dict.keys(): <span class="comment"># 证明可以扩展</span></span><br><span class="line">                    quene.append(j) <span class="comment"># 入队</span></span><br><span class="line">                    depth_dict[j] = depth_dict[node] + <span class="number">1</span> <span class="comment"># 深度记录</span></span><br><span class="line">                <span class="keyword">if</span> j == end_num <span class="keyword">and</span> end_num <span class="keyword">in</span> depth_dict.keys():</span><br><span class="line">                    step = depth_dict[j]</span><br><span class="line">                    <span class="keyword">return</span> step</span><br><span class="line">        <span class="keyword">return</span> step</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ladderLength</span><span class="params">(self, beginWord, endWord, wordList)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type beginWord: str</span></span><br><span class="line"><span class="string">        :type endWord: str</span></span><br><span class="line"><span class="string">        :type wordList: List[str]</span></span><br><span class="line"><span class="string">        :rtype: List[List[str]]</span></span><br><span class="line"><span class="string">        根据给定的字典list构造一个图，考虑使用邻接矩阵构建一个图</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        inf = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">if</span> endWord <span class="keyword">not</span> <span class="keyword">in</span> wordList:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> beginWord <span class="keyword">not</span> <span class="keyword">in</span> wordList:</span><br><span class="line">            nodeList = [beginWord] + wordList  <span class="comment"># 构造所有节点列表</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            nodeList = wordList</span><br><span class="line">            nodeList.remove(nodeList[nodeList.index(beginWord)])</span><br><span class="line">            nodeList = [beginWord] + wordList <span class="comment"># 将初始节点至为第一个</span></span><br><span class="line">        numList = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nodeList))] <span class="comment"># 构造每个节点对应的数字状态</span></span><br><span class="line">        node_num_dict = dict(zip(nodeList,numList)) <span class="comment"># 构建对应关系的字典</span></span><br><span class="line">        num_node_dict = dict(zip(numList,nodeList)) <span class="comment"># 构造反向对应关系</span></span><br><span class="line">        adjacent_matrix = [[inf <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(nodeList))] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(nodeList))] <span class="comment"># 邻接矩阵</span></span><br><span class="line">        <span class="comment"># 构建邻接矩阵</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nodeList:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> nodeList:</span><br><span class="line">                <span class="keyword">if</span> i != j:</span><br><span class="line">                    <span class="keyword">if</span> len(i) == len(j):</span><br><span class="line">                        <span class="keyword">if</span> self.one_chart_different(i,j):</span><br><span class="line">                            adjacent_matrix[node_num_dict[i]][node_num_dict[j]] = <span class="number">1</span></span><br><span class="line">                            adjacent_matrix[node_num_dict[j]][node_num_dict[i]] = <span class="number">1</span></span><br><span class="line">        step = self.BFS_memory_search(<span class="number">0</span>,nodeList.index(endWord),adjacent_matrix)</span><br><span class="line">        <span class="keyword">if</span> step == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> step</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.ladderLength(beginWord = <span class="string">"talk"</span>, endWord = <span class="string">"tail"</span>, wordList = [<span class="string">"talk"</span>,<span class="string">"tons"</span>,<span class="string">"fall"</span>,<span class="string">"tail"</span>,<span class="string">"gale"</span>,<span class="string">"hall"</span>,<span class="string">"negs"</span>]))</span><br></pre></td></tr></table></figure><h3 id="去掉邻接矩阵直接判断的版本"><a href="#去掉邻接矩阵直接判断的版本" class="headerlink" title="去掉邻接矩阵直接判断的版本"></a>去掉邻接矩阵直接判断的版本</h3><p>别人没超时，我用Python又又超时了，我爆哭.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">one_chart_different</span><span class="params">(self, str1, str2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        判断输入的两个字符串是不是只有一个不一样, 默认输入的两个字符串长度相同</span></span><br><span class="line"><span class="string">        :param str1: String</span></span><br><span class="line"><span class="string">        :param str2: String</span></span><br><span class="line"><span class="string">        :return: Boolean True/False</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(str1)):</span><br><span class="line">            <span class="keyword">if</span> str1[i] != str2[i]:</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> num &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new_version</span><span class="params">(self, beginWord, endWord, wordList)</span>:</span></span><br><span class="line">        quene = []</span><br><span class="line">        quene.append(beginWord)</span><br><span class="line">        step = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> len(quene) != <span class="number">0</span>:</span><br><span class="line">            step += <span class="number">1</span></span><br><span class="line">            sz = len(quene)</span><br><span class="line">            <span class="keyword">while</span> sz &gt; <span class="number">0</span>:</span><br><span class="line">                hope = quene.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> hope == endWord:</span><br><span class="line">                    <span class="keyword">return</span> step</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 对每个word进行判断</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(len(wordList)):</span><br><span class="line">                    <span class="keyword">if</span> len(wordList[i]) == <span class="number">0</span> <span class="keyword">or</span> len(wordList[i]) != len(beginWord):</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="comment"># 判断差异性</span></span><br><span class="line">                    <span class="keyword">if</span> self.one_chart_different(hope,wordList[i]):</span><br><span class="line">                        quene.append(wordList[i])</span><br><span class="line">                        wordList[i] = <span class="string">""</span></span><br><span class="line">                sz -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.new_version(beginWord = <span class="string">"hit"</span>, endWord = <span class="string">"cog"</span>, wordList = [<span class="string">"hot"</span>,<span class="string">"dot"</span>,<span class="string">"dog"</span>,<span class="string">"lot"</span>,<span class="string">"log"</span>]))</span><br></pre></td></tr></table></figure></p><h3 id="参考大佬的版本"><a href="#参考大佬的版本" class="headerlink" title="参考大佬的版本"></a>参考大佬的版本</h3><p>反正都是小写字母，每次只变动一位，干脆拿到一个节点时生成所有可能的下一个节点，新生成的节点只要再列表中就参与计算。</p><p>这次终于通过了，不过耗时几百毫秒。<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">def ladderLength(self, beginWord: str, endWord: str, wordLis<span class="variable">t:</span> List[str]) -&gt; in<span class="variable">t:</span></span><br><span class="line">        <span class="keyword">if</span> endWord not in wordLis<span class="variable">t:</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">l</span> = <span class="built_in">len</span>(endWord)</span><br><span class="line">        </span><br><span class="line">            </span><br><span class="line">        <span class="keyword">ws</span> = <span class="keyword">set</span>(wordList)</span><br><span class="line">        </span><br><span class="line">        head = &#123;beginWord&#125;</span><br><span class="line">        tail = &#123;endWord&#125;</span><br><span class="line">        tmp = <span class="keyword">list</span>(<span class="string">'abcdefghijklmnopqrstuvwxyz'</span>)</span><br><span class="line">        <span class="keyword">res</span> = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(head) &gt; <span class="built_in">len</span>(tail):</span><br><span class="line">                head, tail = tail, head</span><br><span class="line">            </span><br><span class="line">            q = <span class="keyword">set</span>()</span><br><span class="line">            <span class="keyword">for</span> cur in head:</span><br><span class="line">                <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="keyword">l</span>):</span><br><span class="line">                    <span class="keyword">for</span> <span class="keyword">j</span> in tmp:</span><br><span class="line">                        word = cur[:i] + <span class="keyword">j</span> + cur[i+<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> word in tai<span class="variable">l:</span></span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">res</span> + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> word in <span class="keyword">w</span><span class="variable">s:</span></span><br><span class="line">                            q.<span class="built_in">add</span>(word)</span><br><span class="line">                            <span class="keyword">ws</span>.<span class="built_in">remove</span>(word)</span><br><span class="line">            head = q</span><br><span class="line">            <span class="keyword">res</span> += <span class="number">1</span></span><br><span class="line">                    </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LeetCode第127题—单词接龙&quot;&gt;&lt;a href=&quot;#LeetCode第127题—单词接龙&quot; class=&quot;headerlink&quot; title=&quot;LeetCode第127题—单词接龙&quot;&gt;&lt;/a&gt;LeetCode第127题—单词接龙&lt;/h1&gt;&lt;p&gt;自己代码的开
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.126</title>
    <link href="www.strivezs.com/2021/06/02/LeetCode%E7%AC%AC126%E9%A2%98/"/>
    <id>www.strivezs.com/2021/06/02/LeetCode%E7%AC%AC126%E9%A2%98/</id>
    <published>2021-06-02T08:57:37.483Z</published>
    <updated>2021-06-02T08:57:37.483Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode第126题—单词接龙II"><a href="#LeetCode第126题—单词接龙II" class="headerlink" title="LeetCode第126题—单词接龙II"></a>LeetCode第126题—单词接龙II</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>按字典 wordList 完成从单词 beginWord 到单词 endWord 转化，一个表示此过程的 转换序列 是形式上像 beginWord -&gt; s1 -&gt; s2 -&gt; … -&gt; sk 这样的单词序列，并满足：</p><p>每对相邻的单词之间仅有单个字母不同。<br>转换过程中的每个单词 si（1 &lt;= i &lt;= k）必须是字典 wordList 中的单词。注意，beginWord 不必是字典 wordList 中的单词。<br>sk == endWord<br>给你两个单词 beginWord 和 endWord ，以及一个字典 wordList 。请你找出并返回所有从 beginWord 到 endWord 的 最短转换序列 ，如果不存在这样的转换序列，返回一个空列表。每个序列都应该以单词列表 [beginWord, s1, s2, …, sk] 的形式返回。</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：<span class="keyword">begin</span>Word = <span class="string">"hit"</span>, <span class="keyword">end</span>Word = <span class="string">"cog"</span>, wordList = [<span class="string">"hot"</span>,<span class="string">"dot"</span>,<span class="string">"dog"</span>,<span class="string">"lot"</span>,<span class="string">"log"</span>,<span class="string">"cog"</span>]</span><br><span class="line">输出：[[<span class="string">"hit"</span>,<span class="string">"hot"</span>,<span class="string">"dot"</span>,<span class="string">"dog"</span>,<span class="string">"cog"</span>],[<span class="string">"hit"</span>,<span class="string">"hot"</span>,<span class="string">"lot"</span>,<span class="string">"log"</span>,<span class="string">"cog"</span>]]</span><br><span class="line">解释：存在 <span class="number">2</span> 种最短的转换序列：</span><br><span class="line"><span class="string">"hit"</span> -&gt; <span class="string">"hot"</span> -&gt; <span class="string">"dot"</span> -&gt; <span class="string">"dog"</span> -&gt; <span class="string">"cog"</span></span><br><span class="line"><span class="string">"hit"</span> -&gt; <span class="string">"hot"</span> -&gt; <span class="string">"lot"</span> -&gt; <span class="string">"log"</span> -&gt; <span class="string">"cog"</span></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：<span class="keyword">begin</span>Word = <span class="string">"hit"</span>, <span class="keyword">end</span>Word = <span class="string">"cog"</span>, wordList = [<span class="string">"hot"</span>,<span class="string">"dot"</span>,<span class="string">"dog"</span>,<span class="string">"lot"</span>,<span class="string">"log"</span>]</span><br><span class="line">输出：[]</span><br><span class="line">解释：<span class="keyword">end</span>Word <span class="string">"cog"</span> 不在字典 wordList 中，所以不存在符合要求的转换序列。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= <span class="keyword">begin</span>Word.length &lt;= <span class="number">7</span></span><br><span class="line"><span class="keyword">end</span>Word.length == <span class="keyword">begin</span>Word.length</span><br><span class="line"><span class="number">1</span> &lt;= wordList.length &lt;= <span class="number">5000</span></span><br><span class="line">wordList[i].length == <span class="keyword">begin</span>Word.length</span><br><span class="line"><span class="keyword">begin</span>Word、<span class="keyword">end</span>Word 和 wordList[i] 由小写英文字母组成</span><br><span class="line"><span class="keyword">begin</span>Word != <span class="keyword">end</span>Word</span><br><span class="line">wordList 中的所有单词 互不相同</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p><img src="https://gitee.com/zyp521/upload_image/raw/master/IMG_0713.PNG" alt="figure.1"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>回溯法做的. 不知道为什么，我写的代码，一个测试用例提交报错，我同样在本地测试一点问题都没有。不知道啥情况了，代码整体思想没有问题。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def one_chart_different(self, str1, str2):</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        判断输入的两个字符串是不是只有一个不一样, 默认输入的两个字符串长度相同</span><br><span class="line">        :param str1: String</span><br><span class="line">        :param str2: String</span><br><span class="line">        :<span class="keyword">return</span>: Boolean True/False</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="built_in">len</span>(str1)):</span><br><span class="line">            <span class="keyword">if</span> str1[i] != str2[i]:</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> num &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> False</span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> False</span><br><span class="line">        <span class="keyword">return</span> True</span><br><span class="line">    # fixme: BFS深度度优先搜索寻找最短路径 实质上就是暴力搜索  回溯法</span><br><span class="line">    res_path = dict()</span><br><span class="line">    min_dist = float(<span class="string">'inf'</span>)</span><br><span class="line">    def BFS_Search(self, start, ends, path, visited, adjacent_matrix):</span><br><span class="line">        inf = float(<span class="string">'inf'</span>)</span><br><span class="line">        # 如果满足则存储路径和距离</span><br><span class="line">        <span class="keyword">if</span> start == end<span class="variable">s:</span></span><br><span class="line">            path_node = path.<span class="keyword">split</span>(<span class="string">','</span>)</span><br><span class="line">            distance = <span class="built_in">len</span>(path_node)</span><br><span class="line">            <span class="keyword">if</span> distance &lt; self.min_dis<span class="variable">t:</span></span><br><span class="line">                self.min_dist = distance</span><br><span class="line">            <span class="keyword">if</span> path not in self.res_path.<span class="built_in">keys</span>():</span><br><span class="line">                self.res_path[path] = distance</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        n = <span class="built_in">len</span>(adjacent_matrix)</span><br><span class="line">        <span class="keyword">for</span> i in <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> adjacent_matrix[start][i] != inf <span class="built_in">and</span> not visited[i]:</span><br><span class="line">                t = path</span><br><span class="line">                path = path + <span class="string">','</span> + str(i)</span><br><span class="line">                visited[i] = True</span><br><span class="line">                self.BFS_Search(i, ends, path, visited, adjacent_matrix)</span><br><span class="line">                path = t</span><br><span class="line">                visited[i] = False</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def findLadders(self, beginWord, endWord, wordList):</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        :<span class="built_in">type</span> beginWord: str</span><br><span class="line">        :<span class="built_in">type</span> endWord: str</span><br><span class="line">        :<span class="built_in">type</span> wordLis<span class="variable">t:</span> List[str]</span><br><span class="line">        :rtype: List[List[str]]</span><br><span class="line">        根据给定的字典<span class="keyword">list</span>构造一个图，考虑使用邻接矩阵构建一个图</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        inf = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">if</span> endWord not in wordLis<span class="variable">t:</span></span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> beginWord not in wordLis<span class="variable">t:</span></span><br><span class="line">            nodeList = [beginWord] + wordList  # 构造所有节点列表</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            nodeList = wordList</span><br><span class="line">        numList = [i <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="built_in">len</span>(nodeList))] # 构造每个节点对应的数字状态</span><br><span class="line">        node_num_dict = dict(zip(nodeList,numList)) # 构建对应关系的字典</span><br><span class="line">        num_node_dict = dict(zip(numList,nodeList)) # 构造反向对应关系</span><br><span class="line">        adjacent_matrix = [[inf <span class="keyword">for</span> _ in <span class="built_in">range</span>(<span class="built_in">len</span>(nodeList))] <span class="keyword">for</span> _ in <span class="built_in">range</span>(<span class="built_in">len</span>(nodeList))] # 邻接矩阵</span><br><span class="line">        # 构建邻接矩阵</span><br><span class="line">        <span class="keyword">for</span> i in nodeLis<span class="variable">t:</span></span><br><span class="line">            <span class="keyword">for</span> <span class="keyword">j</span> in nodeLis<span class="variable">t:</span></span><br><span class="line">                <span class="keyword">if</span> i != <span class="keyword">j</span>:</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">len</span>(i) == <span class="built_in">len</span>(<span class="keyword">j</span>):</span><br><span class="line">                        <span class="keyword">if</span> self.one_chart_different(i,<span class="keyword">j</span>):</span><br><span class="line">                            adjacent_matrix[node_num_dict[i]][node_num_dict[<span class="keyword">j</span>]] = <span class="number">1</span></span><br><span class="line">                            adjacent_matrix[node_num_dict[<span class="keyword">j</span>]][node_num_dict[i]] = <span class="number">1</span></span><br><span class="line">        # 使用BFS回溯法搜索</span><br><span class="line">        visited = [False] * <span class="built_in">len</span>(adjacent_matrix)</span><br><span class="line">        visited[<span class="number">0</span>] = True</span><br><span class="line">        self.BFS_Search(nodeList.<span class="built_in">index</span>(beginWord),nodeList.<span class="built_in">index</span>(endWord),str(nodeList.<span class="built_in">index</span>(beginWord)),visited,adjacent_matrix)</span><br><span class="line">        <span class="keyword">res</span> = []</span><br><span class="line">        <span class="keyword">for</span> item in self.res_path.<span class="built_in">keys</span>():</span><br><span class="line">            <span class="keyword">if</span> self.res_path[item] == self.min_dis<span class="variable">t:</span></span><br><span class="line">                temp = []</span><br><span class="line">                path = item.<span class="keyword">split</span>(<span class="string">','</span>)</span><br><span class="line">                <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="built_in">len</span>(path)):</span><br><span class="line">                    temp.<span class="keyword">append</span>(num_node_dict[<span class="keyword">int</span>(path[i])])</span><br><span class="line">                <span class="keyword">res</span>.<span class="keyword">append</span>(temp)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">res</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    <span class="keyword">print</span>(s.findLadders(beginWord = <span class="string">"hot"</span>, endWord = <span class="string">"dog"</span>, wordList = [<span class="string">"hot"</span>,<span class="string">"dog"</span>,<span class="string">"dot"</span>]))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LeetCode第126题—单词接龙II&quot;&gt;&lt;a href=&quot;#LeetCode第126题—单词接龙II&quot; class=&quot;headerlink&quot; title=&quot;LeetCode第126题—单词接龙II&quot;&gt;&lt;/a&gt;LeetCode第126题—单词接龙II&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 基于邻接矩阵的Dijkstra算法</title>
    <link href="www.strivezs.com/2021/06/02/%E5%9F%BA%E4%BA%8E%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E7%9A%84Dijkstra%E7%AE%97%E6%B3%95/"/>
    <id>www.strivezs.com/2021/06/02/%E5%9F%BA%E4%BA%8E%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E7%9A%84Dijkstra%E7%AE%97%E6%B3%95/</id>
    <published>2021-06-02T08:52:14.412Z</published>
    <updated>2021-06-02T08:52:14.412Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于邻接矩阵的Dijkstra算法"><a href="#基于邻接矩阵的Dijkstra算法" class="headerlink" title="基于邻接矩阵的Dijkstra算法"></a>基于邻接矩阵的Dijkstra算法</h1><p>如果你的图不是邻接矩阵，转换成矩阵的形式就可以了。这里节点我就是用index表示的。  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">fixme:</span> Dijkstra算法寻找最短路径，从给定初始点到每个节点的最短路径</span></span><br><span class="line">    def Dijkstra(self, <span class="keyword">start</span>, adjacent_matrix):</span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :param start: Int 给点初始节点在邻接矩阵中的下标</span></span><br><span class="line"><span class="string">        :param adjacent_matrix: 邻接矩阵</span></span><br><span class="line"><span class="string">        :return: distance, path 返回到每个节点的最短距离，返回路径</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 初始化操作</span></span><br><span class="line">        n = <span class="keyword">len</span>(adjacent_matrix) <span class="comment"># 节点个数</span></span><br><span class="line">        inf = <span class="built_in">float</span>(<span class="string">'inf'</span>)</span><br><span class="line">        distance = [inf] * n <span class="comment"># 用于存放从某个点到其他点的最短路径长度</span></span><br><span class="line">        <span class="keyword">path</span> = [<span class="keyword">None</span>] * n <span class="comment"># 用于存放从初始点到其他点的路径</span></span><br><span class="line">        <span class="keyword">final</span> = [<span class="keyword">None</span>] * n <span class="comment"># 用于存放从初始点到其他点的最短路径</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">range</span>(n):</span><br><span class="line">            <span class="keyword">final</span>[i] = <span class="literal">False</span></span><br><span class="line">            distance[i] = adjacent_matrix[<span class="keyword">start</span>][i]</span><br><span class="line">            <span class="keyword">path</span>[i] = <span class="string">""</span>  <span class="comment"># 路径置空</span></span><br><span class="line">            <span class="keyword">if</span> distance[i] &lt; inf:</span><br><span class="line">                <span class="keyword">path</span>[i] = <span class="keyword">str</span>(i)</span><br><span class="line">        distance[<span class="keyword">start</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">final</span>[<span class="keyword">start</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 算法</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">min</span> = inf</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="keyword">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">final</span>[k] <span class="keyword">and</span> distance[k] &lt; <span class="keyword">min</span>:</span><br><span class="line">                    v = k</span><br><span class="line">                    <span class="keyword">min</span> = distance[k]</span><br><span class="line">            <span class="keyword">final</span>[v] = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="keyword">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">final</span>[k] <span class="keyword">and</span> <span class="keyword">min</span> + adjacent_matrix[v][k] &lt; distance[k]:</span><br><span class="line">                    distance[k] = <span class="keyword">min</span> + adjacent_matrix[v][k]</span><br><span class="line">                    <span class="keyword">path</span>[k] = <span class="keyword">path</span>[v] + <span class="string">','</span> + <span class="keyword">str</span>(k)</span><br><span class="line">        <span class="keyword">return</span> distance, <span class="keyword">path</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基于邻接矩阵的Dijkstra算法&quot;&gt;&lt;a href=&quot;#基于邻接矩阵的Dijkstra算法&quot; class=&quot;headerlink&quot; title=&quot;基于邻接矩阵的Dijkstra算法&quot;&gt;&lt;/a&gt;基于邻接矩阵的Dijkstra算法&lt;/h1&gt;&lt;p&gt;如果你的图不是邻接矩
      
    
    </summary>
    
    
      <category term="算法" scheme="www.strivezs.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="算法" scheme="www.strivezs.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图" scheme="www.strivezs.com/tags/%E5%9B%BE/"/>
    
      <category term="最短路径" scheme="www.strivezs.com/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    
      <category term="Dijkstra" scheme="www.strivezs.com/tags/Dijkstra/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.125</title>
    <link href="www.strivezs.com/2021/06/01/LeetCode%E7%AC%AC125%E9%A2%98/"/>
    <id>www.strivezs.com/2021/06/01/LeetCode%E7%AC%AC125%E9%A2%98/</id>
    <published>2021-06-01T11:17:18.841Z</published>
    <updated>2021-06-01T11:17:18.841Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode第125题—验证回文串"><a href="#LeetCode第125题—验证回文串" class="headerlink" title="LeetCode第125题—验证回文串"></a>LeetCode第125题—验证回文串</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p><p>说明：本题中，我们将空字符串定义为有效的回文串。<br><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: <span class="comment">"A man, a plan, a canal: Panama"</span></span><br><span class="line">输出: <span class="keyword">true</span></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: <span class="comment">"race a car"</span></span><br><span class="line">输出: <span class="keyword">false</span></span><br></pre></td></tr></table></figure></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>执行用时：88 ms, 在所有 Python3 提交中击败了7.76%的用户内存消耗：14.9 MB, 在所有 Python3 提交中击败了96.98%的用户<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">judeRange</span><span class="params">(self, c)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> c &gt;= <span class="string">'a'</span> <span class="keyword">and</span> c &lt;= <span class="string">'z'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> c &gt;= <span class="string">'A'</span> <span class="keyword">and</span> c &lt;= <span class="string">'Z'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> c &gt;=<span class="string">'0'</span> <span class="keyword">and</span> c &lt;= <span class="string">'9'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        核心思想:</span></span><br><span class="line"><span class="string">            双向指针，自动去除出字母和数字之外的字符串</span></span><br><span class="line"><span class="string">            统一将字母转换为小写</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        ends = len(s)<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> start &lt; ends:</span><br><span class="line">            flag1 = self.judeRange(s[start])</span><br><span class="line">            flag2 = self.judeRange(s[ends])</span><br><span class="line">            <span class="keyword">if</span> flag1 <span class="keyword">and</span> flag2:</span><br><span class="line">                s1 = s[start].lower()</span><br><span class="line">                s2 = s[ends].lower()</span><br><span class="line">                <span class="keyword">if</span> s1 != s2:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">                ends -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> flag1 <span class="keyword">and</span> ~flag2:</span><br><span class="line">                ends -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> ~flag1 <span class="keyword">and</span> flag2:</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">                ends -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LeetCode第125题—验证回文串&quot;&gt;&lt;a href=&quot;#LeetCode第125题—验证回文串&quot; class=&quot;headerlink&quot; title=&quot;LeetCode第125题—验证回文串&quot;&gt;&lt;/a&gt;LeetCode第125题—验证回文串&lt;/h1&gt;&lt;p&gt;自己
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.123=4</title>
    <link href="www.strivezs.com/2021/05/31/LeetCode%E7%AC%AC124%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/31/LeetCode%E7%AC%AC124%E9%A2%98/</id>
    <published>2021-05-31T14:43:30.630Z</published>
    <updated>2021-05-31T14:43:30.630Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode第123题—买卖股票的最佳时机III"><a href="#LeetCode第123题—买卖股票的最佳时机III" class="headerlink" title="LeetCode第123题—买卖股票的最佳时机III"></a>LeetCode第123题—买卖股票的最佳时机III</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</p><p>路径和 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点 root ，返回其 最大路径和 。</p><p><img src="https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg" alt="figure.1"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：最优路径是 <span class="number">2</span> -&gt; <span class="number">1</span> -&gt; <span class="number">3</span> ，路径和为 <span class="number">2</span> + <span class="number">1</span> + <span class="number">3</span> = <span class="number">6</span></span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg" alt="figure.2"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">-10</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">42</span></span><br><span class="line">解释：最优路径是 <span class="number">15</span> -&gt; <span class="number">20</span> -&gt; <span class="number">7</span> ，路径和为 <span class="number">15</span> + <span class="number">20</span> + <span class="number">7</span> = <span class="number">42</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">树中节点数目范围是 [<span class="number">1</span>, <span class="number">3</span> * <span class="number">104</span>]</span><br><span class="line"><span class="number">-1000</span> &lt;= Node.val &lt;= <span class="number">1000</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, val=<span class="number">0</span>, left=None, right=None)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.val = val</span><br><span class="line">        <span class="keyword">self</span>.left = left</span><br><span class="line">        <span class="keyword">self</span>.right = right</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="title">object</span>):</span></span><br><span class="line">    max_sum = -sys.maxsize</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs_statistic_path</span><span class="params">(<span class="keyword">self</span>, root)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="symbol">None:</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left_sum = max(<span class="number">0</span>, <span class="keyword">self</span>.dfs_statistic_path(root.left)) <span class="comment"># 统计左子树的路径总和</span></span><br><span class="line">        right_sum = max(<span class="number">0</span>, <span class="keyword">self</span>.dfs_statistic_path(root.right)) <span class="comment"># 统计右子树的路径总和</span></span><br><span class="line">        temp = left_sum + root.val + right_sum <span class="comment"># 统计当前路径总和</span></span><br><span class="line">        <span class="keyword">self</span>.max_sum = max(<span class="keyword">self</span>.max_sum, temp) <span class="comment"># 和当前最大路径进行比较</span></span><br><span class="line">        <span class="keyword">return</span> max(left_sum,right_sum) + root.val <span class="comment"># 由于不能够返回(节点不能够重复)，因此只能选择出最大的一个子树再加上当前根节点值来返回</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxPathSum</span><span class="params">(<span class="keyword">self</span>, root)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        整体上是分而治之的思想，看成一个个子问题</span></span><br><span class="line"><span class="string">        将每个节点看成是它子树的路径和(左子树和右子树)+他本来的值</span></span><br><span class="line"><span class="string">        只有子路径和大于0的时候才会去统计它</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        <span class="keyword">self</span>.dfs_statistic_path(root)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.max_sum</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name_<span class="number">_</span> == <span class="string">'__main__'</span><span class="symbol">:</span></span><br><span class="line">    root = TreeNode(<span class="number">1</span>)</span><br><span class="line">    node1 = TreeNode(<span class="number">2</span>)</span><br><span class="line">    node2 = TreeNode(<span class="number">3</span>)</span><br><span class="line">    root.left = node1</span><br><span class="line">    root.right = node2</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.maxPathSum(root))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LeetCode第123题—买卖股票的最佳时机III&quot;&gt;&lt;a href=&quot;#LeetCode第123题—买卖股票的最佳时机III&quot; class=&quot;headerlink&quot; title=&quot;LeetCode第123题—买卖股票的最佳时机III&quot;&gt;&lt;/a&gt;LeetCode
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.123</title>
    <link href="www.strivezs.com/2021/05/30/LeetCode%E7%AC%AC123%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/30/LeetCode%E7%AC%AC123%E9%A2%98/</id>
    <published>2021-05-30T11:32:17.739Z</published>
    <updated>2021-05-30T11:32:17.739Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode第123题—买卖股票的最佳时机III"><a href="#LeetCode第123题—买卖股票的最佳时机III" class="headerlink" title="LeetCode第123题—买卖股票的最佳时机III"></a>LeetCode第123题—买卖股票的最佳时机III</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入：prices = [<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：在第 <span class="number">4</span> 天（股票价格 = <span class="number">0</span>）的时候买入，在第 <span class="number">6</span> 天（股票价格 = <span class="number">3</span>）的时候卖出，这笔交易所能获得利润 = <span class="number">3</span><span class="number">-0</span> = <span class="number">3</span> 。</span><br><span class="line">     随后，在第 <span class="number">7</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">8</span> 天 （股票价格 = <span class="number">4</span>）的时候卖出，这笔交易所能获得利润 = <span class="number">4</span><span class="number">-1</span> = <span class="number">3</span> 。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：prices = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：在第 <span class="number">1</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">5</span> 天 （股票价格 = <span class="number">5</span>）的时候卖出, 这笔交易所能获得利润 = <span class="number">5</span><span class="number">-1</span> = <span class="number">4</span> 。   </span><br><span class="line">     注意你不能在第 <span class="number">1</span> 天和第 <span class="number">2</span> 天接连购买股票，之后再将它们卖出。   </span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：prices = [<span class="number">7</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>] </span><br><span class="line">输出：<span class="number">0</span> </span><br><span class="line">解释：在这个情况下, 没有交易完成, 所以最大利润为 <span class="number">0</span>。</span><br><span class="line">示例 <span class="number">4</span>：</span><br><span class="line"></span><br><span class="line">输入：prices = [<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= prices.length &lt;= <span class="number">105</span></span><br><span class="line"><span class="number">0</span> &lt;= prices[i] &lt;= <span class="number">105</span></span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>参考大佬的动态规划思想做出来的。我是菜逼我是菜逼</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/IMG_0712.PNG" alt="figure.1"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        利用动态规划</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(prices) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 五种状态初始化</span></span><br><span class="line">        dp0 = <span class="number">0</span></span><br><span class="line">        dp1 = -prices[<span class="number">0</span>]</span><br><span class="line">        dp2 = -sys.maxsize</span><br><span class="line">        dp3 = -sys.maxsize</span><br><span class="line">        dp4 = -sys.maxsize</span><br><span class="line">        <span class="comment"># 状态转移</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(prices)):</span><br><span class="line">            dp1 = max(dp1, dp0-prices[i]) <span class="comment"># 可能是从dp0买入一笔转移过来的，但是没有卖出因此为-prices[i]，也可能是一直处于dp1没有卖出</span></span><br><span class="line">            dp2 = max(dp2, dp1+prices[i]) <span class="comment"># 可能是从dp1卖出一笔转移过来的，因为卖出了所以为+prices[i],也可能是因为没有买一直停留在dp2</span></span><br><span class="line">            dp3 = max(dp3, dp2-prices[i])</span><br><span class="line">            dp4 = max(dp4, dp3+prices[i])</span><br><span class="line">        <span class="keyword">return</span> dp4 <span class="comment">#返回最终状态，就是最终的利润</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s  = Solution()</span><br><span class="line">    print(s.maxProfit([<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>]))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LeetCode第123题—买卖股票的最佳时机III&quot;&gt;&lt;a href=&quot;#LeetCode第123题—买卖股票的最佳时机III&quot; class=&quot;headerlink&quot; title=&quot;LeetCode第123题—买卖股票的最佳时机III&quot;&gt;&lt;/a&gt;LeetCode
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.122</title>
    <link href="www.strivezs.com/2021/05/29/LeetCode%E7%AC%AC122%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/29/LeetCode%E7%AC%AC122%E9%A2%98/</id>
    <published>2021-05-29T12:46:43.308Z</published>
    <updated>2021-05-29T12:46:43.308Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode第122题—买卖股票的最佳时机II"><a href="#LeetCode第122题—买卖股票的最佳时机II" class="headerlink" title="LeetCode第122题—买卖股票的最佳时机II"></a>LeetCode第122题—买卖股票的最佳时机II</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: prices = [<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="number">7</span></span><br><span class="line">解释: 在第 <span class="number">2</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">3</span> 天（股票价格 = <span class="number">5</span>）的时候卖出, 这笔交易所能获得利润 = <span class="number">5</span><span class="number">-1</span> = <span class="number">4</span> 。</span><br><span class="line">     随后，在第 <span class="number">4</span> 天（股票价格 = <span class="number">3</span>）的时候买入，在第 <span class="number">5</span> 天（股票价格 = <span class="number">6</span>）的时候卖出, 这笔交易所能获得利润 = <span class="number">6</span><span class="number">-3</span> = <span class="number">3</span> 。</span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: prices = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line">解释: 在第 <span class="number">1</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">5</span> 天 （股票价格 = <span class="number">5</span>）的时候卖出, 这笔交易所能获得利润 = <span class="number">5</span><span class="number">-1</span> = <span class="number">4</span> 。</span><br><span class="line">     注意你不能在第 <span class="number">1</span> 天和第 <span class="number">2</span> 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br><span class="line">示例 <span class="number">3</span>:</span><br><span class="line"></span><br><span class="line">输入: prices = [<span class="number">7</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">0</span></span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 <span class="number">0</span>。</span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= prices.length &lt;= <span class="number">3</span> * <span class="number">104</span></span><br><span class="line"><span class="number">0</span> &lt;= prices[i] &lt;= <span class="number">104</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        使用贪心的方法，考虑有盈利就卖的思想</span></span><br><span class="line"><span class="string">        [7, 1, 5, 6] 第二天买入，第四天卖出，收益最大（6-1），所以一般人可能会想，怎么判断不是第三天就卖出了呢? 这里就把问题复杂化了，根据题目的意思，当天卖出以后，当天还可以买入，所以其实可以第三天卖出，第三天买入，第四天又卖出（（5-1）+ （6-5） === 6 - 1）。</span></span><br><span class="line"><span class="string">        所以算法可以直接简化为只要今天比昨天大，就卖出。</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(prices)):</span><br><span class="line">            temp  = prices[i] - prices[i<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span> temp &gt; <span class="number">0</span>:</span><br><span class="line">                res += temp</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LeetCode第122题—买卖股票的最佳时机II&quot;&gt;&lt;a href=&quot;#LeetCode第122题—买卖股票的最佳时机II&quot; class=&quot;headerlink&quot; title=&quot;LeetCode第122题—买卖股票的最佳时机II&quot;&gt;&lt;/a&gt;LeetCode第12
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>向量点乘和叉乘</title>
    <link href="www.strivezs.com/2021/05/29/%E5%90%91%E9%87%8F%E7%82%B9%E4%B9%98%E5%92%8C%E5%8F%89%E4%B9%98/"/>
    <id>www.strivezs.com/2021/05/29/%E5%90%91%E9%87%8F%E7%82%B9%E4%B9%98%E5%92%8C%E5%8F%89%E4%B9%98/</id>
    <published>2021-05-29T12:46:38.214Z</published>
    <updated>2021-05-29T12:46:38.214Z</updated>
    
    <content type="html"><![CDATA[<h1 id="向量点乘和叉乘"><a href="#向量点乘和叉乘" class="headerlink" title="向量点乘和叉乘"></a>向量点乘和叉乘</h1><p>假设存在向量a和向量b:<script type="math/tex">a=[a_{1},a_{2},a_{3}],b=[b_{1},b_{2},b_{3}]</script></p><h2 id="点乘"><a href="#点乘" class="headerlink" title="点乘"></a>点乘</h2><p>向量a和向量b的点乘公式如下:</p><script type="math/tex; mode=display">a\bullet b=a_{1}b_{1}+a_{2}b_{2}+a_{3}b_{3}</script><p>要求是向量a和向量的b的维度要相同。</p><h3 id="点乘的几何意义"><a href="#点乘的几何意义" class="headerlink" title="点乘的几何意义"></a>点乘的几何意义</h3><p>点乘的几何意义是可以用来表征或者计算两个向量之间的夹角，以及在b向量或在a向量方向上的投影，公式如下:</p><script type="math/tex; mode=display">a\bullet b=a_{1}b_{1}+a_{2}b_{2}+a_{3}b_{3}=|a||b|cos \theta</script><p>首先假设一下向量构成:</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/itRaNO.png" alt="figure.1"></p><p><strong>推导过程如下</strong>:</p><ul><li>根据上图可以得到c=a-b</li><li>根据三角余弦定理可以得到: <script type="math/tex">c^{2}=a^{2}+b^{2}-2|a||b|cos \theta</script></li><li>根据c=a-b，我们可以对上式变换得到 <script type="math/tex">(a-b) \bullet(a-b)=a^{2}+b^{2}-2 a \bullet b=a^{2}+b^{2}-2|a \| b| \cos \theta</script></li><li>化简上式我们可以得到: <script type="math/tex">a\bullet b=|a||b|cos \theta</script></li><li>因此在已知向量a和向量b长度的情况下，我们可以计算得到a和b的夹角θ</li><li><script type="math/tex; mode=display">\theta=arc\: cos\left ( \frac{a \bullet b}{|a||b|} \right )</script></li></ul><p>根据上述公式就可以计算向量a和向量b之间的夹角，从而就进一步判断出这两个向量是否是同一方向，是否正交，具体对应关系如下:</p><ul><li>a·b&gt;0 : 方向基本相同，夹角在0到90度之间</li><li>a·b=0 : 两个向量正交，相互垂直</li><li>a·b&lt;0 : 方向基本相反，夹角在90度到180度之间</li></ul><h2 id="叉乘"><a href="#叉乘" class="headerlink" title="叉乘"></a>叉乘</h2><p>两个向量的叉乘，又叫向量积、叉积，叉乘的运算结果是一个向量而不是一个标量。并且<strong>两个向量的叉乘与这两个向量组成的坐标平面垂直</strong><br>同样是使用之前假设的向量a和向量b，我们可以得到向量a和向量b的叉乘公式:</p><script type="math/tex; mode=display">a \times b=\left|\begin{array}{lll}\mathrm{i} & \mathrm{j} & \mathrm{k} \\a_{1} & a_{2} & a_{3} \\b_{1} & b_{2} & b_{3}\end{array}\right|=\left(a_{2}b_{3}-a_{3}b_{2}\right) i-\left(a_{1}b_{3}-a_{3}b_{1}\right) j+\left(a_{1}b_{2}-a_{2}b_{1}\right) k</script><p>其中<script type="math/tex">i=(1,0,0),j=(0,1,0),k=(0,0,1)</script>, 其中ijk均为单位向量，最后叉乘的结果为一个向量，所以ijk要为向量，因此单纯的ab相乘再相减得到的标量。<br>因此根据上述i、j、k间的关系，有如下式子(直接用向量表示):</p><script type="math/tex; mode=display">a\times b=\left( a_{2}b_{3}-a_{3}b_{2}, a_{1}b_{3}-a_{3}b_{1}, a_{1}b_{2}-a_{2}b_{1}  \right)</script><p><strong>注意</strong>: 一个向量叉乘自己得到的是0向量，根据右手定则，叉乘得到的结果无论怎么旋转都会永远会垂直这个向量，因此只有0向量满足。</p><h3 id="叉乘的几何意义"><a href="#叉乘的几何意义" class="headerlink" title="叉乘的几何意义"></a>叉乘的几何意义</h3><p>在三维几何中，向量a和向量b的叉乘结果是一个向量，这个向量又称为法向量，它是a和b构成的平面的法向量(垂直)。</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/TRPkZC.png" alt="figure.2"></p><p>如上图。</p><p><strong>右手法则</strong>：使用右手法则来判断a×b向量的方向,如下图所示</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/ttwC2c.png" alt="figuer.3"></p><p>判断方法如下:</p><ul><li>右手手掌张开，四指并拢，大拇指垂直于四指指向的方向</li><li>伸出右手，四指弯曲，四指与A旋转到B方向一致，那么大拇指指向为C向量的方向</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;向量点乘和叉乘&quot;&gt;&lt;a href=&quot;#向量点乘和叉乘&quot; class=&quot;headerlink&quot; title=&quot;向量点乘和叉乘&quot;&gt;&lt;/a&gt;向量点乘和叉乘&lt;/h1&gt;&lt;p&gt;假设存在向量a和向量b:&lt;script type=&quot;math/tex&quot;&gt;a=[a_{1},a_{2}
      
    
    </summary>
    
    
      <category term="Math" scheme="www.strivezs.com/categories/Math/"/>
    
    
      <category term="Knowledge" scheme="www.strivezs.com/tags/Knowledge/"/>
    
      <category term="Math" scheme="www.strivezs.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.121</title>
    <link href="www.strivezs.com/2021/05/28/LeetCode%E7%AC%AC121%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/28/LeetCode%E7%AC%AC121%E9%A2%98/</id>
    <published>2021-05-28T13:14:32.685Z</published>
    <updated>2021-05-28T13:14:32.685Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第121题—买卖股票的最佳时机</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p><p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：[<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：在第 <span class="number">2</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">5</span> 天（股票价格 = <span class="number">6</span>）的时候卖出，最大利润 = <span class="number">6</span><span class="number">-1</span> = <span class="number">5</span> 。</span><br><span class="line">     注意利润不能是 <span class="number">7</span><span class="number">-1</span> = <span class="number">6</span>, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：prices = [<span class="number">7</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：在这种情况下, 没有交易完成, 所以最大利润为 <span class="number">0</span>。</span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= prices.length &lt;= <span class="number">105</span></span><br><span class="line"><span class="number">0</span> &lt;= prices[i] &lt;= <span class="number">104</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        核心思想:</span></span><br><span class="line"><span class="string">            采用动态规划的方法</span></span><br><span class="line"><span class="string">            时间复杂度为O(n)</span></span><br><span class="line"><span class="string">            记录在i之前的最大利润，并和当前利润比较</span></span><br><span class="line"><span class="string">            记录i天之前的最小值</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(prices) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">0</span>] * len(prices)</span><br><span class="line">        min_value = prices[<span class="number">0</span>]</span><br><span class="line">        max_value = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(prices)):</span><br><span class="line">            max_value = max(max_value, prices[i] - min_value) <span class="comment"># 记录最大利润</span></span><br><span class="line">            min_value = min(min_value,prices[i]) <span class="comment"># 记录第i天之前的最小值</span></span><br><span class="line">        <span class="keyword">return</span> max_value</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.maxProfit([<span class="number">7</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>]))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第121题—买卖股票的最佳时机&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.120</title>
    <link href="www.strivezs.com/2021/05/27/LeetCode%E7%AC%AC120%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/27/LeetCode%E7%AC%AC120%E9%A2%98/</id>
    <published>2021-05-27T15:39:01.452Z</published>
    <updated>2021-05-27T15:39:01.452Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第120题—三角形最小路径和</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定一个三角形 triangle ，找出自顶向下的最小路径和。</p><p>每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。</p><p>示例 1：</p><p>输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]<br>输出：11<br>解释：如下面简图所示：<br>2<br>3 4<br>6 5 7<br>4 1 8 3<br>自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。<br>示例 2：</p><p>输入：triangle = [[-10]]<br>输出：-10</p><p>提示：</p><p>1 &lt;= triangle.length &lt;= 200<br>triangle[0].length == 1<br>triangle[i].length == triangle[i - 1].length + 1<br>-104 &lt;= triangle[i][j] &lt;= 104</p><p>进阶：</p><p>你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题吗？</p><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    maxSum = sys.maxsize <span class="comment"># 设置足底啊之</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">limit_dfs</span><span class="params">(self,triangle,j,iList,curSum,curDepth,depth)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :param triangle: List[List[Int]] 所有数值</span></span><br><span class="line"><span class="string">        :param j: Int 上一个节点的纵坐标</span></span><br><span class="line"><span class="string">        :param iList: List[Int] 当前节点所在的层</span></span><br><span class="line"><span class="string">        :param curParam: Int 当前层之前的路径和</span></span><br><span class="line"><span class="string">        :param curDepth: Int 当前深度</span></span><br><span class="line"><span class="string">        :param depth: 最大深度</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        t = iList[j]</span><br><span class="line">        curSum += iList[j]</span><br><span class="line">        <span class="keyword">if</span> depth == curDepth:</span><br><span class="line">            <span class="keyword">if</span> curSum &lt; self.maxSum:</span><br><span class="line">                self.maxSum = curSum</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.limit_dfs(triangle, j, triangle[curDepth+<span class="number">1</span>], curSum, curDepth+<span class="number">1</span>, depth)</span><br><span class="line">        <span class="keyword">if</span> j+<span class="number">1</span> &lt; len(triangle[curDepth+<span class="number">1</span>]):</span><br><span class="line">            self.limit_dfs(triangle, j+<span class="number">1</span>, triangle[curDepth + <span class="number">1</span>], curSum, curDepth+<span class="number">1</span>, depth)</span><br><span class="line">    <span class="comment"># 超时版本</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span><span class="params">(self, triangle)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        核心思想:</span></span><br><span class="line"><span class="string">            每个节点，只能访问它的[i+1][j]/[i+1][j+1] 两个节点</span></span><br><span class="line"><span class="string">            考虑采用递归来判断, 有点类似限制二叉树的访问方法</span></span><br><span class="line"><span class="string">        :type triangle: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int 返回最大值</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.limit_dfs(triangle,<span class="number">0</span>,triangle[<span class="number">0</span>],<span class="number">0</span>,<span class="number">0</span>,len(triangle)<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> self.maxSum</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 参考大佬的版本</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new_version</span><span class="params">(self,triangle)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(triangle) - <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                triangle[i - <span class="number">1</span>][j] += min(triangle[i][j], triangle[i][j + <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> triangle[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.minimumTotal([[<span class="number">-1</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-3</span>]]))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第120题—三角形最小路径和&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)&lt;
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.119</title>
    <link href="www.strivezs.com/2021/05/26/LeetCode%E7%AC%AC119%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/26/LeetCode%E7%AC%AC119%E9%A2%98/</id>
    <published>2021-05-26T14:10:06.243Z</published>
    <updated>2021-05-26T14:10:06.243Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第119题—杨辉三角II</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif" alt="fiogure.1"></p><p>在杨辉三角中，每个数是它左上方和右上方的数的和。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: <span class="number">3</span></span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    res = []  <span class="comment"># 全局结果</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># fixme: 递归分治生成数组</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">genrate_iList</span><span class="params">(self, pre_list, depth, goal_depth)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        采用递归分治的方法来生成每一层的数组</span></span><br><span class="line"><span class="string">        :param pre_list: List 上一层生成的数组</span></span><br><span class="line"><span class="string">        :param depth: Int 当前深度</span></span><br><span class="line"><span class="string">        :param goal_depth: Int 目标深度</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> depth == goal_depth + <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        temp = []</span><br><span class="line">        temp.append(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(pre_list) - <span class="number">1</span>):</span><br><span class="line">            temp.append(pre_list[i] + pre_list[i + <span class="number">1</span>])</span><br><span class="line">        temp.append(<span class="number">1</span>)</span><br><span class="line">        self.res.append(temp)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 递归调用</span></span><br><span class="line">        self.genrate_iList(temp, depth + <span class="number">1</span>, goal_depth)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRow</span><span class="params">(self, numRows)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type numRows: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">            由于每个值都是它上面两个值的加和，因此考虑为分治问题</span></span><br><span class="line"><span class="string">            考虑还是使用递归的方法，因此每次传入的数组就是上一次递归生成的数组.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.res = []</span><br><span class="line">        <span class="keyword">if</span> numRows == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.res</span><br><span class="line">        self.res.append([<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">if</span> numRows == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> self.res</span><br><span class="line">        self.res.append([<span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">if</span> numRows == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> self.res</span><br><span class="line">        self.genrate_iList([<span class="number">1</span>, <span class="number">1</span>], <span class="number">3</span>, numRows+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> self.res[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第119题—杨辉三角II&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)&lt;/p
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.118</title>
    <link href="www.strivezs.com/2021/05/24/LeetCode%E7%AC%AC118%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/24/LeetCode%E7%AC%AC118%E9%A2%98/</id>
    <published>2021-05-24T09:15:39.983Z</published>
    <updated>2021-05-24T09:15:39.983Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第118题—杨辉三角</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif" alt="figure.1"></p><p>在杨辉三角中，每个数是它左上方和右上方的数的和。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: <span class="number">5</span></span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">     [<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">   [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line"> [<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第118题—杨辉三角&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.117</title>
    <link href="www.strivezs.com/2021/05/24/LeetCode%E7%AC%AC117%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/24/LeetCode%E7%AC%AC117%E9%A2%98/</id>
    <published>2021-05-24T09:02:24.802Z</published>
    <updated>2021-05-24T09:02:24.802Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第117题—填充每个节点的下一个右侧节点指针II</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定一个二叉树</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct <span class="keyword">Node</span> <span class="title">&#123;</span></span><br><span class="line"><span class="title">  int</span> val;</span><br><span class="line">  <span class="keyword">Node</span> <span class="title">*left</span>;</span><br><span class="line">  <span class="keyword">Node</span> <span class="title">*right</span>;</span><br><span class="line">  <span class="keyword">Node</span> <span class="title">*next</span>;</span><br><span class="line">&#125;</span><br><span class="line">填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</span><br><span class="line"></span><br><span class="line">初始状态下，所有 next 指针都被设置为 NULL。</span><br><span class="line"></span><br><span class="line">进阶：</span><br><span class="line"></span><br><span class="line">你只能使用常量级额外空间。</span><br><span class="line">使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/15/117_sample.png" alt="figure.1"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="literal">null</span>,<span class="number">7</span>]</span><br><span class="line">输出：[<span class="number">1</span>,#,<span class="number">2</span>,<span class="number">3</span>,#,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,#]</span><br><span class="line">解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化输出按层序遍历顺序（由 next 指针连接），<span class="string">'#'</span> 表示每层的末尾。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">树中的节点数小于 <span class="number">6000</span></span><br><span class="line"><span class="number">-100</span> &lt;= node.val &lt;= <span class="number">100</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, val=<span class="number">0</span>, left=None, right=None, <span class="keyword">next</span>=None)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.val = val</span><br><span class="line">        <span class="keyword">self</span>.left = left</span><br><span class="line">        <span class="keyword">self</span>.right = right</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">next</span> = <span class="keyword">next</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="title">object</span>):</span></span><br><span class="line">    depth_dict = dict() <span class="comment"># 深度字典</span></span><br><span class="line">    <span class="comment"># fixme:采用bfs添加深度，将相同的深度放在同一个列表中</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(<span class="keyword">self</span>, node, depth)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        采用前序遍历</span></span><br><span class="line"><span class="string">        :param node: Node</span></span><br><span class="line"><span class="string">        :param depth: Int 深度</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        <span class="keyword">if</span> node == <span class="symbol">None:</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 创建深度层次</span></span><br><span class="line">        <span class="keyword">if</span> depth <span class="keyword">not</span> <span class="keyword">in</span> <span class="keyword">self</span>.depth_dict.keys()<span class="symbol">:</span></span><br><span class="line">            <span class="keyword">self</span>.depth_dict[depth] = list()</span><br><span class="line">        <span class="comment"># 处理在同一深度的节点</span></span><br><span class="line">        <span class="symbol">else:</span></span><br><span class="line">            <span class="comment"># 带记忆的处理方式，将链尾的值指向下一个同深度的节点</span></span><br><span class="line">            <span class="keyword">self</span>.depth_dict[depth][-<span class="number">1</span>].<span class="keyword">next</span> = node</span><br><span class="line">        <span class="keyword">self</span>.depth_dict[depth].append(node) <span class="comment"># 将结点存进去</span></span><br><span class="line">        <span class="keyword">self</span>.bfs(node.left,depth+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">self</span>.bfs(node.right,depth+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(<span class="keyword">self</span>, root)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        :type root: Node</span></span><br><span class="line"><span class="string">        :rtype: Node</span></span><br><span class="line"><span class="string">        核心思想:</span></span><br><span class="line"><span class="string">            和前面一题的代码一毛一样</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            类似DFS的感觉，将节点分层，一层的都添加到一个队列中。</span></span><br><span class="line"><span class="string">            可以考虑设置深度，将一个深度的放在同一个列表中，构建深度字典</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        depth_dict = dict() <span class="comment"># 深度词典初始化</span></span><br><span class="line">        <span class="keyword">self</span>.bfs(root,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第117题—填充每个节点的下一个右侧节点指针II&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Sta
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.116</title>
    <link href="www.strivezs.com/2021/05/23/LeetCode%E7%AC%AC116%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/23/LeetCode%E7%AC%AC116%E9%A2%98/</id>
    <published>2021-05-23T13:52:45.816Z</published>
    <updated>2021-05-23T13:52:45.816Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第116题—填充每个节点的下一个右侧节点指针</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct <span class="keyword">Node</span> <span class="title">&#123;</span></span><br><span class="line"><span class="title">  int</span> val;</span><br><span class="line">  <span class="keyword">Node</span> <span class="title">*left</span>;</span><br><span class="line">  <span class="keyword">Node</span> <span class="title">*right</span>;</span><br><span class="line">  <span class="keyword">Node</span> <span class="title">*next</span>;</span><br><span class="line">&#125;</span><br><span class="line">填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</span><br><span class="line"></span><br><span class="line">初始状态下，所有 next 指针都被设置为 NULL。</span><br><span class="line"></span><br><span class="line">进阶：</span><br><span class="line"></span><br><span class="line">你只能使用常量级额外空间。</span><br><span class="line">使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2019/02/14/116_sample.png" alt="figure.1"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">输出：[<span class="number">1</span>,#,<span class="number">2</span>,<span class="number">3</span>,#,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,#]</span><br><span class="line">解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，<span class="string">'#'</span> 标志着每一层的结束。</span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">树中节点的数量少于 <span class="number">4096</span></span><br><span class="line"><span class="number">-1000</span> &lt;= node.val &lt;= <span class="number">1000</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><p>采用带记忆的前序遍历即可。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, val=<span class="number">0</span>, left=None, right=None, <span class="keyword">next</span>=None)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.val = val</span><br><span class="line">        <span class="keyword">self</span>.left = left</span><br><span class="line">        <span class="keyword">self</span>.right = right</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">next</span> = <span class="keyword">next</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="title">object</span>):</span></span><br><span class="line">    depth_dict = dict() <span class="comment"># 深度字典</span></span><br><span class="line">    <span class="comment"># fixme:采用bfs添加深度，将相同的深度放在同一个列表中</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(<span class="keyword">self</span>, node, depth)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        采用前序遍历</span></span><br><span class="line"><span class="string">        :param node: Node</span></span><br><span class="line"><span class="string">        :param depth: Int 深度</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        <span class="keyword">if</span> node == <span class="symbol">None:</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 创建深度层次</span></span><br><span class="line">        <span class="keyword">if</span> depth <span class="keyword">not</span> <span class="keyword">in</span> <span class="keyword">self</span>.depth_dict.keys()<span class="symbol">:</span></span><br><span class="line">            <span class="keyword">self</span>.depth_dict[depth] = list()</span><br><span class="line">        <span class="comment"># 处理在同一深度的节点</span></span><br><span class="line">        <span class="symbol">else:</span></span><br><span class="line">            <span class="comment"># 带记忆的处理方式，将链尾的值指向下一个同深度的节点</span></span><br><span class="line">            <span class="keyword">self</span>.depth_dict[depth][-<span class="number">1</span>].<span class="keyword">next</span> = node</span><br><span class="line">        <span class="keyword">self</span>.depth_dict[depth].append(node) <span class="comment"># 将结点存进去</span></span><br><span class="line">        <span class="keyword">self</span>.bfs(node.left,depth+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">self</span>.bfs(node.right,depth+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(<span class="keyword">self</span>, root)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        :type root: Node</span></span><br><span class="line"><span class="string">        :rtype: Node</span></span><br><span class="line"><span class="string">        核心思想:</span></span><br><span class="line"><span class="string">            完美二叉树：它的所有叶子节点都在同一层，每个父结点都有两个叶子结点</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            类似DFS的感觉，将节点分层，一层的都添加到一个队列中。</span></span><br><span class="line"><span class="string">            可以考虑设置深度，将一个深度的放在同一个列表中，构建深度字典</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        depth_dict = dict() <span class="comment"># 深度词典初始化</span></span><br><span class="line">        <span class="keyword">self</span>.bfs(root,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第116题—填充每个节点的下一个右侧节点指针&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.115</title>
    <link href="www.strivezs.com/2021/05/22/LeetCode%E7%AC%AC115%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/22/LeetCode%E7%AC%AC115%E9%A2%98/</id>
    <published>2021-05-22T11:31:58.743Z</published>
    <updated>2021-05-22T11:31:58.743Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第115题—不同的子序列</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。</p><p>字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，“ACE” 是 “ABCDE” 的一个子序列，而 “AEC” 不是）</p><p>题目数据保证答案符合 32 位带符号整数范围。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"rabbbit"</span>, t = <span class="string">"rabbit"</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line">如下图所示, 有 <span class="number">3</span> 种可以从 s 中得到 <span class="string">"rabbit"</span> 的方案。</span><br><span class="line">(上箭头符号 ^ 表示选取的字母)</span><br><span class="line">rabbbit</span><br><span class="line">^^^^ ^^</span><br><span class="line">rabbbit</span><br><span class="line">^^ ^^^^</span><br><span class="line">rabbbit</span><br><span class="line">^^^ ^^^</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"babgbag"</span>, t = <span class="string">"bag"</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：</span><br><span class="line">如下图所示, 有 <span class="number">5</span> 种可以从 s 中得到 <span class="string">"bag"</span> 的方案。 </span><br><span class="line">(上箭头符号 ^ 表示选取的字母)</span><br><span class="line">babgbag</span><br><span class="line">^^ ^</span><br><span class="line">babgbag</span><br><span class="line">^^    ^</span><br><span class="line">babgbag</span><br><span class="line">^    ^^</span><br><span class="line">babgbag</span><br><span class="line">  ^  ^^</span><br><span class="line">babgbag</span><br><span class="line">    ^^^</span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> &lt;= s.length, t.length &lt;= <span class="number">1000</span></span><br><span class="line">s 和 t 由英文字母组成</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def numDistinct(self, s, t):</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        :<span class="built_in">type</span> <span class="variable">s:</span> str</span><br><span class="line">        :<span class="built_in">type</span> <span class="variable">t:</span> str</span><br><span class="line">        :rtype: <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">        核心思想:</span><br><span class="line"></span><br><span class="line">            字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。</span><br><span class="line">            （例如，<span class="string">"ACE"</span> 是 <span class="string">"ABCDE"</span> 的一个子序列，而 <span class="string">"AEC"</span> 不是</span><br><span class="line">            动态规划和递归的区别:</span><br><span class="line">                <span class="keyword">dp</span>是一种不带重复计算的递归，想出<span class="keyword">dp</span>往往也是像想出递归那样，都需要从子问题入手，正确定义子问题，递归想出结束条件，</span><br><span class="line">                <span class="keyword">dp</span>想出base case，递归想出递归公式，<span class="keyword">dp</span>想出递推公式。递归加入记忆化后，</span><br><span class="line">                往往稍作修改，就是<span class="keyword">dp</span>的解法</span><br><span class="line"></span><br><span class="line">            考虑使用二维动态规划</span><br><span class="line">            <span class="keyword">dp</span>[i][<span class="keyword">j</span>]：从开头到s[i-<span class="number">1</span>]的子串中，出现『从开头到t[<span class="keyword">j</span>-<span class="number">1</span>]的子串』的 次数。</span><br><span class="line">            即：前i个字符的s子串中，出现前<span class="keyword">j</span>个字符的t子串的次数。</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        len_s = <span class="built_in">len</span>(s)</span><br><span class="line">        len_t = <span class="built_in">len</span>(t)</span><br><span class="line">        <span class="keyword">dp</span> = [[<span class="number">0</span>] * (len_s + <span class="number">1</span>) <span class="keyword">for</span> i in <span class="built_in">range</span>(len_t+<span class="number">1</span>)] # 生成<span class="keyword">dp</span>数组, +<span class="number">1</span>是为了考虑空串的情况</span><br><span class="line">        # <span class="keyword">print</span>(<span class="keyword">dp</span>)</span><br><span class="line">        # 当t的子字符串为空字符串时</span><br><span class="line">        <span class="keyword">for</span> i in <span class="built_in">range</span>(len_s + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">dp</span>[<span class="number">0</span>][i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="number">1</span>,len_t+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> <span class="keyword">j</span> in <span class="built_in">range</span>(<span class="number">1</span>,len_s+<span class="number">1</span>):</span><br><span class="line">                # 当s的子字符串为空字符串时</span><br><span class="line">                # s为空串，无论怎么删去元素，s还是无法变成t</span><br><span class="line">                # 处理其他情况</span><br><span class="line">                # 数组i不变<span class="keyword">j</span>+<span class="number">1</span>的时候，这时就相当于s增加了一个元素，以s=<span class="string">'ba'</span> t=<span class="string">'b'</span>为例</span><br><span class="line">                # 此时<span class="keyword">dp</span>[<span class="number">1</span>][<span class="number">2</span>]=<span class="number">1</span>，<span class="keyword">j</span>要加<span class="number">1</span>变成<span class="keyword">dp</span>[<span class="number">1</span>][<span class="number">3</span>]了，这时s就变成了<span class="string">'bab'</span></span><br><span class="line">                # 因此需要判断t[i]和新增的s[<span class="keyword">j</span>+<span class="number">1</span>]是否相等，如果不等的话，则<span class="keyword">dp</span>[i][<span class="keyword">j</span>+<span class="number">1</span>]=<span class="keyword">dp</span>[i][<span class="keyword">j</span>]</span><br><span class="line">                # 如果相等的话，同时去掉i和<span class="keyword">j</span>+<span class="number">1</span>分别看剩下的s和t是否有多个匹配，因此<span class="keyword">dp</span>[i][<span class="keyword">j</span>+<span class="number">1</span>] = <span class="keyword">dp</span>[i][<span class="keyword">j</span>]+<span class="keyword">dp</span>[i-<span class="number">1</span>][<span class="keyword">j</span>]</span><br><span class="line">                <span class="keyword">if</span> s[<span class="keyword">j</span>-<span class="number">1</span>] == t[i-<span class="number">1</span>]: # -<span class="number">1</span>是因为上面循环算上了<span class="string">""</span>字符串的情况</span><br><span class="line">                    <span class="keyword">dp</span>[i][<span class="keyword">j</span>] = <span class="keyword">dp</span>[i][<span class="keyword">j</span>-<span class="number">1</span>] + <span class="keyword">dp</span>[i-<span class="number">1</span>][<span class="keyword">j</span>-<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">dp</span>[i][<span class="keyword">j</span>] = <span class="keyword">dp</span>[i][<span class="keyword">j</span>-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">dp</span>[-<span class="number">1</span>][-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    <span class="keyword">print</span>(s.numDistinct(s = <span class="string">"rabbbit"</span>, t = <span class="string">"rabbit"</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第115题—不同的子序列&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)&lt;/p
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.114</title>
    <link href="www.strivezs.com/2021/05/21/LeetCode%E7%AC%AC114%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/21/LeetCode%E7%AC%AC114%E9%A2%98/</id>
    <published>2021-05-21T15:39:58.907Z</published>
    <updated>2021-05-21T15:39:58.907Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第114题—二叉树展开为链表</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给你二叉树的根结点 root ，请你将它展开为一个单链表：</p><p>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。<br>展开后的单链表应该与二叉树 先序遍历 顺序相同。</p><p><img src="https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg" alt="figure.1"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="number">6</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="literal">null</span>,<span class="number">2</span>,<span class="literal">null</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="number">5</span>,<span class="literal">null</span>,<span class="number">6</span>]</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">0</span>]</span><br><span class="line">输出：[<span class="number">0</span>]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">树中结点数在范围 [<span class="number">0</span>, <span class="number">2000</span>] 内</span><br><span class="line"><span class="number">-100</span> &lt;= Node.val &lt;= <span class="number">100</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val=<span class="number">0</span>, left=None, right=None)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flatten</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.flatten(root.left)</span><br><span class="line">        self.flatten(root.right)</span><br><span class="line"></span><br><span class="line">        right = root.right</span><br><span class="line">        <span class="comment"># 将左子树替换掉右子树</span></span><br><span class="line">        root.right = root.left</span><br><span class="line">        root.left = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 找到右子树最右的节点，接上原右子树</span></span><br><span class="line">        p = root</span><br><span class="line">        <span class="keyword">while</span> (p.right != <span class="literal">None</span>):</span><br><span class="line">            p = p.right</span><br><span class="line">        p.right = right</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第114题—二叉树展开为链表&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)&lt;
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
</feed>
