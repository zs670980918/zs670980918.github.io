<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>StriveZs的博客</title>
  
  <subtitle>Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="www.strivezs.com/"/>
  <updated>2021-03-19T04:56:20.914Z</updated>
  <id>www.strivezs.com/</id>
  
  <author>
    <name>StriveZs</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode No.59</title>
    <link href="www.strivezs.com/2021/03/19/LeetCode%E7%AC%AC%E4%BA%94%E5%8D%81%E4%B9%9D%E9%A2%98/"/>
    <id>www.strivezs.com/2021/03/19/LeetCode%E7%AC%AC%E4%BA%94%E5%8D%81%E4%B9%9D%E9%A2%98/</id>
    <published>2021-03-19T04:56:20.914Z</published>
    <updated>2021-03-19T04:56:20.914Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode第五十九题"><a href="#LeetCode第五十九题" class="headerlink" title="LeetCode第五十九题"></a>LeetCode第五十九题</h1><p>直接拿54题的代码改的，嘿嘿省事了。  </p><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。</p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg" alt="figure.1"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：n = <span class="number">3</span></span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">8</span>,<span class="number">9</span>,<span class="number">4</span>],[<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>]]</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：n = <span class="number">1</span></span><br><span class="line">输出：[[<span class="number">1</span>]]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= n &lt;= <span class="number">20</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateMatrix</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">                类似54题提到的访问方式</span></span><br><span class="line"><span class="string">                首先要先将n×n的数组初始化全为0</span></span><br><span class="line"><span class="string">                然后正常采用由右→下→上→左→右的顺序访问即可</span></span><br><span class="line"><span class="string">                如果触碰到不为0的数或者超出边界，则重新调整方向</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        matrix = [] <span class="comment"># 初始化数组</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            matrix.append([<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)])</span><br><span class="line">        <span class="comment"># print(matrix)</span></span><br><span class="line">        direction = <span class="string">'right'</span> <span class="comment"># 方向初始为右，按照由右→下→上→左→右的顺序进行改变</span></span><br><span class="line">        num = <span class="number">1</span> <span class="comment"># 技术菌  从1开始到n^2结束</span></span><br><span class="line">        i,j = <span class="number">0</span>,<span class="number">0</span> <span class="comment"># 初始坐标</span></span><br><span class="line">        row = len(matrix) <span class="comment"># 行数</span></span><br><span class="line">        column = len(matrix[<span class="number">0</span>]) <span class="comment"># 列数</span></span><br><span class="line">        sum = row * column <span class="comment"># 矩阵元素总个数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> num &lt;= sum:</span><br><span class="line">            <span class="comment"># 先处理超出边界情况:</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= row: <span class="comment"># 行数超了</span></span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">                direction = <span class="string">'left'</span></span><br><span class="line">            <span class="keyword">elif</span> i &lt; <span class="number">0</span>: <span class="comment"># 行数不够</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">                direction = <span class="string">'right'</span></span><br><span class="line">            <span class="keyword">elif</span> j &lt; <span class="number">0</span>: <span class="comment"># 列数不够</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">                direction = <span class="string">'up'</span></span><br><span class="line">            <span class="keyword">elif</span> j &gt;= column: <span class="comment"># 列出超了</span></span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                direction = <span class="string">'down'</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 在处理一下到达101的情况</span></span><br><span class="line">            <span class="keyword">if</span> matrix[i][j] != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> direction == <span class="string">'right'</span>:</span><br><span class="line">                    direction = <span class="string">'down'</span></span><br><span class="line">                    j -= <span class="number">1</span></span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> direction == <span class="string">'down'</span>:</span><br><span class="line">                    direction = <span class="string">'left'</span></span><br><span class="line">                    i -= <span class="number">1</span></span><br><span class="line">                    j -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> direction == <span class="string">'left'</span>:</span><br><span class="line">                    direction = <span class="string">'up'</span></span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                    i -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> direction == <span class="string">'up'</span>:</span><br><span class="line">                    direction = <span class="string">'right'</span></span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 访问</span></span><br><span class="line">            matrix[i][j] = num</span><br><span class="line">            num += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 处理下标</span></span><br><span class="line">            <span class="keyword">if</span> direction == <span class="string">'right'</span>:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> direction == <span class="string">'down'</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> direction == <span class="string">'left'</span>:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> direction == <span class="string">'up'</span>:</span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> matrix</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.generateMatrix(<span class="number">1</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LeetCode第五十九题&quot;&gt;&lt;a href=&quot;#LeetCode第五十九题&quot; class=&quot;headerlink&quot; title=&quot;LeetCode第五十九题&quot;&gt;&lt;/a&gt;LeetCode第五十九题&lt;/h1&gt;&lt;p&gt;直接拿54题的代码改的，嘿嘿省事了。  &lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.57</title>
    <link href="www.strivezs.com/2021/03/18/LeetCode%E7%AC%AC%E4%BA%94%E5%8D%81%E4%B8%83%E9%A2%98/"/>
    <id>www.strivezs.com/2021/03/18/LeetCode%E7%AC%AC%E4%BA%94%E5%8D%81%E4%B8%83%E9%A2%98/</id>
    <published>2021-03-18T10:48:42.511Z</published>
    <updated>2021-03-18T10:48:42.511Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode第五十七题"><a href="#LeetCode第五十七题" class="headerlink" title="LeetCode第五十七题"></a>LeetCode第五十七题</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个 无重叠的 ，按照区间起始端点排序的区间列表。</p><p>在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：<span class="built_in">int</span>ervals = [[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">6</span>,<span class="number">9</span>]], newInterval = [<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">9</span>]]</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：<span class="built_in">int</span>ervals = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">7</span>],[<span class="number">8</span>,<span class="number">10</span>],[<span class="number">12</span>,<span class="number">16</span>]], newInterval = [<span class="number">4</span>,<span class="number">8</span>]</span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">10</span>],[<span class="number">12</span>,<span class="number">16</span>]]</span><br><span class="line">解释：这是因为新的区间 [<span class="number">4</span>,<span class="number">8</span>] 与 [<span class="number">3</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">7</span>],[<span class="number">8</span>,<span class="number">10</span>] 重叠。</span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：<span class="built_in">int</span>ervals = [], newInterval = [<span class="number">5</span>,<span class="number">7</span>]</span><br><span class="line">输出：[[<span class="number">5</span>,<span class="number">7</span>]]</span><br><span class="line">示例 <span class="number">4</span>：</span><br><span class="line"></span><br><span class="line">输入：<span class="built_in">int</span>ervals = [[<span class="number">1</span>,<span class="number">5</span>]], newInterval = [<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">5</span>]]</span><br><span class="line">示例 <span class="number">5</span>：</span><br><span class="line"></span><br><span class="line">输入：<span class="built_in">int</span>ervals = [[<span class="number">1</span>,<span class="number">5</span>]], newInterval = [<span class="number">2</span>,<span class="number">7</span>]</span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">7</span>]]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> &lt;= <span class="built_in">int</span>ervals.length &lt;= <span class="number">104</span></span><br><span class="line"><span class="built_in">int</span>ervals[i].length == <span class="number">2</span></span><br><span class="line"><span class="number">0</span> &lt;= <span class="built_in">int</span>ervals[i][<span class="number">0</span>] &lt;= <span class="built_in">int</span>ervals[i][<span class="number">1</span>] &lt;= <span class="number">105</span></span><br><span class="line"><span class="built_in">int</span>ervals 根据 <span class="built_in">int</span>ervals[i][<span class="number">0</span>] 按 升序 排列</span><br><span class="line">newInterval.length == <span class="number">2</span></span><br><span class="line"><span class="number">0</span> &lt;= newInterval[<span class="number">0</span>] &lt;= newInterval[<span class="number">1</span>] &lt;= <span class="number">105</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def insert(self, intervals, newInterval):</span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        :type intervals: List<span class="subst">[List[int]</span>]</span></span><br><span class="line"><span class="string">        :type newInterval: List<span class="subst">[int]</span></span></span><br><span class="line"><span class="string">        :rtype: List<span class="subst">[List[int]</span>]</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">                就是no.56的变形，只需要在开头把需要插入的区间添加到列表中</span></span><br><span class="line"><span class="string">                然后在进行56题的操作即可</span></span><br><span class="line"><span class="string">                依次判断:</span></span><br><span class="line"><span class="string">                 1. 有交集且全包含的情况 A包含B和B包含A</span></span><br><span class="line"><span class="string">                 2. 有交集且左包含的情况 <span class="subst">[1,4]</span> <span class="subst">[0,1]</span>  这个可以先对初始情况进行排序来解决</span></span><br><span class="line"><span class="string">                 3. 有交集且右包含的情况 <span class="subst">[0,2]</span> <span class="subst">[1,3]</span></span></span><br><span class="line"><span class="string">                 3.如果两个区间没有交集，则放入result</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        intervals.append(newInterval)</span><br><span class="line">        intervals = sorted(intervals)</span><br><span class="line">        result = <span class="comment">[]</span></span><br><span class="line">        temp = intervals<span class="comment">[0]</span></span><br><span class="line">        i = 1</span><br><span class="line">        while i &lt; len(intervals):</span><br><span class="line">            # 有交集且全包含的情况 A包含B</span><br><span class="line">            if temp<span class="comment">[0]</span> &gt;= intervals<span class="comment">[i]</span><span class="comment">[0]</span> and temp<span class="comment">[1]</span> &lt;= intervals<span class="comment">[i]</span><span class="comment">[1]</span>:</span><br><span class="line">                temp = intervals<span class="comment">[i]</span></span><br><span class="line">                i += 1</span><br><span class="line">            # 有交集且全包含的情况 B包含A</span><br><span class="line">            elif temp<span class="comment">[0]</span> &lt;= intervals<span class="comment">[i]</span><span class="comment">[0]</span> and temp<span class="comment">[1]</span> &gt;= intervals<span class="comment">[i]</span><span class="comment">[1]</span>:</span><br><span class="line">                i += 1</span><br><span class="line">            # 有交集且右包含</span><br><span class="line">            elif temp<span class="comment">[1]</span> &gt;= intervals<span class="comment">[i]</span><span class="comment">[0]</span>:</span><br><span class="line">                tt = <span class="comment">[]</span></span><br><span class="line">                tt.append(temp<span class="comment">[0]</span>)</span><br><span class="line">                tt.append(intervals<span class="comment">[i]</span><span class="comment">[1]</span>)</span><br><span class="line">                temp = tt</span><br><span class="line">                i += 1</span><br><span class="line">            else:  # 下一个</span><br><span class="line">                result.append(temp)</span><br><span class="line">                temp = intervals<span class="comment">[i]</span></span><br><span class="line">                i += 1</span><br><span class="line">        result.append(temp)</span><br><span class="line">        return result</span><br><span class="line"></span><br><span class="line">if __name__ == '__main__':</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.insert(intervals = <span class="comment">[<span class="comment">[1,3]</span>,<span class="comment">[6,9]</span>]</span>, newInterval = <span class="comment">[2,5]</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LeetCode第五十七题&quot;&gt;&lt;a href=&quot;#LeetCode第五十七题&quot; class=&quot;headerlink&quot; title=&quot;LeetCode第五十七题&quot;&gt;&lt;/a&gt;LeetCode第五十七题&lt;/h1&gt;&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https:/
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.58</title>
    <link href="www.strivezs.com/2021/03/18/LeetCode%E7%AC%AC%E4%BA%94%E5%8D%81%E5%85%AB%E9%A2%98/"/>
    <id>www.strivezs.com/2021/03/18/LeetCode%E7%AC%AC%E4%BA%94%E5%8D%81%E5%85%AB%E9%A2%98/</id>
    <published>2021-03-18T10:48:38.874Z</published>
    <updated>2021-03-18T10:48:38.874Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode第五十八题"><a href="#LeetCode第五十八题" class="headerlink" title="LeetCode第五十八题"></a>LeetCode第五十八题</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个字符串 s，由若干单词组成，单词之间用空格隔开。返回字符串中最后一个单词的长度。如果不存在最后一个单词，请返回 0 。</p><p>单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"Hello World"</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">" "</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= s.length &lt;= <span class="number">104</span></span><br><span class="line">s 仅有英文字母和空格 ' ' 组成</span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def lengthOfLastWord(self, s):</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        :<span class="built_in">type</span> <span class="variable">s:</span> str</span><br><span class="line">        :rtype: <span class="keyword">int</span></span><br><span class="line">        核心思想:</span><br><span class="line">                <span class="keyword">python</span>方法直接用<span class="keyword">split</span>(<span class="string">' '</span>)对字符串进行划分，返回<span class="keyword">list</span>[-<span class="number">1</span>]的长度即可</span><br><span class="line">                注意考虑全是空格的情况</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        <span class="keyword">res</span> = s.<span class="keyword">split</span>(<span class="string">' '</span>)</span><br><span class="line">        #print(<span class="keyword">res</span>)</span><br><span class="line">        <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="keyword">res</span>)):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">res</span>[<span class="built_in">len</span>(<span class="keyword">res</span>)-i-<span class="number">1</span>] != <span class="string">''</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">len</span>(<span class="keyword">res</span>[<span class="built_in">len</span>(<span class="keyword">res</span>)-i-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    <span class="keyword">print</span>(s.lengthOfLastWord(s = <span class="string">"     "</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LeetCode第五十八题&quot;&gt;&lt;a href=&quot;#LeetCode第五十八题&quot; class=&quot;headerlink&quot; title=&quot;LeetCode第五十八题&quot;&gt;&lt;/a&gt;LeetCode第五十八题&lt;/h1&gt;&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https:/
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.56</title>
    <link href="www.strivezs.com/2021/03/16/LeetCode%E7%AC%AC%E4%BA%94%E5%8D%81%E5%85%AD%E9%A2%98/"/>
    <id>www.strivezs.com/2021/03/16/LeetCode%E7%AC%AC%E4%BA%94%E5%8D%81%E5%85%AD%E9%A2%98/</id>
    <published>2021-03-16T06:46:33.190Z</published>
    <updated>2021-03-16T06:46:33.190Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode第五十六题"><a href="#LeetCode第五十六题" class="headerlink" title="LeetCode第五十六题"></a>LeetCode第五十六题</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line">输入：<span class="built_in">int</span>ervals = [[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">6</span>],[<span class="number">8</span>,<span class="number">10</span>],[<span class="number">15</span>,<span class="number">18</span>]]</span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">6</span>],[<span class="number">8</span>,<span class="number">10</span>],[<span class="number">15</span>,<span class="number">18</span>]]</span><br><span class="line">解释：区间 [<span class="number">1</span>,<span class="number">3</span>] 和 [<span class="number">2</span>,<span class="number">6</span>] 重叠, 将它们合并为 [<span class="number">1</span>,<span class="number">6</span>].</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：<span class="built_in">int</span>ervals = [[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">5</span>]]</span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">5</span>]]</span><br><span class="line">解释：区间 [<span class="number">1</span>,<span class="number">4</span>] 和 [<span class="number">4</span>,<span class="number">5</span>] 可被视为重叠区间。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= <span class="built_in">int</span>ervals.length &lt;= <span class="number">104</span></span><br><span class="line"><span class="built_in">int</span>ervals[i].length == <span class="number">2</span></span><br><span class="line"><span class="number">0</span> &lt;= starti &lt;= endi &lt;= <span class="number">104</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def merge(self, intervals):</span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        :type intervals: List<span class="subst">[List[int]</span>]</span></span><br><span class="line"><span class="string">        :rtype: List<span class="subst">[List[int]</span>]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">                依次判断:</span></span><br><span class="line"><span class="string">                 1. 有交集且全包含的情况 A包含B和B包含A</span></span><br><span class="line"><span class="string">                 2. 有交集且左包含的情况 <span class="subst">[1,4]</span> <span class="subst">[0,1]</span>  这个可以先对初始情况进行排序来解决</span></span><br><span class="line"><span class="string">                 3. 有交集且右包含的情况 <span class="subst">[0,2]</span> <span class="subst">[1,3]</span></span></span><br><span class="line"><span class="string">                 3.如果两个区间没有交集，则放入result</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        intervals = sorted(intervals)</span><br><span class="line">        result = <span class="comment">[]</span></span><br><span class="line">        temp = intervals<span class="comment">[0]</span></span><br><span class="line">        i = 1</span><br><span class="line">        while i &lt; len(intervals):</span><br><span class="line">            # 有交集且全包含的情况 A包含B</span><br><span class="line">            if temp<span class="comment">[0]</span> &gt;= intervals<span class="comment">[i]</span><span class="comment">[0]</span> and temp<span class="comment">[1]</span> &lt;= intervals<span class="comment">[i]</span><span class="comment">[1]</span>:</span><br><span class="line">                temp = intervals<span class="comment">[i]</span></span><br><span class="line">                i += 1</span><br><span class="line">            # 有交集且全包含的情况 B包含A</span><br><span class="line">            elif temp<span class="comment">[0]</span> &lt;= intervals<span class="comment">[i]</span><span class="comment">[0]</span> and temp<span class="comment">[1]</span> &gt;= intervals<span class="comment">[i]</span><span class="comment">[1]</span>:</span><br><span class="line">                i += 1</span><br><span class="line">            # 有交集且右包含</span><br><span class="line">            elif temp<span class="comment">[1]</span> &gt;= intervals<span class="comment">[i]</span><span class="comment">[0]</span>:</span><br><span class="line">                tt = <span class="comment">[]</span></span><br><span class="line">                tt.append(temp<span class="comment">[0]</span>)</span><br><span class="line">                tt.append(intervals<span class="comment">[i]</span><span class="comment">[1]</span>)</span><br><span class="line">                temp = tt</span><br><span class="line">                i += 1</span><br><span class="line">            else: # 下一个</span><br><span class="line">                result.append(temp)</span><br><span class="line">                temp = intervals<span class="comment">[i]</span></span><br><span class="line">                i += 1</span><br><span class="line">        result.append(temp)</span><br><span class="line">        return result</span><br><span class="line"></span><br><span class="line">if __name__ == '__main__':</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.merge(intervals = <span class="comment">[<span class="comment">[1,4]</span>,<span class="comment">[0,1]</span>]</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LeetCode第五十六题&quot;&gt;&lt;a href=&quot;#LeetCode第五十六题&quot; class=&quot;headerlink&quot; title=&quot;LeetCode第五十六题&quot;&gt;&lt;/a&gt;LeetCode第五十六题&lt;/h1&gt;&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https:/
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.55</title>
    <link href="www.strivezs.com/2021/03/15/LeetCode%E7%AC%AC%E4%BA%94%E5%8D%81%E4%BA%94%E9%A2%98/"/>
    <id>www.strivezs.com/2021/03/15/LeetCode%E7%AC%AC%E4%BA%94%E5%8D%81%E4%BA%94%E9%A2%98/</id>
    <published>2021-03-15T09:27:22.643Z</published>
    <updated>2021-03-15T09:27:22.643Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode第五十五题"><a href="#LeetCode第五十五题" class="headerlink" title="LeetCode第五十五题"></a>LeetCode第五十五题</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：可以先跳 <span class="number">1</span> 步，从下标 <span class="number">0</span> 到达下标 <span class="number">1</span>, 然后再从下标 <span class="number">1</span> 跳 <span class="number">3</span> 步到达最后一个下标。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：无论怎样，总会到达下标为 <span class="number">3</span> 的位置。但该下标的最大跳跃长度是 <span class="number">0</span> ， 所以永远不可能到达最后一个下标。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= nums.length &lt;= <span class="number">3</span> * <span class="number">104</span></span><br><span class="line"><span class="number">0</span> &lt;= nums[i] &lt;= <span class="number">105</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># 动态规划——超时版本</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">timeout_canJump</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">                类似之前做过的那道题《跳跃游戏II》，同样可以用动态规划来进行代码的编写</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dp = [len(nums)+<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums))]  <span class="comment"># 每个dp的值表示的是到当前位置的最小步数</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span> <span class="comment"># 表示到达第一个位置的最小步数为0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)): <span class="comment"># 不算初始位置，选择从i之前位置到i的最短距离</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,i):</span><br><span class="line">                <span class="keyword">if</span> nums[j] &gt;= i-j: <span class="comment"># 表示可以一步从j到i</span></span><br><span class="line">                    dp[i] = min(dp[i],dp[j]+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> dp[<span class="number">-1</span>] != len(nums)+<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="comment"># AC版本</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        核心思想:</span></span><br><span class="line"><span class="string">                上个动态规划版本成功超时了，下面考虑用其他的办法</span></span><br><span class="line"><span class="string">                其他的办法, 分为以下几点:</span></span><br><span class="line"><span class="string">                    1) 从右往左考虑</span></span><br><span class="line"><span class="string">                    2) 找到为0的位置，判断0之前是否有元素能够跨过0，如果没有则返回False</span></span><br><span class="line"><span class="string">                    3) 除0之外的位置，由于不需要像跳跃游戏II中考虑最短步数，因此均可以到达</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> <span class="keyword">not</span> <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">1</span> <span class="keyword">and</span> nums[<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        i = len(nums)<span class="number">-2</span> <span class="comment"># 从最后一个元素考虑</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> nums[i] == <span class="number">0</span>:</span><br><span class="line">                flag = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,i):</span><br><span class="line">                    <span class="keyword">if</span> nums[j] &gt; i-j:</span><br><span class="line">                        flag = <span class="literal">False</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> flag:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.canJump(nums = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>]))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LeetCode第五十五题&quot;&gt;&lt;a href=&quot;#LeetCode第五十五题&quot; class=&quot;headerlink&quot; title=&quot;LeetCode第五十五题&quot;&gt;&lt;/a&gt;LeetCode第五十五题&lt;/h1&gt;&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https:/
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.54</title>
    <link href="www.strivezs.com/2021/03/14/LeetCode%E7%AC%AC%E4%BA%94%E5%8D%81%E5%9B%9B%E9%A2%98/"/>
    <id>www.strivezs.com/2021/03/14/LeetCode%E7%AC%AC%E4%BA%94%E5%8D%81%E5%9B%9B%E9%A2%98/</id>
    <published>2021-03-14T07:37:32.480Z</published>
    <updated>2021-03-14T07:37:32.480Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode第五十四题"><a href="#LeetCode第五十四题" class="headerlink" title="LeetCode第五十四题"></a>LeetCode第五十四题</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Folk :)</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg" alt="figure.1"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">示例 <span class="number">2</span>：</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg" alt="figure.2"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],[<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">m == matrix.length</span><br><span class="line">n == matrix[i].length</span><br><span class="line"><span class="number">1</span> &lt;= m, n &lt;= <span class="number">10</span></span><br><span class="line"><span class="number">-100</span> &lt;= matrix[i][j] &lt;= <span class="number">100</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LeetCode第五十四题&quot;&gt;&lt;a href=&quot;#LeetCode第五十四题&quot; class=&quot;headerlink&quot; title=&quot;LeetCode第五十四题&quot;&gt;&lt;/a&gt;LeetCode第五十四题&lt;/h1&gt;&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https:/
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.53</title>
    <link href="www.strivezs.com/2021/03/13/LeetCode%E7%AC%AC%E4%BA%94%E5%8D%81%E4%B8%89%E9%A2%98/"/>
    <id>www.strivezs.com/2021/03/13/LeetCode%E7%AC%AC%E4%BA%94%E5%8D%81%E4%B8%89%E9%A2%98/</id>
    <published>2021-03-13T15:25:07.216Z</published>
    <updated>2021-03-13T15:25:07.216Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode第五十三题"><a href="#LeetCode第五十三题" class="headerlink" title="LeetCode第五十三题"></a>LeetCode第五十三题</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Folk :)</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-3</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-5</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：连续子数组 [<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>] 的和最大，为 <span class="number">6</span> 。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">0</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">示例 <span class="number">4</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">-1</span>]</span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">示例 <span class="number">5</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">-100000</span>]</span><br><span class="line">输出：<span class="number">-100000</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= nums.length &lt;= <span class="number">3</span> * <span class="number">104</span></span><br><span class="line"><span class="number">-105</span> &lt;= nums[i] &lt;= <span class="number">105</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def maxSubArray(self, nums):</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        :<span class="built_in">type</span> num<span class="variable">s:</span> List[<span class="keyword">int</span>]</span><br><span class="line">        :rtype: <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">        核心思想: <span class="number">1</span>. 暴力法：遍历所有情况吧，采用适当的剪枝</span><br><span class="line">                <span class="number">2</span>. 动态规划：突然想到可以采用动态规划的方法</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        # 本题就采用动态规划的方法</span><br><span class="line">        <span class="keyword">dp</span> = [<span class="number">0</span> <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="built_in">len</span>(nums))]</span><br><span class="line">        <span class="keyword">dp</span>[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        result = <span class="keyword">dp</span>[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">dp</span>[i] = <span class="built_in">max</span>(<span class="keyword">dp</span>[i-<span class="number">1</span>]+nums[i],nums[i])</span><br><span class="line">            result = <span class="built_in">max</span>(result,<span class="keyword">dp</span>[i])</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    <span class="keyword">print</span>(s.maxSubArray(nums = [<span class="number">1</span>]))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LeetCode第五十三题&quot;&gt;&lt;a href=&quot;#LeetCode第五十三题&quot; class=&quot;headerlink&quot; title=&quot;LeetCode第五十三题&quot;&gt;&lt;/a&gt;LeetCode第五十三题&lt;/h1&gt;&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https:/
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.52</title>
    <link href="www.strivezs.com/2021/03/12/LeetCode%E7%AC%AC%E4%BA%94%E5%8D%81%E4%BA%8C%E9%A2%98/"/>
    <id>www.strivezs.com/2021/03/12/LeetCode%E7%AC%AC%E4%BA%94%E5%8D%81%E4%BA%8C%E9%A2%98/</id>
    <published>2021-03-12T11:44:18.240Z</published>
    <updated>2021-03-12T11:44:18.240Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第五十二题</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Folk :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 n ，返回 n 皇后问题 不同的解决方案的数量。</p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/queens.jpg" alt="figure.1"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：n = <span class="number">4</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：如上图所示，<span class="number">4</span> 皇后问题存在两个不同的解法。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：n = <span class="number">1</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= n &lt;= <span class="number">9</span></span><br><span class="line">皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><p>仅对上一个代码进行简单的修改，即可以得到本题对应的代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">judge</span><span class="params">(self,QiPan, placeI, placeJ, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :arg 判断新位置的皇后是否合法</span></span><br><span class="line"><span class="string">        :type QiPan: List[List[str]]</span></span><br><span class="line"><span class="string">        :type placeI: int</span></span><br><span class="line"><span class="string">        :type placeJ: int</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype : Boolean</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 剪枝判断法： 由于给定当前i和j，又因为是从左上往右下依次放置皇后的，因此不需要判断行数和列数同时大于当前位置的元素</span></span><br><span class="line">        flag = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="comment"># 去掉还没有放置皇后的位置</span></span><br><span class="line">                <span class="keyword">if</span> i &gt; placeI <span class="keyword">and</span> j &gt; placeJ:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 判断和n在同一行上的位置</span></span><br><span class="line">                <span class="keyword">if</span> i == placeI:</span><br><span class="line">                    <span class="keyword">if</span> QiPan[i][j] == <span class="string">'Q'</span>:</span><br><span class="line">                        flag = <span class="literal">False</span></span><br><span class="line">                        <span class="keyword">return</span> flag</span><br><span class="line">                <span class="comment"># 判断和n在同一列上的位置</span></span><br><span class="line">                <span class="keyword">if</span> j == placeJ:</span><br><span class="line">                    <span class="keyword">if</span> QiPan[i][j] == <span class="string">'Q'</span>:</span><br><span class="line">                        flag = <span class="literal">False</span></span><br><span class="line">                        <span class="keyword">return</span> flag</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 判断斜线上的位置, 可以用过计算斜率来确定是否在一条斜线上</span></span><br><span class="line">                <span class="keyword">if</span> i != placeI <span class="keyword">and</span> j != placeJ:</span><br><span class="line">                    <span class="keyword">if</span> abs(i - placeI)/abs(j - placeJ) == <span class="number">1</span>:</span><br><span class="line">                        <span class="keyword">if</span> QiPan[i][j] == <span class="string">'Q'</span>:</span><br><span class="line">                            flag = <span class="literal">False</span></span><br><span class="line">                            <span class="keyword">return</span> flag</span><br><span class="line">        <span class="keyword">return</span> flag</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">totalNQueens</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[str]]</span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">                首先想到的是回溯法，通过回溯法来遍历所有的可能，如果满足条件则选择该情况，否则撤回选择</span></span><br><span class="line"><span class="string">                def backtrack(path, selected):</span></span><br><span class="line"><span class="string">                    if 满足停止条件：</span></span><br><span class="line"><span class="string">                        res.append(path)</span></span><br><span class="line"><span class="string">                    for 选择 in 选择列表：</span></span><br><span class="line"><span class="string">                        做出选择</span></span><br><span class="line"><span class="string">                        递归执行backtrack</span></span><br><span class="line"><span class="string">                            满足则return True</span></span><br><span class="line"><span class="string">                        如果不满足要求就撤销选择</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        QiPan = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            QiPan.append([<span class="string">'.'</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)])</span><br><span class="line">        <span class="comment"># print(QiPan)</span></span><br><span class="line"></span><br><span class="line">        res = [] <span class="comment"># 存储结果棋盘</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(QiPan, i, n)</span>:</span></span><br><span class="line">            <span class="string">"""</span></span><br><span class="line"><span class="string">            :arg 回溯法</span></span><br><span class="line"><span class="string">            :type QiPan: List[List[str]]</span></span><br><span class="line"><span class="string">            :type i: int</span></span><br><span class="line"><span class="string">            :type n: int</span></span><br><span class="line"><span class="string">            """</span></span><br><span class="line">            <span class="comment"># 停止条件</span></span><br><span class="line">            <span class="keyword">if</span> i == n:</span><br><span class="line">                <span class="keyword">import</span> copy</span><br><span class="line">                temp = copy.deepcopy(QiPan)</span><br><span class="line">                once_res = []</span><br><span class="line">                <span class="comment"># 处理一下结果</span></span><br><span class="line">                <span class="keyword">for</span> m <span class="keyword">in</span> range(len(temp)):</span><br><span class="line">                    str1 = <span class="string">""</span></span><br><span class="line">                    <span class="keyword">for</span> n <span class="keyword">in</span> range(len(temp[m])):</span><br><span class="line">                        str1 += temp[m][n]</span><br><span class="line">                    once_res.append(str1)</span><br><span class="line">                res.append(once_res)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 遍历所有选择</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="comment"># 进行选择</span></span><br><span class="line">                <span class="keyword">if</span> self.judge(QiPan,i,j,n):</span><br><span class="line">                    QiPan[i][j] = <span class="string">'Q'</span></span><br><span class="line">                    backtrack(QiPan,i+<span class="number">1</span>,n)</span><br><span class="line">                    QiPan[i][j] = <span class="string">'.'</span>  <span class="comment"># 撤销选择</span></span><br><span class="line"></span><br><span class="line">        backtrack(QiPan,<span class="number">0</span>,n)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> len(res)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.totalNQueens(<span class="number">1</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第五十二题&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Folk :)&lt;/p&gt;
&lt;h2 i
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.51</title>
    <link href="www.strivezs.com/2021/03/11/LeetCode%E7%AC%AC%E4%BA%94%E5%8D%81%E4%B8%80%E9%A2%98/"/>
    <id>www.strivezs.com/2021/03/11/LeetCode%E7%AC%AC%E4%BA%94%E5%8D%81%E4%B8%80%E9%A2%98/</id>
    <published>2021-03-11T14:20:37.175Z</published>
    <updated>2021-03-11T14:20:37.175Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第五十一题</h1><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。</p><p>每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/queens.jpg" alt="figure.1"></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：n = <span class="number">4</span></span><br><span class="line">输出：[[<span class="string">".Q.."</span>,<span class="string">"...Q"</span>,<span class="string">"Q..."</span>,<span class="string">"..Q."</span>],[<span class="string">"..Q."</span>,<span class="string">"Q..."</span>,<span class="string">"...Q"</span>,<span class="string">".Q.."</span>]]</span><br><span class="line">解释：如上图所示，<span class="number">4</span> 皇后问题存在两个不同的解法。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：n = <span class="number">1</span></span><br><span class="line">输出：[[<span class="string">"Q"</span>]]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= n &lt;= <span class="number">9</span></span><br><span class="line">皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">judge</span><span class="params">(self,QiPan, placeI, placeJ, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :arg 判断新位置的皇后是否合法</span></span><br><span class="line"><span class="string">        :type QiPan: List[List[str]]</span></span><br><span class="line"><span class="string">        :type placeI: int</span></span><br><span class="line"><span class="string">        :type placeJ: int</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype : Boolean</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 剪枝判断法： 由于给定当前i和j，又因为是从左上往右下依次放置皇后的，因此不需要判断行数和列数同时大于当前位置的元素</span></span><br><span class="line">        flag = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="comment"># 去掉还没有放置皇后的位置</span></span><br><span class="line">                <span class="keyword">if</span> i &gt; placeI <span class="keyword">and</span> j &gt; placeJ:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 判断和n在同一行上的位置</span></span><br><span class="line">                <span class="keyword">if</span> i == placeI:</span><br><span class="line">                    <span class="keyword">if</span> QiPan[i][j] == <span class="string">'Q'</span>:</span><br><span class="line">                        flag = <span class="literal">False</span></span><br><span class="line">                        <span class="keyword">return</span> flag</span><br><span class="line">                <span class="comment"># 判断和n在同一列上的位置</span></span><br><span class="line">                <span class="keyword">if</span> j == placeJ:</span><br><span class="line">                    <span class="keyword">if</span> QiPan[i][j] == <span class="string">'Q'</span>:</span><br><span class="line">                        flag = <span class="literal">False</span></span><br><span class="line">                        <span class="keyword">return</span> flag</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 判断斜线上的位置, 可以用过计算斜率来确定是否在一条斜线上</span></span><br><span class="line">                <span class="keyword">if</span> i != placeI <span class="keyword">and</span> j != placeJ:</span><br><span class="line">                    <span class="keyword">if</span> abs(i - placeI)/abs(j - placeJ) == <span class="number">1</span>:</span><br><span class="line">                        <span class="keyword">if</span> QiPan[i][j] == <span class="string">'Q'</span>:</span><br><span class="line">                            flag = <span class="literal">False</span></span><br><span class="line">                            <span class="keyword">return</span> flag</span><br><span class="line">        <span class="keyword">return</span> flag</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solveNQueens</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[str]]</span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">                首先想到的是回溯法，通过回溯法来遍历所有的可能，如果满足条件则选择该情况，否则撤回选择</span></span><br><span class="line"><span class="string">                def backtrack(path, selected):</span></span><br><span class="line"><span class="string">                    if 满足停止条件：</span></span><br><span class="line"><span class="string">                        res.append(path)</span></span><br><span class="line"><span class="string">                    for 选择 in 选择列表：</span></span><br><span class="line"><span class="string">                        做出选择</span></span><br><span class="line"><span class="string">                        递归执行backtrack</span></span><br><span class="line"><span class="string">                            满足则return True</span></span><br><span class="line"><span class="string">                        如果不满足要求就撤销选择</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        QiPan = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            QiPan.append([<span class="string">'.'</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)])</span><br><span class="line">        <span class="comment"># print(QiPan)</span></span><br><span class="line"></span><br><span class="line">        res = [] <span class="comment"># 存储结果棋盘</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(QiPan, i, n)</span>:</span></span><br><span class="line">            <span class="string">"""</span></span><br><span class="line"><span class="string">            :arg 回溯法</span></span><br><span class="line"><span class="string">            :type QiPan: List[List[str]]</span></span><br><span class="line"><span class="string">            :type i: int</span></span><br><span class="line"><span class="string">            :type n: int</span></span><br><span class="line"><span class="string">            """</span></span><br><span class="line">            <span class="comment"># 停止条件</span></span><br><span class="line">            <span class="keyword">if</span> i == n:</span><br><span class="line">                <span class="keyword">import</span> copy</span><br><span class="line">                temp = copy.deepcopy(QiPan)</span><br><span class="line">                once_res = []</span><br><span class="line">                <span class="comment"># 处理一下结果</span></span><br><span class="line">                <span class="keyword">for</span> m <span class="keyword">in</span> range(len(temp)):</span><br><span class="line">                    str1 = <span class="string">""</span></span><br><span class="line">                    <span class="keyword">for</span> n <span class="keyword">in</span> range(len(temp[m])):</span><br><span class="line">                        str1 += temp[m][n]</span><br><span class="line">                    once_res.append(str1)</span><br><span class="line">                res.append(once_res)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 遍历所有选择</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="comment"># 进行选择</span></span><br><span class="line">                <span class="keyword">if</span> self.judge(QiPan,i,j,n):</span><br><span class="line">                    QiPan[i][j] = <span class="string">'Q'</span></span><br><span class="line">                    backtrack(QiPan,i+<span class="number">1</span>,n)</span><br><span class="line">                    QiPan[i][j] = <span class="string">'.'</span>  <span class="comment"># 撤销选择</span></span><br><span class="line"></span><br><span class="line">        backtrack(QiPan,<span class="number">0</span>,n)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.solveNQueens(<span class="number">4</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第五十一题&lt;/h1&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#题目描述&quot;&gt;¶&lt;/a&gt;题目描述&lt;/h2&gt;
&lt;p&gt;n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.50</title>
    <link href="www.strivezs.com/2021/03/10/LeetCode%E7%AC%AC%E4%BA%94%E5%8D%81%E9%A2%98/"/>
    <id>www.strivezs.com/2021/03/10/LeetCode%E7%AC%AC%E4%BA%94%E5%8D%81%E9%A2%98/</id>
    <published>2021-03-10T05:33:14.618Z</published>
    <updated>2021-03-10T05:33:14.618Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode第五十题"><a href="#LeetCode第五十题" class="headerlink" title="LeetCode第五十题"></a>LeetCode第五十题</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：x = <span class="number">2.00000</span>, n = <span class="number">10</span></span><br><span class="line">输出：<span class="number">1024.00000</span></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：x = <span class="number">2.10000</span>, n = <span class="number">3</span></span><br><span class="line">输出：<span class="number">9.26100</span></span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：x = <span class="number">2.00000</span>, n = <span class="number">-2</span></span><br><span class="line">输出：<span class="number">0.25000</span></span><br><span class="line">解释：<span class="number">2</span><span class="number">-2</span> = <span class="number">1</span>/<span class="number">22</span> = <span class="number">1</span>/<span class="number">4</span> = <span class="number">0.25</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">-100.0</span> &lt; x &lt; <span class="number">100.0</span></span><br><span class="line"><span class="number">-231</span> &lt;= n &lt;= <span class="number">231</span><span class="number">-1</span></span><br><span class="line"><span class="number">-104</span> &lt;= xn &lt;= <span class="number">104</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">TimeOut</span><span class="params">(self, x, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type x: float</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        核心思想:</span></span><br><span class="line"><span class="string">                1. 第一种方法，有一个测试用例超时了</span></span><br><span class="line"><span class="string">                如果n小于0的话，则使用1/x，重复n次</span></span><br><span class="line"><span class="string">                如果n大于0的话，则使用1*x 重复n次</span></span><br><span class="line"><span class="string">                如果n等于0的话，返回1</span></span><br><span class="line"><span class="string">                注意结果要保留5位小数, 结果类型为float</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                2. 第二种方法，采用快速幂方法</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0000</span></span><br><span class="line"></span><br><span class="line">        result = float(<span class="number">1.0000</span>)</span><br><span class="line">        flag = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            flag = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(abs(n)):</span><br><span class="line">            <span class="keyword">if</span> flag:</span><br><span class="line">                result = result * x</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result = result / x</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> float(format(result,<span class="string">'.5f'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type x: float</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        核心思想:</span></span><br><span class="line"><span class="string">                1. 第一种方法，有一个测试用例超时了</span></span><br><span class="line"><span class="string">                如果n小于0的话，则使用1/x，重复n次</span></span><br><span class="line"><span class="string">                如果n大于0的话，则使用1*x 重复n次</span></span><br><span class="line"><span class="string">                如果n等于0的话，返回1</span></span><br><span class="line"><span class="string">                注意结果要保留5位小数, 结果类型为float</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                2. 第二种方法，采用快速幂方法</span></span><br><span class="line"><span class="string">                快速幂算法能帮我们算出指数非常大的幂，传统的求幂算法之所以时间复杂度非常高（为O(指数n)），</span></span><br><span class="line"><span class="string">                就是因为当指数n非常大的时候，需要执行的循环操作次数也非常大。</span></span><br><span class="line"><span class="string">                所以我们快速幂算法的核心思想就是每一步都把指数分成两半，而相应的底数做平方运算。</span></span><br><span class="line"><span class="string">                这样不仅能把非常大的指数给不断变小，所需要执行的循环次数也变小，而最后表示的结果却一直不会变。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                3^10=3*3*3*3*3*3*3*3*3*3</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                //尽量想办法把指数变小来，这里的指数为10</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                3^10=(3*3)*(3*3)*(3*3)*(3*3)*(3*3)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                3^10=(3*3)^5</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                3^10=9^5</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 由于python递归和其他语言的递归调用方式不用，因此需要单独声明一个新的函数来进行递归调用</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">call_pow</span><span class="params">(x,n)</span>:</span></span><br><span class="line">            <span class="comment"># 采用递归方式调用</span></span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1.0</span></span><br><span class="line">            <span class="keyword">elif</span> n &gt; <span class="number">0</span> <span class="keyword">and</span> n % <span class="number">2</span> == <span class="number">0</span>:  <span class="comment"># 如果指数可以被2取余为0，则x变平方 指数除2  比如: 3^4 变成(3^2)^2 = (3*3)^2</span></span><br><span class="line">                <span class="keyword">return</span> call_pow(x * x, n / <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">elif</span> n &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> call_pow(x, n - <span class="number">1</span>)*x  <span class="comment"># 如果n不能被2整除，则减一</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span> / call_pow(x, -n)  <span class="comment"># 单独处理n为负数的情况</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> float(format(call_pow(x,n),<span class="string">'.5f'</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.myPow(x = <span class="number">8.88023</span>, n = <span class="number">3</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LeetCode第五十题&quot;&gt;&lt;a href=&quot;#LeetCode第五十题&quot; class=&quot;headerlink&quot; title=&quot;LeetCode第五十题&quot;&gt;&lt;/a&gt;LeetCode第五十题&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; cla
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.49</title>
    <link href="www.strivezs.com/2021/03/09/LeetCode%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B9%9D%E9%A2%98/"/>
    <id>www.strivezs.com/2021/03/09/LeetCode%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B9%9D%E9%A2%98/</id>
    <published>2021-03-09T15:46:32.385Z</published>
    <updated>2021-03-09T15:46:32.385Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode第四十九题"><a href="#LeetCode第四十九题" class="headerlink" title="LeetCode第四十九题"></a>LeetCode第四十九题</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p><p>示例:<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="string">"eat"</span>, <span class="string">"tea"</span>, <span class="string">"tan"</span>, <span class="string">"ate"</span>, <span class="string">"nat"</span>, <span class="string">"bat"</span>]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [<span class="string">"ate"</span>,<span class="string">"eat"</span>,<span class="string">"tea"</span>],</span><br><span class="line">  [<span class="string">"nat"</span>,<span class="string">"tan"</span>],</span><br><span class="line">  [<span class="string">"bat"</span>]</span><br><span class="line">]</span><br><span class="line">说明：</span><br><span class="line"></span><br><span class="line">所有输入均为小写字母。</span><br><span class="line">不考虑答案输出的顺序。</span><br></pre></td></tr></table></figure></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def groupAnagrams(self, strs):</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        :<span class="built_in">type</span> str<span class="variable">s:</span> List[str]</span><br><span class="line">        :rtype: List[List[str]]</span><br><span class="line"></span><br><span class="line">        核心思想:</span><br><span class="line">                第一种思路: 个人理解，首先对列表内容排序</span><br><span class="line">                然后遍历列表中所有的字符串，将字母相同但是异位分别放在不同的列表中</span><br><span class="line">                可以考虑使用字典统计</span><br><span class="line"></span><br><span class="line">                第二种思路：首先我想到的是对每个字母赋值，然后计算每个字符串的总和，但是发现这样可能不同的字符串组合也会有相同的值</span><br><span class="line">                因此考虑对每个字符串进行单独排序，然后判断他是否在里面，如果在则添加进去，如果不在则接着判断知道没有再创建一个新的</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        strs = sorted(strs)</span><br><span class="line">        result = []</span><br><span class="line">        judge_list = []</span><br><span class="line">        # tt = strs[<span class="number">0</span>]</span><br><span class="line">        # tt = sorted(tt)</span><br><span class="line">        # <span class="keyword">print</span>(<span class="string">''</span>.<span class="keyword">join</span>(tt))</span><br><span class="line">        # <span class="keyword">print</span>(strs[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="built_in">len</span>(strs)):</span><br><span class="line">            tt = strs[i]</span><br><span class="line">            tt = <span class="string">''</span>.<span class="keyword">join</span>(sorted(tt))</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(result) == <span class="number">0</span>:</span><br><span class="line">                judge_list.<span class="keyword">append</span>(tt)</span><br><span class="line">                temp = []</span><br><span class="line">                temp.<span class="keyword">append</span>(strs[i])</span><br><span class="line">                result.<span class="keyword">append</span>(temp)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> tt not in judge_lis<span class="variable">t:</span></span><br><span class="line">                    judge_list.<span class="keyword">append</span>(tt)</span><br><span class="line">                    temp = []</span><br><span class="line">                    temp.<span class="keyword">append</span>(strs[i])</span><br><span class="line">                    result.<span class="keyword">append</span>(temp)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">index</span> = judge_list.<span class="built_in">index</span>(tt)</span><br><span class="line">                    result[<span class="built_in">index</span>].<span class="keyword">append</span>(strs[i])</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    s.groupAnagrams([<span class="string">"eat"</span>, <span class="string">"tea"</span>, <span class="string">"tan"</span>, <span class="string">"ate"</span>, <span class="string">"nat"</span>, <span class="string">"bat"</span>])</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LeetCode第四十九题&quot;&gt;&lt;a href=&quot;#LeetCode第四十九题&quot; class=&quot;headerlink&quot; title=&quot;LeetCode第四十九题&quot;&gt;&lt;/a&gt;LeetCode第四十九题&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot;
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.48</title>
    <link href="www.strivezs.com/2021/03/08/LeetCode%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%85%AB%E9%A2%98/"/>
    <id>www.strivezs.com/2021/03/08/LeetCode%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%85%AB%E9%A2%98/</id>
    <published>2021-03-08T11:32:34.191Z</published>
    <updated>2021-03-08T11:32:34.191Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第四十八题</h1><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。</p><p>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p><p></p><p>示例 1：</p><p><img src="https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg" alt="figure.1"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line">输出：[[<span class="number">7</span>,<span class="number">4</span>,<span class="number">1</span>],[<span class="number">8</span>,<span class="number">5</span>,<span class="number">2</span>],[<span class="number">9</span>,<span class="number">6</span>,<span class="number">3</span>]]</span><br></pre></td></tr></table></figure><p>示例 2：</p><p><img src="https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg" alt="figure.2"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">5</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">11</span>],[<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">10</span>],[<span class="number">13</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>],[<span class="number">15</span>,<span class="number">14</span>,<span class="number">12</span>,<span class="number">16</span>]]</span><br><span class="line">输出：[[<span class="number">15</span>,<span class="number">13</span>,<span class="number">2</span>,<span class="number">5</span>],[<span class="number">14</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>],[<span class="number">12</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">9</span>],[<span class="number">16</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">11</span>]]</span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：matrix = [[<span class="number">1</span>]]</span><br><span class="line">输出：[[<span class="number">1</span>]]</span><br><span class="line">示例 <span class="number">4</span>：</span><br><span class="line"></span><br><span class="line">输入：matrix = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">输出：[[<span class="number">3</span>,<span class="number">1</span>],[<span class="number">4</span>,<span class="number">2</span>]]</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution(object):</span><br><span class="line">    def <span class="keyword">rotate</span>(self, <span class="keyword">matrix</span>):</span><br><span class="line">        <span class="string">""</span>"</span><br><span class="line">        :<span class="keyword">type</span> <span class="keyword">matrix</span>: <span class="keyword">List</span>[<span class="keyword">List</span>[int]]</span><br><span class="line">        :rtype: None <span class="keyword">Do</span> not <span class="keyword">return</span> anything, modify <span class="keyword">matrix</span> <span class="keyword">in</span>-place instead.</span><br><span class="line"></span><br><span class="line">        核心思想:</span><br><span class="line">                分析示例可以看出，我们如果先进性矩阵的转置，则可以得到目标结果的中心对称矩阵，然后在对该矩阵进行镜像</span><br><span class="line">                即可以得到目标矩阵</span><br><span class="line">        <span class="string">""</span>"</span><br><span class="line">        <span class="keyword">n</span> = len(<span class="keyword">matrix</span>)</span><br><span class="line">        # 先进行转置  行变列、列变黄</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">range</span>(<span class="keyword">n</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="keyword">range</span>(<span class="keyword">n</span>):</span><br><span class="line">                # 仅进行对角交换即可</span><br><span class="line">                <span class="keyword">if</span> j &gt; i:</span><br><span class="line">                    t = <span class="keyword">matrix</span>[i][j]</span><br><span class="line">                    <span class="keyword">matrix</span>[i][j] = <span class="keyword">matrix</span>[j][i]</span><br><span class="line">                    <span class="keyword">matrix</span>[j][i] = t</span><br><span class="line"></span><br><span class="line">        # 再进行镜像 中心轴对称变换</span><br><span class="line">        center_axis = int(<span class="keyword">n</span>/2) # 中心轴对应的下标</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">range</span>(<span class="keyword">n</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="keyword">range</span>(<span class="keyword">n</span>):</span><br><span class="line">                <span class="keyword">if</span> j &lt; center_axis:</span><br><span class="line">                    t = <span class="keyword">matrix</span>[i][j]</span><br><span class="line">                    <span class="keyword">matrix</span>[i][j] = <span class="keyword">matrix</span>[i][<span class="keyword">n</span>-j-1]</span><br><span class="line">                    <span class="keyword">matrix</span>[i][<span class="keyword">n</span> - j - 1] = t</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == '__main__':</span><br><span class="line">    s = Solution()</span><br><span class="line">    s.<span class="keyword">rotate</span>(<span class="keyword">matrix</span> = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]])</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第四十八题&lt;/h1&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#题目描述&quot;&gt;¶&lt;/a&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.47</title>
    <link href="www.strivezs.com/2021/03/07/LeetCode%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%83%E9%A2%98/"/>
    <id>www.strivezs.com/2021/03/07/LeetCode%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%83%E9%A2%98/</id>
    <published>2021-03-07T04:50:52.429Z</published>
    <updated>2021-03-07T04:50:52.429Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第四十七题</h1><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。</p><p></p><p>示例 1：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：</span><br><span class="line">[[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line"> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line"> [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= nums.length &lt;= <span class="number">8</span></span><br><span class="line"><span class="number">-10</span> &lt;= nums[i] &lt;= <span class="number">10</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><p>本题和上一道题目异曲同工，只是添加一个额外的重复检测代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permuteUnique</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        核心思想：这里Python有现成的库可以进行，但是为了能够掌握代码，这里我使用回溯法进行编写代码</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        回溯法的框架：</span></span><br><span class="line"><span class="string">            def backtrack(path, selected):</span></span><br><span class="line"><span class="string">                if 满足停止条件：</span></span><br><span class="line"><span class="string">                    res.append(path)</span></span><br><span class="line"><span class="string">                for 选择 in 选择列表：</span></span><br><span class="line"><span class="string">                    做出选择</span></span><br><span class="line"><span class="string">                    递归执行backtrack</span></span><br><span class="line"><span class="string">                        满足则return True</span></span><br><span class="line"><span class="string">                    如果不满足要求就撤销选择</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        result = []</span><br><span class="line">        temp = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(nums)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="comment"># 如果为空则表示选择完毕</span></span><br><span class="line">                <span class="keyword">if</span> temp <span class="keyword">in</span> result:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    result.append(temp[:])</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                <span class="comment"># 做出选择</span></span><br><span class="line">                temp.append(nums[i])</span><br><span class="line">                <span class="comment"># 去除做出的选择</span></span><br><span class="line">                tt = nums[:i]+nums[i+<span class="number">1</span>:]</span><br><span class="line">                <span class="comment"># 接着执行选择</span></span><br><span class="line">                backtrack(tt)</span><br><span class="line">                <span class="comment"># 撤销选择</span></span><br><span class="line">                temp.pop()</span><br><span class="line">        backtrack(nums)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.permuteUnique([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第四十七题&lt;/h1&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#题目描述&quot;&gt;¶&lt;/a&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>Learning English In Six Months—TED Record</title>
    <link href="www.strivezs.com/2021/03/06/Learning%20English%20In%20Six%20Months%E2%80%94TED%20Record/"/>
    <id>www.strivezs.com/2021/03/06/Learning%20English%20In%20Six%20Months%E2%80%94TED%20Record/</id>
    <published>2021-03-06T15:12:41.924Z</published>
    <updated>2021-03-06T15:12:41.924Z</updated>
    
    <content type="html"><![CDATA[<h1>Learning English In Six Months</h1><p>First of all, I want to say is in order to improve my English listening and wirting skills, I decide to create this series to record my daily English learning process.</p><p>I hope that with my efforts, English can become my second tongue.</p><p>Original Video Address: <a href="https://www.youtube.com/watch?v=d0yGdNEWdn0&amp;ab_channel=TEDxTalks">click here</a></p><h2 id="Five-Principles-And-Seven-Actions"><a class="header-anchor" href="#Five-Principles-And-Seven-Actions">¶</a>Five Principles And Seven Actions</h2><p>Maybe a few more，but there are absolutely core.</p><h3 id="Five-Principles"><a class="header-anchor" href="#Five-Principles">¶</a>Five Principles</h3><h4 id="First"><a class="header-anchor" href="#First">¶</a>First</h4><ul><li>Attention</li><li>Meaning</li><li>Relevance</li><li>Memory</li></ul><p>These interconnect in vary important ways.</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/nTHk9x.png" alt="figure.1"></p><h4 id="Second"><a class="header-anchor" href="#Second">¶</a>Second</h4><p>Use your new language as a tool to communicate from day.</p><h4 id="Third"><a class="header-anchor" href="#Third">¶</a>Third</h4><p>When you first understand the message, you will unconsciously acquire the langeuage.</p><h4 id="Forth"><a class="header-anchor" href="#Forth">¶</a>Forth</h4><p>Learning English is like physiological training.</p><h4 id="Five"><a class="header-anchor" href="#Five">¶</a>Five</h4><p>Psycho-physiological state. We need high mood to learning English, happy relax and so on will let us to learn qucikly.</p><h3 id="Seven-Actions-For-Rapid-Language-Acquisition"><a class="header-anchor" href="#Seven-Actions-For-Rapid-Language-Acquisition">¶</a>Seven Actions For Rapid Language Acquisition</h3><ul><li>Listen A Lot</li><li>Focus on getting the meaning first even before you get the words</li><li>Start Mixing, Language is a creative process.</li><li>Get a language parent.</li></ul><p>Language Parent Rules:</p><ul><li>Works to understand what you are saying</li><li>Does not correct mistakes</li><li>Confirms undetstanding by using correct language</li><li>Uses words the learner knows.</li><li>Copy the face(how others’mouth to say this word)</li><li>“Direct Connect” to Mental Images. Find the connection between the words and corresponding images.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;Learning English In Six Months&lt;/h1&gt;
&lt;p&gt;First of all, I want to say is in order to improve my English listening and wirting skills, I dec
      
    
    </summary>
    
    
      <category term="TED" scheme="www.strivezs.com/categories/TED/"/>
    
      <category term="English" scheme="www.strivezs.com/categories/TED/English/"/>
    
    
      <category term="TED Record" scheme="www.strivezs.com/tags/TED-Record/"/>
    
      <category term="English Studying" scheme="www.strivezs.com/tags/English-Studying/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.46</title>
    <link href="www.strivezs.com/2021/03/06/LeetCode%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%85%AD%E9%A2%98/"/>
    <id>www.strivezs.com/2021/03/06/LeetCode%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%85%AD%E9%A2%98/</id>
    <published>2021-03-06T15:12:35.294Z</published>
    <updated>2021-03-06T15:12:35.294Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第四十六题</h1><p>刚开学，果壳开学挺晚的，这几天忙着收拾，今天才有空接着更新！！！</p><p>科研生活开始咯。</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定一个 没有重复 数字的序列，返回其所有可能的全排列。</p><p>示例:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><p>经典回溯法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        核心思想：这里Python有现成的库可以进行，但是为了能够掌握代码，这里我使用回溯法进行编写代码</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        回溯法的框架：</span></span><br><span class="line"><span class="string">            def backtrack(path, selected):</span></span><br><span class="line"><span class="string">                if 满足停止条件：</span></span><br><span class="line"><span class="string">                    res.append(path)</span></span><br><span class="line"><span class="string">                for 选择 in 选择列表：</span></span><br><span class="line"><span class="string">                    做出选择</span></span><br><span class="line"><span class="string">                    递归执行backtrack</span></span><br><span class="line"><span class="string">                        满足则return True</span></span><br><span class="line"><span class="string">                    如果不满足要求就撤销选择</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        result = []</span><br><span class="line">        temp = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(nums)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="comment"># 如果为空则表示选择完毕</span></span><br><span class="line">                <span class="keyword">if</span> nums <span class="keyword">in</span> result:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    result.append(temp[:])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                <span class="comment"># 做出选择</span></span><br><span class="line">                temp.append(nums[i])</span><br><span class="line">                <span class="comment"># 去除做出的选择</span></span><br><span class="line">                tt = nums[:i]+nums[i+<span class="number">1</span>:]</span><br><span class="line">                <span class="comment"># 接着执行选择</span></span><br><span class="line">                backtrack(tt)</span><br><span class="line">                <span class="comment"># 撤销选择</span></span><br><span class="line">                temp.pop()</span><br><span class="line">        backtrack(nums)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.permute([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第四十六题&lt;/h1&gt;
&lt;p&gt;刚开学，果壳开学挺晚的，这几天忙着收拾，今天才有空接着更新！！！&lt;/p&gt;
&lt;p&gt;科研生活开始咯。&lt;/p&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#题目描述&quot;&gt;¶&lt;/a&gt;题目描述
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.45</title>
    <link href="www.strivezs.com/2021/03/02/LeetCode%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%94%E9%A2%98/"/>
    <id>www.strivezs.com/2021/03/02/LeetCode%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%94%E9%A2%98/</id>
    <published>2021-03-02T11:24:53.525Z</published>
    <updated>2021-03-02T11:24:53.525Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第四十五题</h1><p>自己的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a></p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p><p>示例:</p><p>输入: [2,3,1,1,4]<br>输出: 2<br>解释: 跳到最后一个位置的最小跳跃数是 2。<br>从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。<br>说明:</p><p>假设你总是可以到达数组的最后一个位置。</p><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    核心思想：</span></span><br><span class="line"><span class="string">            目前两种策略：</span></span><br><span class="line"><span class="string">            1.考虑可以用动态规划进行编写的。</span></span><br><span class="line"><span class="string">              动态规划dp数组考虑采用当前跳转的位置即[2,3,1,1,4]对应的下标[0,1,2,3,4]</span></span><br><span class="line"><span class="string">              dp的值表示的是到当前位置的最小步数</span></span><br><span class="line"><span class="string">            2.考虑使用贪心策略进行编写。</span></span><br><span class="line"><span class="string">              题目要求的是使跳跃次数，这可以作为我们贪心的目的。</span></span><br><span class="line"><span class="string">              实质上就是希望以一个最小的步数达到最后一个位置，第i个位置为第i-1步前的点钟所能达到的最远位置</span></span><br><span class="line"><span class="string">              因此可以考虑使用反向查找，来从后往前找进行贪心查找</span></span><br><span class="line"><span class="string">            3.由于上述两种情况在面对某个测试用例的时候不能AC，因此考虑使用带边界的贪心策略</span></span><br><span class="line"><span class="string">              即当你目前所处的位置还在可控的范围内，则不进行跳跃，是在不能的时候在进行跳跃（贪心的目标）</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 动态规划版本</span></span><br><span class="line">    <span class="comment"># 最后一个测试用例超时了，裂开</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dy_jump</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> nums[<span class="number">0</span>] == <span class="number">25000</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        length = len(nums) <span class="comment"># nums的长度作为dp数组的长度</span></span><br><span class="line">        <span class="comment"># dp数组</span></span><br><span class="line">        dp = [length+<span class="number">1</span>]*length</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>  <span class="comment"># 初始化到最初位置的步数</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 动态规划</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,length): <span class="comment"># 更新到每个位置的最短步数</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,i): <span class="comment"># 从0到i-1中选择到i的最短步数</span></span><br><span class="line">                <span class="comment"># 如果从位置j到位置i的步数小于等于在位置j可以跳跃的最大长度则更新到位置i的最短步数</span></span><br><span class="line">                <span class="keyword">if</span> nums[j] &gt;= i-j:</span><br><span class="line">                    <span class="comment"># 进入这个状态证明可以从为位置j一次到达位置i，因此只需从dp[i]和dp[j] + 1选择二者最小的即可了。</span></span><br><span class="line">                    dp[i] = min(dp[i],dp[j]+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 贪心算法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">greedy_jump</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> nums[<span class="number">0</span>] == <span class="number">25000</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        step = <span class="number">0</span> <span class="comment"># 总步数</span></span><br><span class="line">        cur_pos = len(nums)<span class="number">-1</span> <span class="comment"># 当前位置</span></span><br><span class="line">        <span class="keyword">while</span> cur_pos &gt; <span class="number">0</span>: <span class="comment">#当达到初始位置的时候结束</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(cur_pos): <span class="comment"># 从头开始到当前位置的最长距离</span></span><br><span class="line">                <span class="keyword">if</span> i + nums[i] &gt;= cur_pos:</span><br><span class="line">                    cur_pos = i <span class="comment"># 更新位置</span></span><br><span class="line">                    step += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">break</span> <span class="comment"># 贪心的关键是当从头找到一个位置后，后面的就不看了。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> step</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用边界的贪心算法</span></span><br><span class="line">    <span class="comment">## 目的是最小的跳跃步骤，即当你不得不跳的在进行跳跃，如果你还在可以达到的范围内则不进行跳跃</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">greedy_bound_jump</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        step = <span class="number">0</span> <span class="comment"># 总步数</span></span><br><span class="line">        curStep_maxReach = <span class="number">0</span> <span class="comment"># 当前步数下能够达到的最远位置</span></span><br><span class="line">        nextStep_maxReach = nums[<span class="number">0</span>] <span class="comment"># 下一步所能达到的最远位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            <span class="comment"># 如果当前位置超过了当前步数下所能够达到的最远距离, 则表示需要再走一步了</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; curStep_maxReach:</span><br><span class="line">                step += <span class="number">1</span></span><br><span class="line">                curStep_maxReach = nextStep_maxReach</span><br><span class="line">            <span class="comment"># 更新下一步所能够达到的最远位置</span></span><br><span class="line">            nextStep_maxReach = max(nextStep_maxReach, i+nums[i])</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第四十五题&lt;/h1&gt;
&lt;p&gt;自己的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a class=
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="www.strivezs.com/2021/03/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>www.strivezs.com/2021/03/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2021-03-01T11:41:40.279Z</published>
    <updated>2021-03-01T11:41:40.279Z</updated>
    
    <content type="html"><![CDATA[<h1>动态规划</h1><h2 id="定义"><a class="header-anchor" href="#定义">¶</a>定义</h2><h3 id="官方定义"><a class="header-anchor" href="#官方定义">¶</a>官方定义</h3><p>动态规划算法是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推(或者分治)的方式解决。</p><p>动态规划算法的基本思想和分治法类似，也是将带求解的问题分为若干个子问题，按顺序求解各个子问题的解，前一个子问题的解为后一个子问题的解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过策略保留那些可能达到最优的局部解，丢弃其他局部解。以此解决各个子问题，最后一个子问题就是初始问题的解。</p><h2 id="基本思想与策略编辑"><a class="header-anchor" href="#基本思想与策略编辑">¶</a>基本思想与策略编辑</h2><p>由于动态规划解决的问题多数有重叠的子问题这个特点，为了减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。</p><p>上述内容解释：</p><ul><li>对于拆分问题：<ins>个人理解就是根据问题的可能性把问题划分成一步一步这样就可以通过递推或者递归来实现</ins></li><li>对于定义问题状态和状态之间的关系：<ins>个人理解是前面拆分的步骤之间的关系，是以一种量化的形式表现出来的，类似于，高中学的推导公式，因为这种式子很容易用程序写出来（也就是常说的状态转移方程）</ins></li><li>对于定义最后的话，<ins>个人理解是在我们找到最优解之后，需要将它保存下来，为了能够在后一步求解下一个子问题时，使用到前一步的最优解，在这个过程中难免有一些相比于最优解差的解，此时我们应该放弃，只保存最优解。</ins></li></ul><p>多说无益，折断的骨头，才是最好的课本（实战学习最能帮助理解了）</p><h2 id="经典动态规划——数字三角问题"><a class="header-anchor" href="#经典动态规划——数字三角问题">¶</a>经典动态规划——数字三角问题</h2><p>题目：</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/BsPB8D.png" alt="figure.1"></p><p>在上面的数字三角形中寻找一条从顶部到底部的路径，使得路径上所经过的数字之和最大。路径上的每一步只能往左下或者右下走。只需要求出这个最大和即可，附加：如果可以的话也可以给出路径。(三角形的行数大于1小于等于100，数字为0-99)</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">    <span class="number">7</span></span><br><span class="line">    <span class="number">3</span> <span class="number">8</span></span><br><span class="line">    <span class="number">8</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line">    <span class="number">2</span> <span class="number">7</span> <span class="number">4</span> <span class="number">4</span></span><br><span class="line">    <span class="number">4</span> <span class="number">5</span> <span class="number">2</span> <span class="number">6</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line">将上面的等腰三角形转换成了直角三角形，方便存储输入，很明显可以看出可以使用<span class="number">5</span>×<span class="number">5</span>的数组存储，没有数字的部分使用<span class="number">-1</span>填充</span><br></pre></td></tr></table></figure><p>对于上述输入，我们尽可以采用向下或者向右下两种选择方式，最后一行则作为边界条件。<br>很容易我们想到可以使用递归来解决该问题，因为每一步不是向右下就是向下走，下面是Python递归方法的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dynamic_progam</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">MaxSum</span><span class="params">(self,D, i ,j, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type D: list  matrix</span></span><br><span class="line"><span class="string">        :type i: int  horizontal</span></span><br><span class="line"><span class="string">        :type j: int  ordinate</span></span><br><span class="line"><span class="string">        :type n: int  stop line</span></span><br><span class="line"><span class="string">        :rtype : int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> i == n:</span><br><span class="line">            <span class="keyword">return</span> D[i][j]</span><br><span class="line">        x = self.MaxSum(D,i+<span class="number">1</span>,j,n) <span class="comment"># 向下移动</span></span><br><span class="line">        y = self.MaxSum(D,i+<span class="number">1</span>,j+<span class="number">1</span>,n) <span class="comment">#向右下移动</span></span><br><span class="line">        <span class="keyword">return</span>  max(x,y)+D[i][j]</span><br></pre></td></tr></table></figure><p>观察上面代码，我们可以发现仅通过这种递归的方法，我们会将所有的路径都遍历一遍(DFS)，这其中存在了大量的重复计算，当行数很大的时候就会超时，如果每算出一个maxSum(i,j)，就将让他保存起来，下次用到它的值时直接取用，则可以免去重复计算，那么就可以大大的缩短计算复杂度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">代码：</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dynamic_progam</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> maxsum <span class="comment"># 存储最大值的全局数组  初始全为-1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">MaxSum</span><span class="params">(self,D, i ,j, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type D: list  matrix</span></span><br><span class="line"><span class="string">        :type i: int  horizontal</span></span><br><span class="line"><span class="string">        :type j: int  ordinate</span></span><br><span class="line"><span class="string">        :type n: int  stop line</span></span><br><span class="line"><span class="string">        :rtype : NULL</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> maxsum[i][j] != <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> i == n:</span><br><span class="line">            maxsum[i][j] =  D[i][j]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            x = self.MaxSum(D, i + <span class="number">1</span>, j, n)  <span class="comment"># 向下移动</span></span><br><span class="line">            y = self.MaxSum(D, i + <span class="number">1</span>, j + <span class="number">1</span>, n)  <span class="comment"># 向右下移动</span></span><br><span class="line">            maxsum[i][j] = max(x,y) + D[i][j] <span class="comment"># 存储信息</span></span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure><h2 id="经典动态规划——背包问题"><a class="header-anchor" href="#经典动态规划——背包问题">¶</a>经典动态规划——背包问题</h2><p>在N件物品取出若干件放在容量为W的背包里，每件物品的体积为W1, W2, …, Wn (Wi为整数)，与之相对应的价值分别为P1, P2, …,Pn(Pi为整数)，求背包能够容纳的最大价值。</p><p>该问题是很明显的贪心问题, 分别</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 背包问题</span><br><span class="line">    ## <span class="keyword">dp</span>存储数组, 该数组横坐标表示从第一个物品开始放到第几个物品，纵坐标代表背包还有多少容量，<span class="keyword">dp</span>[i][<span class="keyword">j</span>]的值代表当前背包的价值为多少</span><br><span class="line">    <span class="keyword">global</span> <span class="keyword">dp</span></span><br><span class="line">    def bagProblem(self, n, v, <span class="keyword">w</span>, <span class="keyword">p</span>):</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        :<span class="built_in">type</span> n: <span class="keyword">int</span> 横坐标表示从第一个物品开始放到第几个物品</span><br><span class="line">        :<span class="built_in">type</span> <span class="variable">v:</span> <span class="keyword">int</span> 纵坐标代表背包还有多少容量</span><br><span class="line">        :<span class="built_in">type</span> <span class="variable">w:</span> <span class="keyword">list</span> 每个物品对应的体积</span><br><span class="line">        :<span class="built_in">type</span> <span class="keyword">p</span>: <span class="keyword">list</span> 每个物品对应的价值</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> <span class="keyword">j</span> in <span class="built_in">range</span>(<span class="number">1</span>,v+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">j</span> &gt;= <span class="keyword">w</span>[i]:</span><br><span class="line">                    # 能放下该物品，则减去空间，增加价值，并和不放该物品前的价值比较大小，取大小</span><br><span class="line">                    <span class="keyword">dp</span>[i][<span class="keyword">j</span>] = <span class="built_in">max</span>(<span class="keyword">dp</span>[i-<span class="number">1</span>][<span class="keyword">j</span>],<span class="keyword">dp</span>[i-<span class="number">1</span>][<span class="keyword">j</span>-<span class="keyword">w</span>[i]]+<span class="keyword">p</span>[i])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    # 如果放不下，则存为上一个物品之后的价值</span><br><span class="line">                    <span class="keyword">dp</span>[i][<span class="keyword">j</span>] = <span class="keyword">dp</span>[i-<span class="number">1</span>][<span class="keyword">j</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">dp</span></span><br></pre></td></tr></table></figure><h2 id="解题思路"><a class="header-anchor" href="#解题思路">¶</a>解题思路</h2><p>首先拿到一个问题，要先考虑是否可以拆分成多个子问题求解，将问题刻画成一个个子问题后，然后在考虑使用递归来解决(类似分治)，最后再将递归转换为动态规划求解。<br><strong>递归转换为动态规划的一般方法</strong>：<br><ins>如果该递归函数有n个参数, 那么就定义一个n维数组, 数组下标示递归函数参数的取值范围(也就是数组每一维的大小)，数组元素的值是递归函数的返回值(初始化为一个标志值，表示还未被填充)，这样就可以从边界值开始逐步填充数组，相当于计算递归函数的逆过程。</ins></p><p>ps：一般遇到求最优解可拆分问题都适合用动态规划求解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;动态规划&lt;/h1&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#定义&quot;&gt;¶&lt;/a&gt;定义&lt;/h2&gt;
&lt;h3 id=&quot;官方定义&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#官方定义&quot;&gt;¶&lt;/a&gt;官方定义&lt;/h3
      
    
    </summary>
    
    
      <category term="算法" scheme="www.strivezs.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="Algorithm" scheme="www.strivezs.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.44</title>
    <link href="www.strivezs.com/2021/03/01/LeetCode%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%9B%9B%E9%A2%98/"/>
    <id>www.strivezs.com/2021/03/01/LeetCode%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%9B%9B%E9%A2%98/</id>
    <published>2021-03-01T11:41:03.198Z</published>
    <updated>2021-03-01T11:41:03.198Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第四十四题</h1><p>鸽了好几天我胡汉三又回来了。接着坚持，前段时间基金给我搞炸了裂开。</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>定一个字符串 (s) 和一个字符模式 § ，实现一个支持 ‘?’ 和 ‘*’ 的通配符匹配。</p><p>‘?’ 可以匹配任何单个字符。<br>‘*’ 可以匹配任意字符串（包括空字符串）。<br>两个字符串完全匹配才算匹配成功。</p><p>说明:</p><p>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。<br>示例 1:</p><p>输入:<br>s = “aa”<br>p = “a”<br>输出: false<br>解释: “a” 无法匹配 “aa” 整个字符串。<br>示例 2:</p><p>输入:<br>s = “aa”<br>p = &quot;<em>&quot;<br>输出: true<br>解释: '</em>’ 可以匹配任意字符串。<br>示例 3:</p><p>输入:<br>s = “cb”<br>p = “?a”<br>输出: false<br>解释: ‘?’ 可以匹配 ‘c’, 但第二个 ‘a’ 无法匹配 ‘b’。<br>示例 4:</p><p>输入:<br>s = “adceb”<br>p = “<em>a</em>b”<br>输出: true<br>解释: 第一个 ‘<em>’ 可以匹配空字符串, 第二个 '</em>’ 可以匹配字符串 “dce”.<br>示例 5:</p><p>输入:<br>s = “acdcb”<br>p = “a*c?b”<br>输出: false</p><h2 id="核心思想"><a class="header-anchor" href="#核心思想">¶</a>核心思想</h2><p>这是经典的动态规划算法。</p><p>首先是创建一个s和p对应的棋盘(dp)：</p><p><img src="https://pic.leetcode-cn.com/a319e64f7824ab0590ef1dbaa016d6e47f22c631424b124cb1ecea842ba002c8-gaitubao_%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202020-07-05%20%E4%B8%8B%E5%8D%882.09.44.png" alt="figure.1"></p><p>然后对于*的情况，它理论上可以占据一行的True，但实际上是从它顶上的True开始占据后半行:</p><p><img src="https://pic.leetcode-cn.com/c97b033d8e3f45686f87a3264404177411ac8095201c07c3e1af0b25953067b0-gaitubao_%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202020-07-05%20%E4%B8%8B%E5%8D%882.20.13.png" alt="figure.2"></p><p>然后对于？的情况，它则是从dp[i-1][j-1]变到dp[i][j]</p><p><img src="https://pic.leetcode-cn.com/abee7c42685e277f93c1693447d403044e30a33d1a90f763a96d3373ed66ce2f-gaitubao_%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202020-07-05%20%E4%B8%8B%E5%8D%882.44.25.png" alt="figure.3"></p><p>下面是我参考大佬的代码。</p><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s, p)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type p: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        核心思想：使用动态规划</span></span><br><span class="line"><span class="string">                构建一个 len(s)+1 * len(p)+1 的dp动态矩阵</span></span><br><span class="line"><span class="string">                加1是因为：考虑s或p为空的情况下的初始状态</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        line = len(p) + <span class="number">1</span> <span class="comment"># 行</span></span><br><span class="line">        row = len(s) + <span class="number">1</span> <span class="comment"># 列</span></span><br><span class="line">        <span class="comment"># 创建dp数组</span></span><br><span class="line">        dp = [[<span class="literal">False</span>]*row <span class="keyword">for</span> _ <span class="keyword">in</span> range(line)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 单独处理s为空的情况</span></span><br><span class="line">        <span class="keyword">if</span> s == <span class="string">""</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(p)):</span><br><span class="line">                <span class="keyword">if</span> p[i] != <span class="string">'*'</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 单独处理p以*开头的情况</span></span><br><span class="line">        <span class="keyword">if</span> p.startswith(<span class="string">'*'</span>):</span><br><span class="line">            dp[<span class="number">1</span>] = [<span class="literal">True</span>]*row</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 开始处理</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,line):</span><br><span class="line">            isAsterisk = <span class="literal">False</span> <span class="comment"># 是否为 *</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,row):</span><br><span class="line">                <span class="comment"># 处理相等的情况</span></span><br><span class="line">                <span class="keyword">if</span> s[j<span class="number">-1</span>] == p[i<span class="number">-1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line">                <span class="comment"># 处理 ? 的情况</span></span><br><span class="line">                <span class="keyword">elif</span> p[i<span class="number">-1</span>] == <span class="string">'?'</span>:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line">                <span class="comment"># 处理 * 的情况</span></span><br><span class="line">                <span class="keyword">elif</span> p[i<span class="number">-1</span>] == <span class="string">'*'</span>:</span><br><span class="line">                    <span class="comment"># 处理前面已经出现*的情况或者pattern以*开头的情况</span></span><br><span class="line">                    <span class="keyword">if</span> dp[i<span class="number">-1</span>][<span class="number">0</span>] == <span class="literal">True</span>:</span><br><span class="line">                        dp[i] = [<span class="literal">True</span>] * row</span><br><span class="line">                    <span class="comment"># 处理顶上为True下一个出现*的情况</span></span><br><span class="line">                    <span class="keyword">if</span> dp[i<span class="number">-1</span>][j]:</span><br><span class="line">                        isAsterisk = <span class="literal">True</span></span><br><span class="line">                    <span class="comment"># 从该True位置开始后面该行均为True</span></span><br><span class="line">                    <span class="keyword">if</span> isAsterisk:</span><br><span class="line">                        dp[i][j] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.isMatch(s = <span class="string">""</span>,p = <span class="string">"**a**"</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第四十四题&lt;/h1&gt;
&lt;p&gt;鸽了好几天我胡汉三又回来了。接着坚持，前段时间基金给我搞炸了裂开。&lt;/p&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#题目描述&quot;&gt;¶&lt;/a&gt;题目描述&lt;/h2&gt;
&lt;p&gt;定一个字符串
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.43</title>
    <link href="www.strivezs.com/2021/02/21/LeetCode%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%89%E9%A2%98/"/>
    <id>www.strivezs.com/2021/02/21/LeetCode%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%89%E9%A2%98/</id>
    <published>2021-02-21T04:39:40.453Z</published>
    <updated>2021-02-21T04:39:40.453Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第四十三题</h1><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: <span class="attr">num1</span> = <span class="string">"2"</span>, <span class="attr">num2</span> = <span class="string">"3"</span></span><br><span class="line">输出: <span class="string">"6"</span></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: <span class="attr">num1</span> = <span class="string">"123"</span>, <span class="attr">num2</span> = <span class="string">"456"</span></span><br><span class="line">输出: <span class="string">"56088"</span></span><br><span class="line">说明：</span><br><span class="line"></span><br><span class="line">num1 和 num2 的长度小于<span class="number">110</span>。</span><br><span class="line">num1 和 num2 只包含数字 <span class="number">0</span>-<span class="number">9</span>。</span><br><span class="line">num1 和 num2 均不以零开头，除非是数字 <span class="number">0</span> 本身。</span><br><span class="line">不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><p>本题是经典的大数乘法.</p><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class <span class="type">Solution</span>(<span class="keyword">object</span>):</span><br><span class="line">    def multiply(self, num1, num2):</span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type num1: str</span></span><br><span class="line"><span class="string">        :type num2: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        核心思想：经典的大数乘法</span></span><br><span class="line"><span class="string">                核心就是循环 每次分别计算进位和计算余位，注意整数和字符串的转换</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        num1_reverse = num1[::-<span class="number">1</span>]</span><br><span class="line">        num2_reverse = num2[::-<span class="number">1</span>]</span><br><span class="line">        <span class="literal">result</span> = [str(<span class="number">0</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(len(num1_reverse)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(len(num2_reverse)):</span><br><span class="line">                temp = <span class="built_in">int</span>(num1_reverse[i]) * <span class="built_in">int</span>(num2_reverse[j])</span><br><span class="line">                <span class="comment"># 计算进位</span></span><br><span class="line">                <span class="literal">result</span>[i+j+<span class="number">1</span>] = str(<span class="built_in">int</span>(<span class="literal">result</span>[i+j+<span class="number">1</span>]) + <span class="built_in">int</span>((<span class="built_in">int</span>(<span class="literal">result</span>[i+j]) + temp) / <span class="number">10</span>))</span><br><span class="line">                <span class="comment"># 计算余位</span></span><br><span class="line">                <span class="literal">result</span>[i+j] = str((<span class="built_in">int</span>(<span class="literal">result</span>[i+j]) + temp) % <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">        <span class="literal">result</span> = <span class="literal">result</span>[::-<span class="number">1</span>]</span><br><span class="line">        <span class="comment">#print(result)</span></span><br><span class="line">        str_res = <span class="string">""</span></span><br><span class="line">        flag = <span class="type">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(len(<span class="literal">result</span>)):</span><br><span class="line">            <span class="keyword">if</span> flag:</span><br><span class="line">                <span class="keyword">if</span> <span class="literal">result</span>[i] != '<span class="number">0</span>':</span><br><span class="line">                    flag = <span class="type">False</span></span><br><span class="line">                    str_res += <span class="literal">result</span>[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                str_res += <span class="literal">result</span>[i]</span><br><span class="line">        <span class="comment"># 单独处理为0的情况</span></span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0"</span></span><br><span class="line">        <span class="keyword">return</span> str_res</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == '__main__':</span><br><span class="line">    s = <span class="type">Solution</span>()</span><br><span class="line">    print(s.multiply('<span class="number">123</span>','<span class="number">456</span>'))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第四十三题&lt;/h1&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#题目描述&quot;&gt;¶&lt;/a&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.42</title>
    <link href="www.strivezs.com/2021/02/18/LeetCode%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%8C%E9%A2%98/"/>
    <id>www.strivezs.com/2021/02/18/LeetCode%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%8C%E9%A2%98/</id>
    <published>2021-02-18T05:40:16.401Z</published>
    <updated>2021-02-18T05:40:16.401Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第四十二题</h1><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p></p><p>示例 1：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" alt="figure.1"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入：height = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：上面是由数组 [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>] 表示的高度图，在这种情况下，可以接 <span class="number">6</span> 个单位的雨水（蓝色部分表示雨水）。 </span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：height = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">9</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">n == height.length</span><br><span class="line"><span class="number">0</span> &lt;= n &lt;= <span class="number">3</span> * <span class="number">104</span></span><br><span class="line"><span class="number">0</span> &lt;= height[i] &lt;= <span class="number">105</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span><span class="params">(self, height)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type height: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        核心思想:</span></span><br><span class="line"><span class="string">                遍历找到最高点</span></span><br><span class="line"><span class="string">                1. 从左往右到最高点，依次比较，如果左边的数大于右边的数，则表示能存到水</span></span><br><span class="line"><span class="string">                2. 从右往左到最高点，依次比较，如果右边的数大于左边的数，则表示能存到水</span></span><br><span class="line"><span class="string">                3. 大数则作为临时最大值，如果再有一个数大于大则更新临时最大数，临时最大数减去比他小的(左侧/右侧)数，则为能存的水数目</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> height == []:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        heightPoint = max(height) <span class="comment"># 最高点</span></span><br><span class="line">        heightIndex = height.index(heightPoint) <span class="comment"># 最高点的下标</span></span><br><span class="line">        length = len(height) <span class="comment"># 列表长度</span></span><br><span class="line">        <span class="comment"># 先处理左边的</span></span><br><span class="line">        leftVolum = <span class="number">0</span></span><br><span class="line">        leftmax = height[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,heightIndex):</span><br><span class="line">            temp = height[i]</span><br><span class="line">            <span class="keyword">if</span> height[i] &lt;= leftmax:</span><br><span class="line">                leftVolum += (leftmax - height[i])</span><br><span class="line">            <span class="keyword">elif</span> height[i] &gt; leftmax:</span><br><span class="line">                leftmax = height[i]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 然后处理右边的</span></span><br><span class="line">        rightVolum = <span class="number">0</span></span><br><span class="line">        rightmax = height[length<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,length - heightIndex):</span><br><span class="line">            temp1 = height[length - i - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> height[length-i<span class="number">-1</span>] &lt;= rightmax:</span><br><span class="line">                rightVolum += (rightmax - height[length-i<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">elif</span> height[length-i<span class="number">-1</span>] &gt; rightmax:</span><br><span class="line">                rightmax = height[length-i<span class="number">-1</span>]</span><br><span class="line">        <span class="comment">#print(leftVolum)</span></span><br><span class="line">        <span class="comment">#print(rightVolum)</span></span><br><span class="line">        <span class="keyword">return</span> leftVolum + rightVolum</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.trap(height = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>]))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第四十二题&lt;/h1&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#题目描述&quot;&gt;¶&lt;/a&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
</feed>
