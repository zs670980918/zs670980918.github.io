<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>StriveZs的博客</title>
  
  <subtitle>Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="www.strivezs.com/"/>
  <updated>2021-05-23T13:52:45.816Z</updated>
  <id>www.strivezs.com/</id>
  
  <author>
    <name>StriveZs</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode No.116</title>
    <link href="www.strivezs.com/2021/05/23/LeetCode%E7%AC%AC116%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/23/LeetCode%E7%AC%AC116%E9%A2%98/</id>
    <published>2021-05-23T13:52:45.816Z</published>
    <updated>2021-05-23T13:52:45.816Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第116题—填充每个节点的下一个右侧节点指针</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct <span class="keyword">Node</span> <span class="title">&#123;</span></span><br><span class="line"><span class="title">  int</span> val;</span><br><span class="line">  <span class="keyword">Node</span> <span class="title">*left</span>;</span><br><span class="line">  <span class="keyword">Node</span> <span class="title">*right</span>;</span><br><span class="line">  <span class="keyword">Node</span> <span class="title">*next</span>;</span><br><span class="line">&#125;</span><br><span class="line">填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</span><br><span class="line"></span><br><span class="line">初始状态下，所有 next 指针都被设置为 NULL。</span><br><span class="line"></span><br><span class="line">进阶：</span><br><span class="line"></span><br><span class="line">你只能使用常量级额外空间。</span><br><span class="line">使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2019/02/14/116_sample.png" alt="figure.1"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">输出：[<span class="number">1</span>,#,<span class="number">2</span>,<span class="number">3</span>,#,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,#]</span><br><span class="line">解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，<span class="string">'#'</span> 标志着每一层的结束。</span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">树中节点的数量少于 <span class="number">4096</span></span><br><span class="line"><span class="number">-1000</span> &lt;= node.val &lt;= <span class="number">1000</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><p>采用带记忆的前序遍历即可。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, val=<span class="number">0</span>, left=None, right=None, <span class="keyword">next</span>=None)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.val = val</span><br><span class="line">        <span class="keyword">self</span>.left = left</span><br><span class="line">        <span class="keyword">self</span>.right = right</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">next</span> = <span class="keyword">next</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="title">object</span>):</span></span><br><span class="line">    depth_dict = dict() <span class="comment"># 深度字典</span></span><br><span class="line">    <span class="comment"># fixme:采用bfs添加深度，将相同的深度放在同一个列表中</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(<span class="keyword">self</span>, node, depth)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        采用前序遍历</span></span><br><span class="line"><span class="string">        :param node: Node</span></span><br><span class="line"><span class="string">        :param depth: Int 深度</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        <span class="keyword">if</span> node == <span class="symbol">None:</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 创建深度层次</span></span><br><span class="line">        <span class="keyword">if</span> depth <span class="keyword">not</span> <span class="keyword">in</span> <span class="keyword">self</span>.depth_dict.keys()<span class="symbol">:</span></span><br><span class="line">            <span class="keyword">self</span>.depth_dict[depth] = list()</span><br><span class="line">        <span class="comment"># 处理在同一深度的节点</span></span><br><span class="line">        <span class="symbol">else:</span></span><br><span class="line">            <span class="comment"># 带记忆的处理方式，将链尾的值指向下一个同深度的节点</span></span><br><span class="line">            <span class="keyword">self</span>.depth_dict[depth][-<span class="number">1</span>].<span class="keyword">next</span> = node</span><br><span class="line">        <span class="keyword">self</span>.depth_dict[depth].append(node) <span class="comment"># 将结点存进去</span></span><br><span class="line">        <span class="keyword">self</span>.bfs(node.left,depth+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">self</span>.bfs(node.right,depth+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(<span class="keyword">self</span>, root)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        :type root: Node</span></span><br><span class="line"><span class="string">        :rtype: Node</span></span><br><span class="line"><span class="string">        核心思想:</span></span><br><span class="line"><span class="string">            完美二叉树：它的所有叶子节点都在同一层，每个父结点都有两个叶子结点</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            类似DFS的感觉，将节点分层，一层的都添加到一个队列中。</span></span><br><span class="line"><span class="string">            可以考虑设置深度，将一个深度的放在同一个列表中，构建深度字典</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        depth_dict = dict() <span class="comment"># 深度词典初始化</span></span><br><span class="line">        <span class="keyword">self</span>.bfs(root,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第116题—填充每个节点的下一个右侧节点指针&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.115</title>
    <link href="www.strivezs.com/2021/05/22/LeetCode%E7%AC%AC115%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/22/LeetCode%E7%AC%AC115%E9%A2%98/</id>
    <published>2021-05-22T11:31:58.743Z</published>
    <updated>2021-05-22T11:31:58.743Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第115题—不同的子序列</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。</p><p>字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，“ACE” 是 “ABCDE” 的一个子序列，而 “AEC” 不是）</p><p>题目数据保证答案符合 32 位带符号整数范围。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"rabbbit"</span>, t = <span class="string">"rabbit"</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line">如下图所示, 有 <span class="number">3</span> 种可以从 s 中得到 <span class="string">"rabbit"</span> 的方案。</span><br><span class="line">(上箭头符号 ^ 表示选取的字母)</span><br><span class="line">rabbbit</span><br><span class="line">^^^^ ^^</span><br><span class="line">rabbbit</span><br><span class="line">^^ ^^^^</span><br><span class="line">rabbbit</span><br><span class="line">^^^ ^^^</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"babgbag"</span>, t = <span class="string">"bag"</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：</span><br><span class="line">如下图所示, 有 <span class="number">5</span> 种可以从 s 中得到 <span class="string">"bag"</span> 的方案。 </span><br><span class="line">(上箭头符号 ^ 表示选取的字母)</span><br><span class="line">babgbag</span><br><span class="line">^^ ^</span><br><span class="line">babgbag</span><br><span class="line">^^    ^</span><br><span class="line">babgbag</span><br><span class="line">^    ^^</span><br><span class="line">babgbag</span><br><span class="line">  ^  ^^</span><br><span class="line">babgbag</span><br><span class="line">    ^^^</span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> &lt;= s.length, t.length &lt;= <span class="number">1000</span></span><br><span class="line">s 和 t 由英文字母组成</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def numDistinct(self, s, t):</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        :<span class="built_in">type</span> <span class="variable">s:</span> str</span><br><span class="line">        :<span class="built_in">type</span> <span class="variable">t:</span> str</span><br><span class="line">        :rtype: <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">        核心思想:</span><br><span class="line"></span><br><span class="line">            字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。</span><br><span class="line">            （例如，<span class="string">"ACE"</span> 是 <span class="string">"ABCDE"</span> 的一个子序列，而 <span class="string">"AEC"</span> 不是</span><br><span class="line">            动态规划和递归的区别:</span><br><span class="line">                <span class="keyword">dp</span>是一种不带重复计算的递归，想出<span class="keyword">dp</span>往往也是像想出递归那样，都需要从子问题入手，正确定义子问题，递归想出结束条件，</span><br><span class="line">                <span class="keyword">dp</span>想出base case，递归想出递归公式，<span class="keyword">dp</span>想出递推公式。递归加入记忆化后，</span><br><span class="line">                往往稍作修改，就是<span class="keyword">dp</span>的解法</span><br><span class="line"></span><br><span class="line">            考虑使用二维动态规划</span><br><span class="line">            <span class="keyword">dp</span>[i][<span class="keyword">j</span>]：从开头到s[i-<span class="number">1</span>]的子串中，出现『从开头到t[<span class="keyword">j</span>-<span class="number">1</span>]的子串』的 次数。</span><br><span class="line">            即：前i个字符的s子串中，出现前<span class="keyword">j</span>个字符的t子串的次数。</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        len_s = <span class="built_in">len</span>(s)</span><br><span class="line">        len_t = <span class="built_in">len</span>(t)</span><br><span class="line">        <span class="keyword">dp</span> = [[<span class="number">0</span>] * (len_s + <span class="number">1</span>) <span class="keyword">for</span> i in <span class="built_in">range</span>(len_t+<span class="number">1</span>)] # 生成<span class="keyword">dp</span>数组, +<span class="number">1</span>是为了考虑空串的情况</span><br><span class="line">        # <span class="keyword">print</span>(<span class="keyword">dp</span>)</span><br><span class="line">        # 当t的子字符串为空字符串时</span><br><span class="line">        <span class="keyword">for</span> i in <span class="built_in">range</span>(len_s + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">dp</span>[<span class="number">0</span>][i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="number">1</span>,len_t+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> <span class="keyword">j</span> in <span class="built_in">range</span>(<span class="number">1</span>,len_s+<span class="number">1</span>):</span><br><span class="line">                # 当s的子字符串为空字符串时</span><br><span class="line">                # s为空串，无论怎么删去元素，s还是无法变成t</span><br><span class="line">                # 处理其他情况</span><br><span class="line">                # 数组i不变<span class="keyword">j</span>+<span class="number">1</span>的时候，这时就相当于s增加了一个元素，以s=<span class="string">'ba'</span> t=<span class="string">'b'</span>为例</span><br><span class="line">                # 此时<span class="keyword">dp</span>[<span class="number">1</span>][<span class="number">2</span>]=<span class="number">1</span>，<span class="keyword">j</span>要加<span class="number">1</span>变成<span class="keyword">dp</span>[<span class="number">1</span>][<span class="number">3</span>]了，这时s就变成了<span class="string">'bab'</span></span><br><span class="line">                # 因此需要判断t[i]和新增的s[<span class="keyword">j</span>+<span class="number">1</span>]是否相等，如果不等的话，则<span class="keyword">dp</span>[i][<span class="keyword">j</span>+<span class="number">1</span>]=<span class="keyword">dp</span>[i][<span class="keyword">j</span>]</span><br><span class="line">                # 如果相等的话，同时去掉i和<span class="keyword">j</span>+<span class="number">1</span>分别看剩下的s和t是否有多个匹配，因此<span class="keyword">dp</span>[i][<span class="keyword">j</span>+<span class="number">1</span>] = <span class="keyword">dp</span>[i][<span class="keyword">j</span>]+<span class="keyword">dp</span>[i-<span class="number">1</span>][<span class="keyword">j</span>]</span><br><span class="line">                <span class="keyword">if</span> s[<span class="keyword">j</span>-<span class="number">1</span>] == t[i-<span class="number">1</span>]: # -<span class="number">1</span>是因为上面循环算上了<span class="string">""</span>字符串的情况</span><br><span class="line">                    <span class="keyword">dp</span>[i][<span class="keyword">j</span>] = <span class="keyword">dp</span>[i][<span class="keyword">j</span>-<span class="number">1</span>] + <span class="keyword">dp</span>[i-<span class="number">1</span>][<span class="keyword">j</span>-<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">dp</span>[i][<span class="keyword">j</span>] = <span class="keyword">dp</span>[i][<span class="keyword">j</span>-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">dp</span>[-<span class="number">1</span>][-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    <span class="keyword">print</span>(s.numDistinct(s = <span class="string">"rabbbit"</span>, t = <span class="string">"rabbit"</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第115题—不同的子序列&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)&lt;/p
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.114</title>
    <link href="www.strivezs.com/2021/05/21/LeetCode%E7%AC%AC114%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/21/LeetCode%E7%AC%AC114%E9%A2%98/</id>
    <published>2021-05-21T15:39:58.907Z</published>
    <updated>2021-05-21T15:39:58.907Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第114题—二叉树展开为链表</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给你二叉树的根结点 root ，请你将它展开为一个单链表：</p><p>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。<br>展开后的单链表应该与二叉树 先序遍历 顺序相同。</p><p><img src="https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg" alt="figure.1"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="number">6</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="literal">null</span>,<span class="number">2</span>,<span class="literal">null</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="number">5</span>,<span class="literal">null</span>,<span class="number">6</span>]</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">0</span>]</span><br><span class="line">输出：[<span class="number">0</span>]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">树中结点数在范围 [<span class="number">0</span>, <span class="number">2000</span>] 内</span><br><span class="line"><span class="number">-100</span> &lt;= Node.val &lt;= <span class="number">100</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val=<span class="number">0</span>, left=None, right=None)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flatten</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.flatten(root.left)</span><br><span class="line">        self.flatten(root.right)</span><br><span class="line"></span><br><span class="line">        right = root.right</span><br><span class="line">        <span class="comment"># 将左子树替换掉右子树</span></span><br><span class="line">        root.right = root.left</span><br><span class="line">        root.left = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 找到右子树最右的节点，接上原右子树</span></span><br><span class="line">        p = root</span><br><span class="line">        <span class="keyword">while</span> (p.right != <span class="literal">None</span>):</span><br><span class="line">            p = p.right</span><br><span class="line">        p.right = right</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第114题—二叉树展开为链表&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)&lt;
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.113</title>
    <link href="www.strivezs.com/2021/05/19/LeetCode%E7%AC%AC113%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/19/LeetCode%E7%AC%AC113%E9%A2%98/</id>
    <published>2021-05-19T12:10:21.212Z</published>
    <updated>2021-05-19T12:10:21.212Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第113题—路径总和II</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p><p>叶子节点 是指没有子节点的节点。</p><p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsumii1.jpg" alt="figure.1"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="literal">null</span>,<span class="number">13</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">5</span>,<span class="number">1</span>], targetSum = <span class="number">22</span></span><br><span class="line">输出：[[<span class="number">5</span>,<span class="number">4</span>,<span class="number">11</span>,<span class="number">2</span>],[<span class="number">5</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>]]</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg" alt="figure.2"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], targetSum = <span class="number">5</span></span><br><span class="line">输出：[]</span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>], targetSum = <span class="number">0</span></span><br><span class="line">输出：[]</span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">树中节点总数在范围 [<span class="number">0</span>, <span class="number">5000</span>] 内</span><br><span class="line"><span class="number">-1000</span> &lt;= Node.val &lt;= <span class="number">1000</span></span><br><span class="line"><span class="number">-1000</span> &lt;= targetSum &lt;= <span class="number">1000</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><p>在上一题的基础上，引入了一个记录路径的数组，这里面不知道为什么</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.sum<span class="constructor">Path(<span class="params">node</span>.<span class="params">right</span>, <span class="params">curSum</span> + <span class="params">node</span>.<span class="params">val</span>, <span class="params">targetSum</span>, <span class="params">curPath</span>.<span class="params">append</span>(<span class="params">node</span>.<span class="params">val</span>)</span>)</span><br></pre></td></tr></table></figure><p>会报错，因此这里使用了temp列表来最后和curPaht+temp来得到下一层的路径。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">python</span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val=<span class="number">0</span>, left=None, right=None)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    pathList = [] <span class="comment"># 路径集合</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumPath</span><span class="params">(self, node, curSum, targetSum, curPath)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        temp = []</span><br><span class="line">        temp.append(node.val)</span><br><span class="line">        <span class="comment"># 如果到达叶子节点，则进行总和判断</span></span><br><span class="line">        <span class="keyword">if</span> node.left == <span class="literal">None</span> <span class="keyword">and</span> node.right == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> curSum + node.val == targetSum:</span><br><span class="line">                self.pathList.append(curPath + temp)</span><br><span class="line">        self.sumPath(node.left, curSum + node.val, targetSum,curPath + temp)</span><br><span class="line">        self.sumPath(node.right, curSum + node.val, targetSum, curPath + temp)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span><span class="params">(self, root, targetSum)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type targetSum: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">            采用DFS，每当遇到叶子结点，就去计算当前路径总和，如果等于targetSum, 则将路径添加进去</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.pathList = []</span><br><span class="line">        self.sumPath(root, <span class="number">0</span>, targetSum, [])</span><br><span class="line">        <span class="keyword">return</span> self.pathList</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    root = TreeNode(<span class="number">5</span>)</span><br><span class="line">    node1 = TreeNode(<span class="number">4</span>)</span><br><span class="line">    node2 = TreeNode(<span class="number">11</span>)</span><br><span class="line">    node3 = TreeNode(<span class="number">7</span>)</span><br><span class="line">    node4 = TreeNode(<span class="number">2</span>)</span><br><span class="line">    node5 = TreeNode(<span class="number">8</span>)</span><br><span class="line">    node6 = TreeNode(<span class="number">13</span>)</span><br><span class="line">    node7 = TreeNode(<span class="number">4</span>)</span><br><span class="line">    node8 = TreeNode(<span class="number">5</span>)</span><br><span class="line">    node9 = TreeNode(<span class="number">1</span>)</span><br><span class="line">    root.left = node1</span><br><span class="line">    node1.left = node2</span><br><span class="line">    node2.left = node3</span><br><span class="line">    node2.right = node4</span><br><span class="line">    root.right = node5</span><br><span class="line">    node5.left = node6</span><br><span class="line">    node5.right = node7</span><br><span class="line">    node7.left = node8</span><br><span class="line">    node7.right = node9</span><br><span class="line"></span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.pathSum(root,<span class="number">22</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第113题—路径总和II&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)&lt;/p
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>实现Vue和Flask通信</title>
    <link href="www.strivezs.com/2021/05/18/%E5%AE%9E%E7%8E%B0Vue%E5%92%8CFlask%E9%80%9A%E4%BF%A1/"/>
    <id>www.strivezs.com/2021/05/18/%E5%AE%9E%E7%8E%B0Vue%E5%92%8CFlask%E9%80%9A%E4%BF%A1/</id>
    <published>2021-05-18T09:31:24.853Z</published>
    <updated>2021-05-18T09:31:24.853Z</updated>
    
    <content type="html"><![CDATA[<h1>实现Vue和Flask通信</h1><h2 id="安装axios和实现通信"><a class="header-anchor" href="#安装axios和实现通信">¶</a>安装axios和实现通信</h2><p>这里我们通过axios来连接Vue前端和Flask后端，使用AJAX请求进行通信。使用如下命令安装</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> axios</span><br></pre></td></tr></table></figure><p>axios的使用格式:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        serverResponse: <span class="string">'res_test'</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      getData() &#123;</span><br><span class="line">        <span class="comment">// 设置对应python的接口，这里使用的是localhost:5000</span></span><br><span class="line">        <span class="keyword">const</span> path = <span class="string">'http://127.0.0.1:5000/getMsg'</span>;</span><br><span class="line">        <span class="comment">// 这里要使用 res =&gt;表示返回的数据</span></span><br><span class="line">        axios.get(path).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 这里服务器返回response为一个json对象</span></span><br><span class="line">          <span class="comment">// 通过.data来访返回的数据，然后在通过.变量名进行访问</span></span><br><span class="line">          <span class="comment">// 可以直接通过response.data取得key-value</span></span><br><span class="line">          <span class="keyword">var</span> msg = res.data.msg;</span><br><span class="line">          <span class="keyword">this</span>.serverResponse = msg; <span class="comment">// 因为不能直接使用this作为指针，因此在这之前将this赋给了then指针</span></span><br><span class="line">          alter(<span class="string">'Success'</span> + response.status + <span class="string">','</span> + response.data + <span class="string">','</span> + msg); <span class="comment">// 成功后显示提示</span></span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.error(error);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="代码及演示"><a class="header-anchor" href="#代码及演示">¶</a>代码及演示</h2><h3 id="前端代码"><a class="header-anchor" href="#前端代码">¶</a>前端代码</h3><p>对./components/HelloWorld.vue文件进行改写。代码如下:</p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!-- html部分 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><span class="template-variable">&#123;&#123; serverResponse &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!--这里使用</span></span><span class="template-variable">&#123;&#123;&#125;&#125;</span><span class="xml"><span class="comment">来引用JavaScript中赋给this的值--&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"getData"</span>&gt;</span>get data<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- js部分 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">  import axios from 'axios';</span></span><br><span class="line"><span class="xml">  export default &#123;</span></span><br><span class="line"><span class="xml">    data: function () &#123;</span></span><br><span class="line"><span class="xml">      return &#123;</span></span><br><span class="line"><span class="xml">        serverResponse: 'res_test'</span></span><br><span class="line"><span class="xml">      &#125;;</span></span><br><span class="line"><span class="xml">    &#125;,</span></span><br><span class="line"><span class="xml">    methods: &#123;</span></span><br><span class="line"><span class="xml">      getData() &#123;</span></span><br><span class="line"><span class="xml">        // 设置对应python的接口，这里使用的是localhost:5000</span></span><br><span class="line"><span class="xml">        const path = 'http://127.0.0.1:5000/getMsg';</span></span><br><span class="line"><span class="xml">        axios.get(path).then(res =&gt; &#123;</span></span><br><span class="line"><span class="xml">          // 这里服务器返回response为一个json对象</span></span><br><span class="line"><span class="xml">          // 通过.data来访返回的数据，然后在通过.变量名进行访问</span></span><br><span class="line"><span class="xml">          // 可以直接通过response.data取得key-value</span></span><br><span class="line"><span class="xml">          var msg = res.data.msg;</span></span><br><span class="line"><span class="xml">          this.serverResponse = msg; // 因为不能直接使用this作为指针，因此在这之前将this赋给了then指针</span></span><br><span class="line"><span class="xml">          alter('Success' + response.status + ',' + response.data + ',' + msg); // 成功后显示提示</span></span><br><span class="line"><span class="xml">        &#125;).catch(error =&gt; &#123;</span></span><br><span class="line"><span class="xml">          console.error(error);</span></span><br><span class="line"><span class="xml">        &#125;);</span></span><br><span class="line"><span class="xml">      &#125;</span></span><br><span class="line"><span class="xml">    &#125;,</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- css部分 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- Add "scoped" attribute to limit CSS to this component only --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span></span><br><span class="line"><span class="xml">  h1,</span></span><br><span class="line"><span class="xml">  h2 &#123;</span></span><br><span class="line"><span class="xml">    font-weight: normal;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="xml">  ul &#123;</span></span><br><span class="line"><span class="xml">    list-style-type: none;</span></span><br><span class="line"><span class="xml">    padding: 0;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="xml">  li &#123;</span></span><br><span class="line"><span class="xml">    display: inline-block;</span></span><br><span class="line"><span class="xml">    margin: 0 10px;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="xml">  a &#123;</span></span><br><span class="line"><span class="xml">    color: #42b983;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>这里主要实现了通过单击按钮来和服务器端进行交互获得数据并传回前端，将得到的数据重新来对前端进行渲染。</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/X6O7G9.png" alt="figure.1"></p><p>得到如上页面之后，我们单击get date按钮，就会像后端发送GET请求，后端服务器监听到请求之后就会返回对应的数据。</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/UZuYsL.png" alt="figure.2"></p><h3 id="客户端代码"><a class="header-anchor" href="#客户端代码">¶</a>客户端代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> jsonify</span><br><span class="line"><span class="keyword">from</span> flask_cors <span class="keyword">import</span> CORS</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">cors = CORS(app, resources=&#123;<span class="string">r"/getMsg"</span>: &#123;<span class="string">"origins"</span>: <span class="string">"*"</span>&#125;&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'test!'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 监听127.0.0.1:5000/getMsg请求</span></span><br><span class="line"><span class="meta">@app.route('/getMsg', methods=['GET', 'POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">home</span><span class="params">()</span>:</span></span><br><span class="line">    response = &#123;</span><br><span class="line">        <span class="string">'msg'</span>: <span class="string">'Hello, Python !'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;实现Vue和Flask通信&lt;/h1&gt;
&lt;h2 id=&quot;安装axios和实现通信&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#安装axios和实现通信&quot;&gt;¶&lt;/a&gt;安装axios和实现通信&lt;/h2&gt;
&lt;p&gt;这里我们通过axios来连接Vue前端和Fla
      
    
    </summary>
    
    
      <category term="Python" scheme="www.strivezs.com/categories/Python/"/>
    
      <category term="JavaScript" scheme="www.strivezs.com/categories/Python/JavaScript/"/>
    
    
      <category term="Python" scheme="www.strivezs.com/tags/Python/"/>
    
      <category term="JavaScript" scheme="www.strivezs.com/tags/JavaScript/"/>
    
      <category term="Vue" scheme="www.strivezs.com/tags/Vue/"/>
    
      <category term="Flask" scheme="www.strivezs.com/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.112</title>
    <link href="www.strivezs.com/2021/05/18/LeetCode%E7%AC%AC112%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/18/LeetCode%E7%AC%AC112%E9%A2%98/</id>
    <published>2021-05-18T09:28:53.785Z</published>
    <updated>2021-05-18T09:28:53.785Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第112题—路径总和</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。</p><p>叶子节点 是指没有子节点的节点。</p><p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg" alt="figure.1"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="literal">null</span>,<span class="number">13</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">1</span>], targetSum = <span class="number">22</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg" alt="figure.2"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], targetSum = <span class="number">5</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>], targetSum = <span class="number">0</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">树中节点的数目在范围 [<span class="number">0</span>, <span class="number">5000</span>] 内</span><br><span class="line"><span class="number">-1000</span> &lt;= Node.val &lt;= <span class="number">1000</span></span><br><span class="line"><span class="number">-1000</span> &lt;= targetSum &lt;= <span class="number">1000</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><p>执行用时：44 ms, 在所有 Python3 提交中击败了94.71%的用户内存消耗：16.6 MB, 在所有 Python3 提交中击败了47.96%的用户</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val=<span class="number">0</span>, left=None, right=None)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    flag = <span class="literal">False</span> <span class="comment"># 全局标志：表示是否存在一条路径数值加和等于目标值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumPath</span><span class="params">(self, node, curSum, targetSum)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :param node: 当前节点</span></span><br><span class="line"><span class="string">        :param curSum: 到当前节点之前的节点数值总和</span></span><br><span class="line"><span class="string">        :param targetSum: 目标总和</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 如果到达叶子节点，则进行总和判断</span></span><br><span class="line">        <span class="keyword">if</span> node.left == <span class="literal">None</span> <span class="keyword">and</span> node.right == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> curSum + node.val == targetSum:</span><br><span class="line">                self.flag = <span class="literal">True</span></span><br><span class="line">        self.sumPath(node.left,curSum+node.val,targetSum)</span><br><span class="line">        self.sumPath(node.right, curSum + node.val, targetSum)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span><span class="params">(self, root, targetSum)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type targetSum: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">            采用DFS，每当遇到叶子结点，就去计算当前路径总和，如果等于targetSum就将全局标志flag设置为True</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.sumPath(root,<span class="number">0</span>,targetSum)</span><br><span class="line">        <span class="keyword">return</span> self.flag</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第112题—路径总和&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>MAC+PyCharm+Flask+Vue.js</title>
    <link href="www.strivezs.com/2021/05/17/MAC+PyCharm+Flask+Vue.js/"/>
    <id>www.strivezs.com/2021/05/17/MAC+PyCharm+Flask+Vue.js/</id>
    <published>2021-05-17T12:47:31.582Z</published>
    <updated>2021-05-17T12:47:31.582Z</updated>
    
    <content type="html"><![CDATA[<h1>MAC+PyCharm+Flask+Vue.js</h1><h2 id="配置node-js-nvm-npm"><a class="header-anchor" href="#配置node-js-nvm-npm">¶</a>配置node.js+nvm+npm</h2><p>访问github官方地址，根据官方的文档来安装Mac版本的nvm，<a href="https://github.com/nvm-sh/nvm">click here</a></p><p>这里建议用<a href="https://github.com/nvm-sh/nvm">nvm</a>安装管理Node.js</p><p><strong>cURL:</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -<span class="keyword">o</span>- http<span class="variable">s:</span>//raw.githubusercontent.<span class="keyword">com</span>/nvm-<span class="keyword">sh</span>/nvm/v0.<span class="number">35.2</span>/install.<span class="keyword">sh</span> | bash</span><br></pre></td></tr></table></figure><p><strong>Wget:</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -qO- http<span class="variable">s:</span>//raw.githubusercontent.<span class="keyword">com</span>/nvm-<span class="keyword">sh</span>/nvm/v0.<span class="number">35.2</span>/install.<span class="keyword">sh</span> | bash</span><br></pre></td></tr></table></figure><p>nvm安装好后，重启终端，然后安装Node.js：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">nvm ls-remote</span></span><br></pre></td></tr></table></figure><p>使用上述命令来查看远程node版本，然后根据需要安装最新版本的Nodejs：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm install <span class="number">15.3</span><span class="number">.0</span></span><br></pre></td></tr></table></figure><p>安装完成之后可以使用</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm <span class="built_in">list</span></span><br></pre></td></tr></table></figure><p>来查看已经安装的nodejs版本，并且使用</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm <span class="keyword">use</span> 版本号</span><br></pre></td></tr></table></figure><p>来使用对应版本的nodejs。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm use <span class="number">15.3</span><span class="number">.0</span></span><br></pre></td></tr></table></figure><p>可以使用如下命令查看当前node版本</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">node</span> <span class="title">-v</span></span><br></pre></td></tr></table></figure><h3 id="npm切换淘宝镜像"><a class="header-anchor" href="#npm切换淘宝镜像">¶</a>npm切换淘宝镜像</h3><h4 id="临时的"><a class="header-anchor" href="#临时的">¶</a>临时的</h4><p>临时使用的命令:</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">npm</span> --registry https:<span class="regexp">//</span>registry.<span class="built_in">npm</span>.taobao.org install express</span><br></pre></td></tr></table></figure><h4 id="长久的"><a class="header-anchor" href="#长久的">¶</a>长久的</h4><p>通过如下面命令：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="built_in">config</span> <span class="built_in">set</span> registry https:<span class="comment">//registry.npm.taobao.org</span></span><br></pre></td></tr></table></figure><p>配置完成之后，可以使用如下命令来得到当前的配置。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm<span class="built_in"> config </span><span class="builtin-name">get</span> registry</span><br></pre></td></tr></table></figure><h2 id="安装Vue-js"><a class="header-anchor" href="#安装Vue-js">¶</a>安装Vue.js</h2><p>这里我在我的node.js=15.3.0进行安装vue.js。</p><p>安装vue-cli脚手架构建工具:</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">npm</span> install -g @vue-cli</span><br><span class="line"><span class="built_in">npm</span> install -g @vue/cli-init</span><br></pre></td></tr></table></figure><p>在安装好输入如下命令验证是否成功:</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue --<span class="keyword">version</span> <span class="comment">// 如果有版本号，则证明安装成功了</span></span><br></pre></td></tr></table></figure><p>安装webpack:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> -g webpack</span><br></pre></td></tr></table></figure><h2 id="创建并运行Vue-js项目"><a class="header-anchor" href="#创建并运行Vue-js项目">¶</a>创建并运行Vue.js项目</h2><h3 id="在线初始化"><a class="header-anchor" href="#在线初始化">¶</a>在线初始化</h3><p>使用cd命令进入项目目录，然后使用如下命令来初始化项目(下载template):</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">vue init webpack visProject</span></span><br></pre></td></tr></table></figure><p>然后进入项目目录, 安装项目依赖得到node-modules目录:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span></span><br></pre></td></tr></table></figure><h3 id="离线方式"><a class="header-anchor" href="#离线方式">¶</a>离线方式</h3><p>由于使用上述方式，一直显示在downloading template，这里使用的是webpack作为template，因此我考虑使用离线的方式进行初始化。</p><p>首先先去下载webpack, 可以在gitee下载，下载链接:<a href="https://gitee.com/uyulnet/vuejs-templates-webpack">click here</a><br>下载完成之后，在用户目录下面中的隐藏文件中找一下是否有.vue-templates文件夹，如果没有的话使用如下命令创建一个</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> .vue-templates</span><br></pre></td></tr></table></figure><p>创建完成之后，将下载好的文件解压之后，改名成webpack，然后将文件夹放在该目录下。然后回到你之前的目录输入如下命令来离线初始化:</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue init webpack 项目名 <span class="comment">--offline</span></span><br></pre></td></tr></table></figure><p>初始化配置如下:</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/TR9kMI.png" alt="figure.1"></p><p>初始化之后使用如下命令，将当前执行环境添加到node_modules文件夹下:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span></span><br></pre></td></tr></table></figure><h3 id="运行项目"><a class="header-anchor" href="#运行项目">¶</a>运行项目</h3><p>在完成上述配置之后，使用cd进入项目文件夹，使用如下命令来对项目进行编译:</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">run</span><span class="bash"> dev</span></span><br></pre></td></tr></table></figure><p>编译完成之后, 就可以通过localhost来访问了。出现如下页面表示运行成功了.</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/2qh71D.png" alt="figure.3"></p><h2 id="src文件以及作用"><a class="header-anchor" href="#src文件以及作用">¶</a>src文件以及作用</h2><p><img src="https://gitee.com/zyp521/upload_image/raw/master/4fuyhq.png" alt="figure.4"></p><h3 id="解决打不开的问题"><a class="header-anchor" href="#解决打不开的问题">¶</a>解决打不开的问题</h3><p>这里由于默认的我8080端口被占用了，因此可以通过修改配置文件，来给它分配新的端口来解决。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">配置文件目录: ~/config/index.js</span><br><span class="line"></span><br><span class="line">将里面dev一类下的port对应的端口号修改为<span class="number">8083</span>即可.</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/zyp521/upload_image/raw/master/Ewtcd9.png" alt="figure.2"></p><p>然后使用下面命令重新进行编译即可:</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">run</span><span class="bash"> dev</span></span><br></pre></td></tr></table></figure><h2 id="配置Flask"><a class="header-anchor" href="#配置Flask">¶</a>配置Flask</h2><p>这里使用的IDE工具是：PyCharm，关于Python环境的搭建这里就不过多赘述了，网上有很多教程。</p><h3 id="安装Flask"><a class="header-anchor" href="#安装Flask">¶</a>安装Flask</h3><p>使用如下命令安装flask库: 这里我使用的是Anaconda进行包管理。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda <span class="keyword">install</span> flask</span><br></pre></td></tr></table></figure><p>但是这里，我使用PyCharm创建一个新的项目的话，可以选择直接创建一个flask项目，选择如下:</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/EvhLHQ.png" alt="figure.5"></p><p>这样的话，是会自动在选择的解释器中安装flask的。</p><p>这里我使用的前者，因此我需要手动安装flask，安装完之后，使用PyCharm来创建一个新的Flask项目，如上图所示，创建完成之后，我们会得到如下内容:</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/lyOMJX.png" alt="figure.6"></p><p>运行app.py文件，我们可以通过访问<a href="http://127.0.0.1:5000/">http://127.0.0.1:5000/</a>来得到一下界面。</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/LzX4hb.png" alt="figure.7"></p><p>这表明我们配置完成了。综上我们分别配置好了vue和flask，后面会接着将如何使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;MAC+PyCharm+Flask+Vue.js&lt;/h1&gt;
&lt;h2 id=&quot;配置node-js-nvm-npm&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#配置node-js-nvm-npm&quot;&gt;¶&lt;/a&gt;配置node.js+nvm+npm&lt;/h2&gt;

      
    
    </summary>
    
    
      <category term="MAC" scheme="www.strivezs.com/categories/MAC/"/>
    
      <category term="Python" scheme="www.strivezs.com/categories/MAC/Python/"/>
    
      <category term="JavaScript" scheme="www.strivezs.com/categories/MAC/Python/JavaScript/"/>
    
    
      <category term="Python" scheme="www.strivezs.com/tags/Python/"/>
    
      <category term="MAC" scheme="www.strivezs.com/tags/MAC/"/>
    
      <category term="PyCharm" scheme="www.strivezs.com/tags/PyCharm/"/>
    
      <category term="JavaScript" scheme="www.strivezs.com/tags/JavaScript/"/>
    
      <category term="Vue" scheme="www.strivezs.com/tags/Vue/"/>
    
      <category term="Flask" scheme="www.strivezs.com/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.111</title>
    <link href="www.strivezs.com/2021/05/17/LeetCode%E7%AC%AC111%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/17/LeetCode%E7%AC%AC111%E9%A2%98/</id>
    <published>2021-05-17T09:10:29.457Z</published>
    <updated>2021-05-17T09:10:29.457Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第111题—二叉树的最小深度</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p>说明：叶子节点是指没有子节点的节点。</p><p><img src="https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg" alt="figure.1"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">2</span>,<span class="literal">null</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="number">5</span>,<span class="literal">null</span>,<span class="number">6</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">树中节点数的范围在 [<span class="number">0</span>, <span class="number">105</span>] 内</span><br><span class="line"><span class="number">-1000</span> &lt;= Node.val &lt;= <span class="number">1000</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><p>执行用时：944 ms, 在所有 Python 提交中击败了18.01%的用户内存消耗：92.5 MB, 在所有 Python 提交中击败了61.96%的用户</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val=<span class="number">0</span>, left=None, right=None)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    globalMinDepth = <span class="number">100000</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">depthSearch</span><span class="params">(self, node, depth)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 为叶子节点，进行深度判断</span></span><br><span class="line">        <span class="keyword">if</span> node.left == <span class="literal">None</span> <span class="keyword">and</span> node.right == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> depth &lt; self.globalMinDepth:</span><br><span class="line">                self.globalMinDepth = depth + <span class="number">1</span> <span class="comment"># +1的原因是因为这里的深度算当前的深度</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.depthSearch(node.left, depth+<span class="number">1</span>)</span><br><span class="line">        self.depthSearch(node.right, depth+<span class="number">1</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">            最小深度是从根节点到最近叶子节点的最短路径上的节点数量</span></span><br><span class="line"><span class="string">            使用DFS，设置一个全局最小深度，每当到达一个叶子结点就和当前全局最大深度进行比较</span></span><br><span class="line"><span class="string">            要确保节点是叶子节点</span></span><br><span class="line"><span class="string">            如果小于则更新全剧最小深度。</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        self.depthSearch(root,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.globalMinDepth</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    root = TreeNode(<span class="number">2</span>)</span><br><span class="line">    node1 = TreeNode(<span class="number">3</span>)</span><br><span class="line">    node2 = TreeNode(<span class="number">4</span>)</span><br><span class="line">    node3 = TreeNode(<span class="number">5</span>)</span><br><span class="line">    node4 = TreeNode(<span class="number">6</span>)</span><br><span class="line">    root.right = node1</span><br><span class="line">    node1.right = node2</span><br><span class="line">    node2.right = node3</span><br><span class="line">    node3.right = node4</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.minDepth(root))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第111题—二叉树的最小深度&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)&lt;
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.110</title>
    <link href="www.strivezs.com/2021/05/16/LeetCode%E7%AC%AC110%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/16/LeetCode%E7%AC%AC110%E9%A2%98/</id>
    <published>2021-05-16T03:48:58.100Z</published>
    <updated>2021-05-16T03:48:58.100Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第110题—平衡二叉树</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：</p><p>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg" alt="figure.1"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">2</span>：</span><br><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">4</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg" alt="figure.2"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：root = []</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">树中的节点数在范围 [<span class="number">0</span>, <span class="number">5000</span>] 内</span><br><span class="line"><span class="number">-104</span> &lt;= Node.val &lt;= <span class="number">104</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val=<span class="number">0</span>, left=None, right=None)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">depth</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        leftDepth = self.depth(node.left)</span><br><span class="line">        rightDepth = self.depth(node.right)</span><br><span class="line">        <span class="keyword">return</span> max(leftDepth,rightDepth)+<span class="number">1</span> <span class="comment"># 自底下上深度依次增加</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">            平衡二叉树是一棵每个节点的左右子树的高度差绝对值不超过1的树</span></span><br><span class="line"><span class="string">            判断方法的话，采用递归+深度的方法</span></span><br><span class="line"><span class="string">            这里还是考虑自底向上的方法</span></span><br><span class="line"><span class="string">            每往上一层的深度就增加1</span></span><br><span class="line"><span class="string">            采用先序遍历方法来遍历的话，这样就先确定左子树的深度，再确定右子树的深度</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            同样考虑使用分治的方法</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> abs(self.depth(root.left) - self.depth(root.right)) &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 分治处理每个子树</span></span><br><span class="line">        <span class="comment">## 处理左子树</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.isBalanced(root.left):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment">## 处理右子树</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.isBalanced(root.right):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    root = TreeNode(<span class="number">1</span>)</span><br><span class="line">    node1 = TreeNode(<span class="number">2</span>)</span><br><span class="line">    node2 = TreeNode(<span class="number">2</span>)</span><br><span class="line">    node3 = TreeNode(<span class="number">3</span>)</span><br><span class="line">    node4 = TreeNode(<span class="number">3</span>)</span><br><span class="line">    node5 = TreeNode(<span class="number">4</span>)</span><br><span class="line">    node6 = TreeNode(<span class="number">4</span>)</span><br><span class="line">    root.left = node1</span><br><span class="line">    root.right = node2</span><br><span class="line">    node1.left = node3</span><br><span class="line">    node1.right = node4</span><br><span class="line">    node3.left = node5</span><br><span class="line">    node3.right = node6</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.isBalanced(root))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第110题—平衡二叉树&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.109</title>
    <link href="www.strivezs.com/2021/05/16/LeetCode%E7%AC%AC109%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/16/LeetCode%E7%AC%AC109%E9%A2%98/</id>
    <published>2021-05-16T02:52:27.785Z</published>
    <updated>2021-05-16T02:52:27.785Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第109题—将有序链表转换为二叉搜索树</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">给定的有序链表： [<span class="number">-10</span>, <span class="number">-3</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">9</span>],</span><br><span class="line"></span><br><span class="line">一个可能的答案是：[<span class="number">0</span>, <span class="number">-3</span>, <span class="number">9</span>, <span class="number">-10</span>, <span class="literal">null</span>, <span class="number">5</span>], 它可以表示下面这个高度平衡二叉搜索树：</span><br><span class="line"></span><br><span class="line">      <span class="number">0</span></span><br><span class="line">     / \</span><br><span class="line">   <span class="number">-3</span>   <span class="number">9</span></span><br><span class="line">   /   /</span><br><span class="line"> <span class="number">-10</span>  <span class="number">5</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><p>两种办法，一种是非常蠢直接转换，但是十分不推荐，另一种是使用快慢指针寻找链表的中间节点的方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val=<span class="number">0</span>, next=None)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.next = next</span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val=<span class="number">0</span>, left=None, right=None)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">balancedBST</span><span class="params">(self,partNode)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">            我们需要将中间的节点作为根节点，这样就划分成一个分而治之的问题了</span></span><br><span class="line"><span class="string">            分治思想：每个划分的部分都是以中间节点作为当前子树的根节点</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(partNode) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(partNode[<span class="number">0</span>])</span><br><span class="line">        middle = int(len(partNode)/<span class="number">2</span>)</span><br><span class="line">        node = TreeNode(partNode[middle])</span><br><span class="line">        node.left = self.balancedBST(partNode[<span class="number">0</span>:middle])</span><br><span class="line">        <span class="keyword">if</span> middle == len(partNode)<span class="number">-1</span>:</span><br><span class="line">            node.right = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node.right = self.balancedBST(partNode[middle+<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nodeList2SortedList</span><span class="params">(self,node)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">            递归得到有序列表</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> node != <span class="literal">None</span>:</span><br><span class="line">            self.res.append(node.val)</span><br><span class="line">            self.nodeList2SortedList(node.next)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fastSlowPointer</span><span class="params">(self,head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">            快慢指针寻找链表中点，快指针走两步，慢指针走一步，这样当快指针走到结束时，就可以很容易的找到链表的中点</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> head.next == <span class="literal">None</span>: <span class="comment"># 下一个节点为null</span></span><br><span class="line">            <span class="keyword">return</span> TreeNode(head.val)</span><br><span class="line">        <span class="comment"># 快慢指针寻找中间节点</span></span><br><span class="line">        fastPointer = head</span><br><span class="line">        slowPointer = head</span><br><span class="line">        pre = <span class="literal">None</span> <span class="comment"># 用于划分左右子树</span></span><br><span class="line">        <span class="keyword">while</span> fastPointer != <span class="literal">None</span> <span class="keyword">and</span> fastPointer.next != <span class="literal">None</span>:</span><br><span class="line">            fastPointer = fastPointer.next.next</span><br><span class="line">            pre = slowPointer <span class="comment"># 最终得到中间节点的前一个节点，用于划分左右子树</span></span><br><span class="line">            slowPointer = slowPointer.next</span><br><span class="line">        pre.next = <span class="literal">None</span> <span class="comment"># 分割链表</span></span><br><span class="line">        <span class="comment"># 构造树以及左右子树</span></span><br><span class="line">        middleNode = TreeNode(slowPointer.val)</span><br><span class="line">        middleNode.left = self.fastSlowPointer(head) <span class="comment"># 左子树</span></span><br><span class="line">        middleNode.right = self.fastSlowPointer(slowPointer.next)</span><br><span class="line">        <span class="keyword">return</span> middleNode</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedListToBST</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">            高度平衡的二叉树：每个节点的左右子树的高度差绝对值不超过1</span></span><br><span class="line"><span class="string">            而且有要求是二叉搜索树，因此中序遍历要是升序</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            类似上一道题，这里我想一个比较蠢的办法就是将有序链表先转换为有序数组</span></span><br><span class="line"><span class="string">            然后在使用108题的方法，将有序数组转换为二叉搜索树</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            还有一个办法就是按照上一题的操作，只不过从计算列表中点，变成了找列表的中点</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        self.res = []</span><br><span class="line">        self.nodeList2SortedList(head)</span><br><span class="line">        <span class="keyword">return</span> self.balancedBST(self.res)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedListToBSTNewVersion</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">            高度平衡的二叉树：每个节点的左右子树的高度差绝对值不超过1</span></span><br><span class="line"><span class="string">            而且有要求是二叉搜索树，因此中序遍历要是升序</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            类似上一道题，这里我想一个比较蠢的办法就是将有序链表先转换为有序数组</span></span><br><span class="line"><span class="string">            然后在使用108题的方法，将有序数组转换为二叉搜索树</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            还有一个办法就是按照上一题的操作，只不过从计算列表中点，变成了找列表的中点</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.fastSlowPointer(head)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第109题—将有序链表转换为二叉搜索树&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和For
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.108</title>
    <link href="www.strivezs.com/2021/05/14/LeetCode%E7%AC%AC108%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/14/LeetCode%E7%AC%AC108%E9%A2%98/</id>
    <published>2021-05-14T05:11:38.179Z</published>
    <updated>2021-05-14T05:11:38.179Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第108题—将有序数组转换为二叉搜索树</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。</p><p>高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/r67QOX.jpg" alt="figure.1.1"></p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/lME5lp.jpg" alt="figure.1.2"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">-10</span>,<span class="number">-3</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">9</span>]</span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">-3</span>,<span class="number">9</span>,<span class="number">-10</span>,<span class="literal">null</span>,<span class="number">5</span>]</span><br><span class="line">解释：[<span class="number">0</span>,<span class="number">-10</span>,<span class="number">5</span>,<span class="literal">null</span>,<span class="number">-3</span>,<span class="literal">null</span>,<span class="number">9</span>] 也将被视为正确答案：</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/zyp521/upload_image/raw/master/kqM2k2.jpg" alt="figure.2"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">解释：[<span class="number">1</span>,<span class="number">3</span>] 和 [<span class="number">3</span>,<span class="number">1</span>] 都是高度平衡二叉搜索树。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= nums.length &lt;= <span class="number">104</span></span><br><span class="line"><span class="number">-104</span> &lt;= nums[i] &lt;= <span class="number">104</span></span><br><span class="line">nums 按 严格递增 顺序排列</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><p>执行用时：32 ms, 在所有 Python 提交中击败了59.87%的用户内存消耗：15.7 MB, 在所有 Python 提交中击败了52.76%的用户<br>经典分治思想</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val=<span class="number">0</span>, left=None, right=None)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">balancedBST</span><span class="params">(self,partNode)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(partNode) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(partNode[<span class="number">0</span>])</span><br><span class="line">        middle = int(len(partNode)/<span class="number">2</span>)</span><br><span class="line">        node = TreeNode(partNode[middle])</span><br><span class="line">        node.left = self.balancedBST(partNode[<span class="number">0</span>:middle])</span><br><span class="line">        <span class="keyword">if</span> middle == len(partNode)<span class="number">-1</span>:</span><br><span class="line">            node.right = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node.right = self.balancedBST(partNode[middle+<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedArrayToBST</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">            高度平衡的二叉树：每个节点的左右子树的高度差绝对值不超过1</span></span><br><span class="line"><span class="string">            而且有要求是二叉搜索树，因此中序遍历要是升序</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            综合上述条件，我们需要将中间的节点作为根节点，这样就划分成一个分而治之的问题了</span></span><br><span class="line"><span class="string">            分治思想：每个划分的部分都是以中间节点作为当前子树的根节点</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.balancedBST(nums)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第108题—将有序数组转换为二叉搜索树&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和For
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.107</title>
    <link href="www.strivezs.com/2021/05/13/LeetCode%E7%AC%AC107%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/13/LeetCode%E7%AC%AC107%E9%A2%98/</id>
    <published>2021-05-13T11:05:48.299Z</published>
    <updated>2021-05-13T11:05:48.299Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第107题—二叉树的层序遍历II</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定一个二叉树，返回其节点值自底向上的层序遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">给定二叉树 [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">15</span>,<span class="number">7</span>],</span><br><span class="line"></span><br><span class="line">    <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">9</span>  <span class="number">20</span></span><br><span class="line">    /  \</span><br><span class="line">   <span class="number">15</span>   <span class="number">7</span></span><br><span class="line">返回其自底向上的层序遍历为：</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [<span class="number">15</span>,<span class="number">7</span>],</span><br><span class="line">  [<span class="number">9</span>,<span class="number">20</span>],</span><br><span class="line">  [<span class="number">3</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><p>魔改102题就好了。直接reverse.<br>执行用时：40 ms, 在所有 Python3 提交中击败了76.52%的用户内存消耗：15.7 MB, 在所有 Python3 提交中击败了6.45%的用户</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, val=<span class="number">0</span>, left=None, right=None)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.val = val</span><br><span class="line">        <span class="keyword">self</span>.left = left</span><br><span class="line">        <span class="keyword">self</span>.right = right</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="title">object</span>):</span></span><br><span class="line">    res = dict()  <span class="comment"># 用字典存储对应深度的结果</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forwardSearch</span><span class="params">(<span class="keyword">self</span>, root, depth)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">if</span> root != <span class="symbol">None:</span></span><br><span class="line">            <span class="keyword">if</span> depth <span class="keyword">not</span> <span class="keyword">in</span> <span class="keyword">self</span>.res.keys()<span class="symbol">:</span></span><br><span class="line">                <span class="keyword">self</span>.res[depth] = []</span><br><span class="line">            <span class="keyword">self</span>.res[depth].append(root.val)</span><br><span class="line">            <span class="keyword">self</span>.forwardSearch(root.left, depth + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">self</span>.forwardSearch(root.right, depth + <span class="number">1</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrderBottom</span><span class="params">(<span class="keyword">self</span>, root)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">            延续二叉树的层序遍历第一期的思想</span></span><br><span class="line"><span class="string">            只不过是将最终得到的结果reverse就可以了。</span></span><br><span class="line"><span class="string">            同样是采用前序遍历，按照深度进行划分，只不过是从最大深度开始存储就可以了</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        <span class="keyword">self</span>.forwardSearch(root, <span class="number">1</span>)</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">self</span>.dic = dict()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">self</span>.res.keys()<span class="symbol">:</span></span><br><span class="line">            result.append(<span class="keyword">self</span>.res[i])</span><br><span class="line">        <span class="keyword">return</span> result[<span class="symbol">:</span><span class="symbol">:-</span><span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name_<span class="number">_</span> == <span class="string">'__main__'</span><span class="symbol">:</span></span><br><span class="line">    root = TreeNode(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.levelOrderBottom(root))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第107题—二叉树的层序遍历II&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.106</title>
    <link href="www.strivezs.com/2021/05/12/LeetCode%E7%AC%AC106%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/12/LeetCode%E7%AC%AC106%E9%A2%98/</id>
    <published>2021-05-12T15:25:25.531Z</published>
    <updated>2021-05-12T15:25:25.531Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第106题—从中序与后序遍历序列构造二叉树</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p><p>注意:<br>你可以假设树中没有重复的元素。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">例如，给出</span><br><span class="line"></span><br><span class="line">中序遍历 inorder = [<span class="number">9</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>]</span><br><span class="line">后序遍历 postorder = [<span class="number">9</span>,<span class="number">15</span>,<span class="number">7</span>,<span class="number">20</span>,<span class="number">3</span>]</span><br><span class="line">返回如下的二叉树：</span><br><span class="line"></span><br><span class="line">    <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">9</span>  <span class="number">20</span></span><br><span class="line">    /  \</span><br><span class="line">   <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><p>我只改了我105题一行代码。其实就是把后序遍历的节点从队尾读取，而对于前序遍历的话则是从队首读取就可以了</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, val=<span class="number">0</span>, left=None, right=None)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.val = val</span><br><span class="line">        <span class="keyword">self</span>.left = left</span><br><span class="line">        <span class="keyword">self</span>.right = right</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">irritationBuildTree</span><span class="params">(<span class="keyword">self</span>,postorder,inorder)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">if</span> len(postorder) == <span class="number">0</span>: <span class="comment"># 则证明没有根节点了</span></span><br><span class="line">            <span class="keyword">return</span> None</span><br><span class="line">        curRoot = postorder.pop() <span class="comment"># 获得当前子树根节点</span></span><br><span class="line">        node = TreeNode(curRoot) <span class="comment"># 生成节点</span></span><br><span class="line">        index = inorder.index(curRoot) <span class="comment"># 获得当前根节点在中序遍历中的位置，左边划分为左子树，右边为右子树</span></span><br><span class="line">        node.left = <span class="keyword">self</span>.irritationBuildTree(postorder[<span class="symbol">:index</span>],inorder[<span class="symbol">:index</span>]) <span class="comment"># 递归构建左子树</span></span><br><span class="line">        node.right = <span class="keyword">self</span>.irritationBuildTree(postorder[<span class="symbol">index:</span>],inorder[index+<span class="number">1</span><span class="symbol">:</span>]) <span class="comment"># 递归构建右子树</span></span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(<span class="keyword">self</span>, inorder, postorder)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        :type inorder: List[int]</span></span><br><span class="line"><span class="string">        :type postorder: List[int]</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">            类似上一道题，只不过从前序遍历变成了后序遍历</span></span><br><span class="line"><span class="string">            后序遍历的话，最后的元素为当前子树的根节点，其他的同理</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.irritationBuildTree(postorder, inorder)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第106题—从中序与后序遍历序列构造二叉树&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和F
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.105</title>
    <link href="www.strivezs.com/2021/05/11/LeetCode%E7%AC%AC105%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/11/LeetCode%E7%AC%AC105%E9%A2%98/</id>
    <published>2021-05-11T04:17:56.002Z</published>
    <updated>2021-05-11T04:17:56.002Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第105题—从前序与中序遍历序列构造二叉树</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>根据一棵树的前序遍历与中序遍历构造二叉树。</p><p>注意:<br>你可以假设树中没有重复的元素。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">例如，给出</span><br><span class="line"></span><br><span class="line">前序遍历 preorder = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">中序遍历 inorder = [<span class="number">9</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>]</span><br><span class="line">返回如下的二叉树：</span><br><span class="line"></span><br><span class="line">    <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">9</span>  <span class="number">20</span></span><br><span class="line">    /  \</span><br><span class="line">   <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, val=<span class="number">0</span>, left=None, right=None)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.val = val</span><br><span class="line">        <span class="keyword">self</span>.left = left</span><br><span class="line">        <span class="keyword">self</span>.right = right</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">irritationBuildTree</span><span class="params">(<span class="keyword">self</span>,preorder,inorder)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">if</span> len(preorder) == <span class="number">0</span>: <span class="comment"># 则证明没有根节点了</span></span><br><span class="line">            <span class="keyword">return</span> None</span><br><span class="line">        curRoot = preorder.pop(<span class="number">0</span>) <span class="comment"># 获得当前子树根节点</span></span><br><span class="line">        node = TreeNode(curRoot) <span class="comment"># 生成节点</span></span><br><span class="line">        index = inorder.index(curRoot) <span class="comment"># 获得当前根节点在中序遍历中的位置，左边划分为左子树，右边为右子树</span></span><br><span class="line">        node.left = <span class="keyword">self</span>.irritationBuildTree(preorder[<span class="symbol">:index</span>],inorder[<span class="symbol">:index</span>]) <span class="comment"># 递归构建左子树</span></span><br><span class="line">        node.right = <span class="keyword">self</span>.irritationBuildTree(preorder[<span class="symbol">index:</span>],inorder[index+<span class="number">1</span><span class="symbol">:</span>]) <span class="comment"># 递归构建右子树</span></span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(<span class="keyword">self</span>, preorder, inorder)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        :type preorder: List[int]</span></span><br><span class="line"><span class="string">        :type inorder: List[int]</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">            根据前序遍历和中序遍历来确定一颗二叉树</span></span><br><span class="line"><span class="string">            1.确定树的根节点,树根是当前树中所有元素在前序遍历中最先出现的元素。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            2.求解树的子树,找出根节点在中序遍历中的位置，根左边的所有元素就是左子树，</span></span><br><span class="line"><span class="string">            根右边的所有元素就是右子树。若根节点左边或右边为空，则该方向子树为空；</span></span><br><span class="line"><span class="string">            若根节点左边和右边都为空，则根节点已经为叶子节点。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            3.递归求解树,将左子树和右子树分别看成一棵二叉树，重复1、2、3步，直到所有的节点完成定位。</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.irritationBuildTree(preorder,inorder)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name_<span class="number">_</span> == <span class="string">'__main__'</span><span class="symbol">:</span></span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.irritationBuildTree([<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="number">15</span>,<span class="number">7</span>],[<span class="number">9</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>]))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第105题—从前序与中序遍历序列构造二叉树&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和F
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.104</title>
    <link href="www.strivezs.com/2021/05/10/LeetCode%E7%AC%AC104%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/10/LeetCode%E7%AC%AC104%E9%A2%98/</id>
    <published>2021-05-10T10:36:04.737Z</published>
    <updated>2021-05-10T10:36:04.737Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第104题—二叉树的最大深度</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">给定二叉树 [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">15</span>,<span class="number">7</span>]，</span><br><span class="line"></span><br><span class="line">    <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">9</span>  <span class="number">20</span></span><br><span class="line">    /  \</span><br><span class="line">   <span class="number">15</span>   <span class="number">7</span></span><br><span class="line">返回它的最大深度 <span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><p>执行用时：24 ms, 在所有 Python 提交中击败了92.24%的用户内存消耗：15.5 MB, 在所有 Python 提交中击败了85.16%的用户 深度遍历DFS，求深度</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, val=<span class="number">0</span>, left=None, right=None)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.val = val</span><br><span class="line">        <span class="keyword">self</span>.left = left</span><br><span class="line">        <span class="keyword">self</span>.right = right</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="title">object</span>):</span></span><br><span class="line">    maxdepth = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs_depth</span><span class="params">(<span class="keyword">self</span>,node,depth)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">if</span> node != <span class="symbol">None:</span></span><br><span class="line">            <span class="keyword">self</span>.dfs_depth(node.left,depth+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> depth &gt; <span class="keyword">self</span>.<span class="symbol">maxdepth:</span></span><br><span class="line">                <span class="keyword">self</span>.maxdepth = depth</span><br><span class="line">            <span class="keyword">self</span>.dfs_depth(node.right,depth+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(<span class="keyword">self</span>, root)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">            dfs遍历最大深度，效果最差</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        <span class="keyword">self</span>.dfs_depth(root,<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.maxdepth</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第104题—二叉树的最大深度&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)&lt;
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.103</title>
    <link href="www.strivezs.com/2021/05/09/LeetCode%E7%AC%AC103%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/09/LeetCode%E7%AC%AC103%E9%A2%98/</id>
    <published>2021-05-09T04:59:02.452Z</published>
    <updated>2021-05-09T04:59:02.452Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第103题—二叉树的锯齿形层序遍历</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">给定二叉树 [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">15</span>,<span class="number">7</span>],</span><br><span class="line"></span><br><span class="line">    <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">9</span>  <span class="number">20</span></span><br><span class="line">    /  \</span><br><span class="line">   <span class="number">15</span>   <span class="number">7</span></span><br><span class="line">返回锯齿形层序遍历如下：</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [<span class="number">3</span>],</span><br><span class="line">  [<span class="number">20</span>,<span class="number">9</span>],</span><br><span class="line">  [<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><p>比较懒直接把上一题的结果，拿过来，将偶数层逆序就好了。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, val=<span class="number">0</span>, left=None, right=None)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.val = val</span><br><span class="line">        <span class="keyword">self</span>.left = left</span><br><span class="line">        <span class="keyword">self</span>.right = right</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="title">object</span>):</span></span><br><span class="line">    res = dict()  <span class="comment"># 用字典存储对应深度的结果</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forwardSearch</span><span class="params">(<span class="keyword">self</span>, root, depth)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">if</span> root != <span class="symbol">None:</span></span><br><span class="line">            <span class="keyword">if</span> depth <span class="keyword">not</span> <span class="keyword">in</span> <span class="keyword">self</span>.res.keys()<span class="symbol">:</span></span><br><span class="line">                <span class="keyword">self</span>.res[depth] = []</span><br><span class="line">            <span class="keyword">self</span>.res[depth].append(root.val)</span><br><span class="line">            <span class="keyword">self</span>.forwardSearch(root.left, depth + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">self</span>.forwardSearch(root.right, depth + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">zigzagLevelOrder</span><span class="params">(<span class="keyword">self</span>, root)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">            类似上一题的方法，先得到层序的结果</span></span><br><span class="line"><span class="string">            然后将深度为偶数的结果倒序就好了</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        <span class="keyword">self</span>.res = dict()</span><br><span class="line">        <span class="keyword">self</span>.forwardSearch(root, <span class="number">1</span>)</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">self</span>.res.keys()<span class="symbol">:</span></span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span><span class="symbol">:</span></span><br><span class="line">                result.append(<span class="keyword">self</span>.res[i][<span class="symbol">:</span><span class="symbol">:-</span><span class="number">1</span>])</span><br><span class="line">            <span class="symbol">else:</span></span><br><span class="line">                result.append(<span class="keyword">self</span>.res[i])</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name_<span class="number">_</span> == <span class="string">'__main__'</span><span class="symbol">:</span></span><br><span class="line">    root = TreeNode(<span class="number">1</span>)</span><br><span class="line">    node1 = TreeNode(<span class="number">2</span>)</span><br><span class="line">    node2 = TreeNode(<span class="number">3</span>)</span><br><span class="line">    node3 = TreeNode(<span class="number">4</span>)</span><br><span class="line">    node4 = TreeNode(<span class="number">5</span>)</span><br><span class="line">    root.left = node1</span><br><span class="line">    root.right = node2</span><br><span class="line">    node1.left = node3</span><br><span class="line">    node2.right = node4</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.zigzagLevelOrder(root))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第103题—二叉树的锯齿形层序遍历&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork 
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.102</title>
    <link href="www.strivezs.com/2021/05/08/LeetCode%E7%AC%AC102%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/08/LeetCode%E7%AC%AC102%E9%A2%98/</id>
    <published>2021-05-08T07:58:17.809Z</published>
    <updated>2021-05-08T07:58:17.809Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第102题—二叉树的层序遍历</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">二叉树：[<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">15</span>,<span class="number">7</span>],</span><br><span class="line"></span><br><span class="line">    <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">9</span>  <span class="number">20</span></span><br><span class="line">    /  \</span><br><span class="line">   <span class="number">15</span>   <span class="number">7</span></span><br><span class="line">返回其层序遍历结果：</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [<span class="number">3</span>],</span><br><span class="line">  [<span class="number">9</span>,<span class="number">20</span>],</span><br><span class="line">  [<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, val=<span class="number">0</span>, left=None, right=None)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.val = val</span><br><span class="line">        <span class="keyword">self</span>.left = left</span><br><span class="line">        <span class="keyword">self</span>.right = right</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="title">object</span>):</span></span><br><span class="line">    res = dict() <span class="comment"># 用字典存储对应深度的结果</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forwardSearch</span><span class="params">(<span class="keyword">self</span>,root,depth)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">if</span> root != <span class="symbol">None:</span></span><br><span class="line">            <span class="keyword">if</span> depth <span class="keyword">not</span> <span class="keyword">in</span> <span class="keyword">self</span>.res.keys()<span class="symbol">:</span></span><br><span class="line">                <span class="keyword">self</span>.res[depth] = []</span><br><span class="line">            <span class="keyword">self</span>.res[depth].append(root.val)</span><br><span class="line">            <span class="keyword">self</span>.forwardSearch(root.left,depth+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">self</span>.forwardSearch(root.right,depth+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(<span class="keyword">self</span>, root)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">            采用前序遍历，这样的话会先访问根节点，再访问左节点，最后再访问右节点</span></span><br><span class="line"><span class="string">            对于例题中的例子:</span></span><br><span class="line"><span class="string">                    3</span></span><br><span class="line"><span class="string">                   / \</span></span><br><span class="line"><span class="string">                  9  20</span></span><br><span class="line"><span class="string">                    /  \</span></span><br><span class="line"><span class="string">                   15   7</span></span><br><span class="line"><span class="string">        前序遍历的结果正好就是 3 9 20 15 7</span></span><br><span class="line"><span class="string">        只需要添加depth就可以区分深度了</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        <span class="keyword">self</span>.forwardSearch(root,<span class="number">1</span>)</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">self</span>.res.keys()<span class="symbol">:</span></span><br><span class="line">            result.append(<span class="keyword">self</span>.res[i])</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name_<span class="number">_</span> == <span class="string">'__main__'</span><span class="symbol">:</span></span><br><span class="line">    root = TreeNode(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.levelOrder(root))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第102题—二叉树的层序遍历&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)&lt;
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.101</title>
    <link href="www.strivezs.com/2021/05/07/LeetCode%E7%AC%AC101%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/07/LeetCode%E7%AC%AC101%E9%A2%98/</id>
    <published>2021-05-07T09:20:44.668Z</published>
    <updated>2021-05-07T09:20:44.668Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第101题—对称二叉树</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定一个二叉树，检查它是否是镜像对称的。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">例如，二叉树 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">3</span>] 是对称的。</span><br><span class="line"></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">2</span></span><br><span class="line"> / \ / \</span><br><span class="line"><span class="number">3</span>  <span class="number">4</span> <span class="number">4</span>  <span class="number">3</span></span><br><span class="line"> </span><br><span class="line">但是下面这个 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="literal">null</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="number">3</span>] 则不是镜像对称的:</span><br><span class="line"></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">2</span></span><br><span class="line">   \   \</span><br><span class="line">   <span class="number">3</span>    <span class="number">3</span></span><br><span class="line"> </span><br><span class="line">进阶：</span><br><span class="line"></span><br><span class="line">你可以运用递归和迭代两种方法解决这个问题吗？</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><p>一遍AC，思路很简单。就是效率不行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMirror</span><span class="params">(self,node1,node2)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> node1 != <span class="literal">None</span> <span class="keyword">and</span> node2 == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> node1 == <span class="literal">None</span> <span class="keyword">and</span> node2 != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> node1 != <span class="literal">None</span> <span class="keyword">and</span> node2 != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> self.isMirror(node1.left, node2.right) == <span class="literal">False</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> node1.val != node2.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> self.isMirror(node1.right,node2.left) == <span class="literal">False</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">            方法①：直接中序遍历，将得到的结果，如果得到序列是对称的则证明是镜像对称的 这种方法太蠢了</span></span><br><span class="line"><span class="string">            方法②：直接使用递归一边遍历左子树，一边遍历右子树，左边采用中序遍历进行，右边的话采用镜像中序遍历的方法进行遍历即可</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.isMirror(root,root)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第101题—对称二叉树&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中变量、作用域和内存问题</title>
    <link href="www.strivezs.com/2021/05/06/JavaScript%E4%B8%AD%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/06/JavaScript%E4%B8%AD%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/</id>
    <published>2021-05-06T08:01:38.571Z</published>
    <updated>2021-05-06T08:01:38.571Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript学习笔记。  Github同步链接: <a href="https://github.com/zs670980918/JavaScript_Study">click here</a></p><h1>变量、作用域和内存问题</h1><h2 id="基本类型和引用类型的值"><a class="header-anchor" href="#基本类型和引用类型的值">¶</a>基本类型和引用类型的值</h2><p>JavaScript变量可能包含两种不同的数据类型的值：基本类型值和引用类型值。</p><ul><li>基本类型值指的是简单的数据段</li><li>引用类型值指的是那些可能由多个值构成的对象</li></ul><p>引用类型的值是保存在内存中的对象。JavaScript不允许直接访问内存中的位置，即不能直接操作对象的内存空间。</p><h3 id="动态的属性"><a class="header-anchor" href="#动态的属性">¶</a>动态的属性</h3><p>定义基本类型值和引用类型值的方法是类似的：创建一个变量并为该变量赋值。但是当这个值保存到变量中以后，对不同类型值可以执行的操作是不同的。对于引用类型的值，我们可以为其添加属性和方法，也可以改变和删除其属性和方法，如下例子:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var person = <span class="built_in">new</span> <span class="keyword">Object</span>();</span><br><span class="line">person.name = "Niko";</span><br><span class="line"><span class="keyword">alter</span>(person.name);</span><br></pre></td></tr></table></figure><p>以上代码创建了一个对象并将其保存在了变量person中，然后我们为该对象添加了一个名为name的属性，并将字符串“Niko”赋给了它。这个person就属于引用类型。而对于基本类型则无法添加属性，比如:</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var <span class="built_in">name</span> = <span class="string">"Niko"</span>;</span><br><span class="line"><span class="built_in">name</span>.age = <span class="number">13</span>; <span class="comment">// 会报错</span></span><br></pre></td></tr></table></figure><p>引用类型一般指的是对象，基本类型值的是之前提到的基本数据类型</p><h3 id="复制变量值"><a class="header-anchor" href="#复制变量值">¶</a>复制变量值</h3><p>除了保存的方式不同之外，在从一个变量向另一个变量复制基本类型值和引用类型时，也存在不同。如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制到新的变量分配的位置上。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var <span class="symbol">num1</span> = <span class="number">5</span>;</span><br><span class="line">var <span class="symbol">num2</span> = <span class="symbol">num1</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/zyp521/upload_image/raw/master/24RzR1.png" alt="figure.1"></p><p>当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。复制操作结束后，两个变量实际上将引用同一个对象，因此，<strong>改变其中一个变量，就会影响另一个变量</strong>。</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/zmvJyy.png" alt="figure.2"></p><h3 id="传递参数"><a class="header-anchor" href="#传递参数">¶</a>传递参数</h3><p>JavaScript中所有的函数的参数都是按值传递的。即把函数外部的值赋值给函数内部的参数，就和把值从一个变量复制到另一个变量一样。基本类型值的传递如同基本类型变量的复制，引用类型的值，则如同引用类型变量的值一样。</p><h3 id="检测类型"><a class="header-anchor" href="#检测类型">¶</a>检测类型</h3><p>要检测一个变量是不是基本数据类型，使用typeof操作符是最佳的工作。如果变量的值是一个对象或null，则typeof操作符会如下返回object：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">"123"</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">22</span>;</span><br><span class="line"><span class="keyword">var</span> u;</span><br><span class="line"><span class="keyword">var</span> n = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span>(s); <span class="comment">// string</span></span><br><span class="line"><span class="keyword">typeof</span>(b); <span class="comment">// number</span></span><br><span class="line"><span class="keyword">typeof</span>(i); <span class="comment">// boolean</span></span><br><span class="line"><span class="keyword">typeof</span>(u); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">typeof</span>(n); <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span>(m); <span class="comment">// object</span></span><br></pre></td></tr></table></figure><p>在检测基本数据类型时，typeof十分好用，但是在检测引用类型的值时，这个操作符用处则不大。为了知道某个值是什么类型的对象，我们可以使用instanceof操作符：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">result = variable instanceof <span class="function"><span class="keyword">constructor</span>;</span></span><br><span class="line"></span><br><span class="line">person instanceof <span class="keyword">Object</span>; <span class="comment">//变量person是Object类型的对象吗</span></span><br><span class="line">colors instanceof <span class="keyword">Array</span>; <span class="comment">//变量colors是Array吗？</span></span><br></pre></td></tr></table></figure><p>根据规定，所有引用类型的值都是Object的实例。因此，在检测一个引用类型值和Object构造函数时，instanceof操作符始终会返回True，如果用instanceof检测基本类型的值，则始终会返回false。因为基本类型不是对象。</p><h2 id="执行环境及作用域"><a class="header-anchor" href="#执行环境及作用域">¶</a>执行环境及作用域</h2><p>执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。<br>全局执行环境是最外围的一个执行环境。根据JavaScript实现所在的宿主环境不同，表示执行环境的对象也不一样。在Web浏览器中，全局执行环境是window对象，因此所有全局变量和函数都是作为window对象的属性和方法创建的。某个执行环境中的所有代码执行完之后，该环境会被销毁，保存在其中的所有变量和函数定义也会随之销毁。</p><p>当代码在一个环境中执行时，会创建变量对象的一个作用域链。<strong>作用域链</strong>的用途是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。标识符解析是沿着作用域链一级一级地搜索标识符的过程，搜索过程始终从作用域链的前段开始，然后逐级地向后回溯，直到找到标识符位为止。</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">color</span> = <span class="string">"blue"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> temp = <span class="string">"yellow"</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">color</span> == <span class="string">"blue"</span>)&#123;</span><br><span class="line">        <span class="built_in">color</span> = <span class="string">"red"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title">else</span>&#123;</span><br><span class="line">        <span class="built_in">color</span> = <span class="string">"blue"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">changeColor();</span><br></pre></td></tr></table></figure><p>上述代码中changColor()的作用域链包含两个对象：他自己的变量对象(temp)和全局环境的变量对象(color)。可以在函数内部访问全局变量color。<br>同理看下面代码：</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">color</span> = <span class="string">"blue"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> temp = <span class="string">"yellow"</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">color</span> == <span class="string">"blue"</span>)&#123;</span><br><span class="line">        <span class="built_in">color</span> = <span class="string">"red"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title">else</span>&#123;</span><br><span class="line">        <span class="built_in">color</span> = <span class="string">"blue"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">changeColor();</span><br><span class="line">alter(<span class="built_in">color</span>); <span class="comment">// 显示red</span></span><br><span class="line">alter(temp); <span class="comment">// 会报错</span></span><br></pre></td></tr></table></figure><p>这里temp为changColor的局部变量，只可以在函数的局部环境中访问，而不能在全局环境中访问，而color则是全局变量，既可以在全局环境中访问，又可以在局部环境中访问。</p><h3 id="延长作用域链"><a class="header-anchor" href="#延长作用域链">¶</a>延长作用域链</h3><p>执行环境类型总共有两种——全局和局部，但是还是有其他办法来延长作用于链。当执行流进入下列任何一个语句时，作用域链就会得到加长：</p><ul><li>try-catch语句的catch块</li><li>with语句</li></ul><p>这两个语句都会在作用域链的前端添加一个变量对象。对with语句来说，会将指定的对象添加到作用域链中，对catch语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildUrl</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> qs = <span class="string">"?debuge=true"</span>;</span><br><span class="line">    <span class="keyword">with</span>(location)&#123;</span><br><span class="line">        <span class="keyword">var</span> <span class="built_in">url</span> = href + qs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">url</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于with语句内部，定义了一个url变量，这个url就会成为函数执行环境的一部分，所有可以作为函数的值被返回。</p><h3 id="没有块级作用域"><a class="header-anchor" href="#没有块级作用域">¶</a>没有块级作用域</h3><p>JavaScript没有块级作用域，比如下面代码:</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="built_in">var</span> <span class="built_in">color</span> = <span class="string">"blue"</span>;</span><br><span class="line">&#125;</span><br><span class="line">alter(<span class="built_in">color</span>);</span><br></pre></td></tr></table></figure><p>在C++、C和Java中，color会在if语句执行完毕后被销毁。但是JavaScript中，if语句中的变量声明会将变量添加到当前的执行环境（上文的代码指的是全局环境中）。在使用for语句时一定要记住这一点差异。因为要定义i:</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (<span class="name">var</span> i=0<span class="comment">; i&lt;10; i++)&#123;</span></span><br><span class="line">    doSomething(<span class="name">i</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">alter(<span class="name">i</span>)<span class="comment">; // i=10</span></span><br></pre></td></tr></table></figure><p>这里i在for中被声明后，当退出for的块之后，这个变量i还是会存在于外部的执行环境中的。这里适合C++、Java等语言不同的地方。</p><h4 id="声明变量"><a class="header-anchor" href="#声明变量">¶</a>声明变量</h4><p>使用var声明的变量会自动被添加到最接近的环境中，在函数内部，最接近的环境就是函数的局部环境。在with语句中，最接近的环境是函数环境。如果初始化变量时没有使用var声明，该变量会自动被添加到全局环境。</p><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(num1,num2)</span>&#123;</span></span><br><span class="line">    var <span class="built_in">sum</span> = num1 + num2;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>;</span><br><span class="line">&#125;</span><br><span class="line">var result = add(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sum</span>; <span class="comment">// 会报错，因为sum在函数环境中</span></span><br></pre></td></tr></table></figure><p>但是如何在函数中sum省略了var声明，则sum会被自动添加到全局环境中。但是不建议这样使用！</p><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(num1,num2)</span>&#123;</span></span><br><span class="line">    <span class="built_in">sum</span> = num1 + num2; <span class="comment">// 声明未使用var，sum被添加到全局环境中</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>;</span><br><span class="line">&#125;</span><br><span class="line">var result = add(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sum</span>; <span class="comment">// 30</span></span><br></pre></td></tr></table></figure><p>这种声明方式不被推荐使用，应该按照严格的方式来声明变量。</p><h4 id="查询标识符"><a class="header-anchor" href="#查询标识符">¶</a>查询标识符</h4><p>当在某个环境中为了读取或写入而引用一个标识符时，必须通过搜索来确定该标识符实际代表什么。搜索过程从作用域链的前段开始，向上逐级查询与给定名字匹配的标识符。如果在局部环境中找到了该标识符，搜索过程停止，变量就绪，如果在局部环境中没有找到变量名，则继续沿着作用域链向上搜索。搜索过程将会一直追溯到全局环境的变量对象。如果在全局环境中也没有找到这个变量，则意味着该变量未声明。（先找局部环境，局部环境没有再找全局环境）</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">color</span> = <span class="string">"blue"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">color</span>;</span><br><span class="line">&#125;</span><br><span class="line">alter(getColor()); <span class="comment">// blue</span></span><br></pre></td></tr></table></figure><p>上述过程，因为函数环境中没有blue，因此搜索了全局环境中的color。</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">color</span> = <span class="string">"blue"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">color</span> = <span class="string">"red"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">color</span>;</span><br><span class="line">&#125;</span><br><span class="line">alter(getColor()); <span class="comment">// red</span></span><br></pre></td></tr></table></figure><p>上述过程，因为函数局部环境中有red，因此不需要在搜索全局环境了。</p><h2 id="垃圾收集"><a class="header-anchor" href="#垃圾收集">¶</a>垃圾收集</h2><p>JavaScript具有自动垃圾收集机制，即执行环境会负责管理代码执行过程中使用的内存。垃圾收集机制的原理：找出那些不再继续使用的变量，然后释放其占用的内存。因此垃圾收集机制会按照固定的时间间隔周期性的执行操作。</p><h3 id="标记清除"><a class="header-anchor" href="#标记清除">¶</a>标记清除</h3><p>JavaScript中最常用的垃圾收集方式是标记清除。当环境进入环境时，就将这个变量标记为进入环境。从逻辑上讲，永远不能释放进入环境的变量所占的内存，因为执行流可能要用到它们，当变量离开环境时，则将其标记为离开环境。<br>可以使用任何方法来标记变量，垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记，然后，他们会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，最后垃圾收集器完成内存清楚工作，销毁那些带有标记的值并且回收他们所占用的内存空间。</p><p>目前主流的浏览器都是采用这种垃圾收集策略的。</p><h3 id="引用计数"><a class="header-anchor" href="#引用计数">¶</a>引用计数</h3><p>另一种不太常见的垃圾收集策略叫做引用计数。引用技术的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。同样对于其他的变量也是类似的加1。而如果包含对这个值引用变量又取得了另外一个值，则这个值的引用次数就减1.当这个值的引用次数变成0之后，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。</p><h3 id="性能问题"><a class="header-anchor" href="#性能问题">¶</a>性能问题</h3><p>垃圾收集器是周期性运行的，而且如果为变量分配的内存数量很可观，那么回收工作量也是相当大的。在这种情况下，确定垃圾收集的时间间隔是十分重要的。后面JavaScript引擎的垃圾收集例程改变了工作方式：触发垃圾收集的变量分配、字面量和数组元素的临界值被调整为动态修正。</p><h3 id="内存管理"><a class="header-anchor" href="#内存管理">¶</a>内存管理</h3><p>一般来说，出于安全考虑分配给浏览器的内存数量通常要不分配给桌面应用的内存少。目的是防止运行JavaScript的网页耗尽系统全部内存而导致系统崩溃。<br>因此确保占用最少内存可以让页面获得更好地性能，一般来说对于不使用的数据，最好将其设置为null来释放其引用，这个做法叫做解决引用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JavaScript学习笔记。  Github同步链接: &lt;a href=&quot;https://github.com/zs670980918/JavaScript_Study&quot;&gt;click here&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;变量、作用域和内存问题&lt;/h1&gt;
&lt;h2 id=&quot;基本
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="www.strivezs.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="www.strivezs.com/tags/JavaScript/"/>
    
      <category term="LearningNote" scheme="www.strivezs.com/tags/LearningNote/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.100</title>
    <link href="www.strivezs.com/2021/05/06/LeetCode%E7%AC%AC%E4%B8%80%E7%99%BE%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/06/LeetCode%E7%AC%AC%E4%B8%80%E7%99%BE%E9%A2%98/</id>
    <published>2021-05-06T04:35:43.952Z</published>
    <updated>2021-05-06T04:35:43.952Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第一百题—相同的数</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><p><img src="https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg" alt="figure.1"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：p = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], q = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg" alt="figure.2"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">2</span>：</span><br><span class="line">输入：p = [<span class="number">1</span>,<span class="number">2</span>], q = [<span class="number">1</span>,<span class="literal">null</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg" alt="figure.3"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">3</span>：</span><br><span class="line">输入：p = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>], q = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">两棵树上的节点数目都在范围 [<span class="number">0</span>, <span class="number">100</span>] 内</span><br><span class="line"><span class="number">-104</span> &lt;= Node.val &lt;= <span class="number">104</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><p>执行用时：36 ms, 在所有 Python3 提交中击败了84.05%的用户内存消耗：14.9 MB, 在所有 Python3 提交中击败了53.64%的用户. 刷题的第100个，每天都在坚持，希望自己博士毕业能够把所有题刷完。</p><p>代码难得一遍AC</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val=<span class="number">0</span>, left=None, right=None)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">middle_search</span><span class="params">(self,node1,node2)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> node1 == <span class="literal">None</span> <span class="keyword">and</span> node2 == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> node1 == <span class="literal">None</span> <span class="keyword">and</span> node2 != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> node1 != <span class="literal">None</span> <span class="keyword">and</span> node2 == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> self.middle_search(node1.left,node2.left) == <span class="literal">False</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> node1.val != node2.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> self.middle_search(node1.right, node2.right) == <span class="literal">False</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span><span class="params">(self, p, q)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type p: TreeNode</span></span><br><span class="line"><span class="string">        :type q: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">                同时对两个棵树进行先序遍历、中序遍历、后序遍历都可以，执行DFS就行了，然后同时比较结果，</span></span><br><span class="line"><span class="string">            如果存在不同的情况，则返回False</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.middle_search(p,q)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第一百题—相同的数&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
</feed>
